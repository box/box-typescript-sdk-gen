(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["box-typescript-sdk-gen"] = {}));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    function __awaiter$1(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
        function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
        function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }

    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    class GeneratedCodeError extends Error {
        constructor(fields) {
            super(fields.message);
            Object.assign(this, fields);
            this.name = 'GeneratedCodeError';
            Object.setPrototypeOf(this, GeneratedCodeError.prototype);
        }
    }

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    const byteToHex = [];

    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1));
    }

    function unsafeStringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }

    const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var native = {
      randomUUID
    };

    function v4(options, buf, offset) {
      if (native.randomUUID && true && !options) {
        return native.randomUUID();
      }

      options = options || {};
      const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      return unsafeStringify(rnds);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var buffer = {};

    var base64Js = {};

    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;

    function getLens (b64) {
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=');
      if (validLen === -1) validLen = len;

      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4);

      return [validLen, placeHoldersLen]
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function toByteArray (b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

      var curByte = 0;

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen;

      var i;
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = (tmp >> 16) & 0xFF;
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        );
      }

      return parts.join('')
    }

    var ieee754 = {};

    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

    ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    };

    ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    (function (exports) {

    	const base64 = base64Js;
    	const ieee754$1 = ieee754;
    	const customInspectSymbol =
    	  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    	    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    	    : null;

    	exports.Buffer = Buffer;
    	exports.SlowBuffer = SlowBuffer;
    	exports.INSPECT_MAX_BYTES = 50;

    	const K_MAX_LENGTH = 0x7fffffff;
    	exports.kMaxLength = K_MAX_LENGTH;

    	/**
    	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
    	 *   === true    Use Uint8Array implementation (fastest)
    	 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
    	 *               implementation (most compatible, even IE6)
    	 *
    	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
    	 * Opera 11.6+, iOS 4.2+.
    	 *
    	 * We report that the browser does not support typed arrays if the are not subclassable
    	 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
    	 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
    	 * for __proto__ and has a buggy typed array implementation.
    	 */
    	Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    	if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    	    typeof console.error === 'function') {
    	  console.error(
    	    'This browser lacks typed array (Uint8Array) support which is required by ' +
    	    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    	  );
    	}

    	function typedArraySupport () {
    	  // Can typed array instances can be augmented?
    	  try {
    	    const arr = new Uint8Array(1);
    	    const proto = { foo: function () { return 42 } };
    	    Object.setPrototypeOf(proto, Uint8Array.prototype);
    	    Object.setPrototypeOf(arr, proto);
    	    return arr.foo() === 42
    	  } catch (e) {
    	    return false
    	  }
    	}

    	Object.defineProperty(Buffer.prototype, 'parent', {
    	  enumerable: true,
    	  get: function () {
    	    if (!Buffer.isBuffer(this)) return undefined
    	    return this.buffer
    	  }
    	});

    	Object.defineProperty(Buffer.prototype, 'offset', {
    	  enumerable: true,
    	  get: function () {
    	    if (!Buffer.isBuffer(this)) return undefined
    	    return this.byteOffset
    	  }
    	});

    	function createBuffer (length) {
    	  if (length > K_MAX_LENGTH) {
    	    throw new RangeError('The value "' + length + '" is invalid for option "size"')
    	  }
    	  // Return an augmented `Uint8Array` instance
    	  const buf = new Uint8Array(length);
    	  Object.setPrototypeOf(buf, Buffer.prototype);
    	  return buf
    	}

    	/**
    	 * The Buffer constructor returns instances of `Uint8Array` that have their
    	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
    	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
    	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
    	 * returns a single octet.
    	 *
    	 * The `Uint8Array` prototype remains unmodified.
    	 */

    	function Buffer (arg, encodingOrOffset, length) {
    	  // Common case.
    	  if (typeof arg === 'number') {
    	    if (typeof encodingOrOffset === 'string') {
    	      throw new TypeError(
    	        'The "string" argument must be of type string. Received type number'
    	      )
    	    }
    	    return allocUnsafe(arg)
    	  }
    	  return from(arg, encodingOrOffset, length)
    	}

    	Buffer.poolSize = 8192; // not used by this implementation

    	function from (value, encodingOrOffset, length) {
    	  if (typeof value === 'string') {
    	    return fromString(value, encodingOrOffset)
    	  }

    	  if (ArrayBuffer.isView(value)) {
    	    return fromArrayView(value)
    	  }

    	  if (value == null) {
    	    throw new TypeError(
    	      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    	      'or Array-like Object. Received type ' + (typeof value)
    	    )
    	  }

    	  if (isInstance(value, ArrayBuffer) ||
    	      (value && isInstance(value.buffer, ArrayBuffer))) {
    	    return fromArrayBuffer(value, encodingOrOffset, length)
    	  }

    	  if (typeof SharedArrayBuffer !== 'undefined' &&
    	      (isInstance(value, SharedArrayBuffer) ||
    	      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    	    return fromArrayBuffer(value, encodingOrOffset, length)
    	  }

    	  if (typeof value === 'number') {
    	    throw new TypeError(
    	      'The "value" argument must not be of type number. Received type number'
    	    )
    	  }

    	  const valueOf = value.valueOf && value.valueOf();
    	  if (valueOf != null && valueOf !== value) {
    	    return Buffer.from(valueOf, encodingOrOffset, length)
    	  }

    	  const b = fromObject(value);
    	  if (b) return b

    	  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
    	      typeof value[Symbol.toPrimitive] === 'function') {
    	    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
    	  }

    	  throw new TypeError(
    	    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    	    'or Array-like Object. Received type ' + (typeof value)
    	  )
    	}

    	/**
    	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
    	 * if value is a number.
    	 * Buffer.from(str[, encoding])
    	 * Buffer.from(array)
    	 * Buffer.from(buffer)
    	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
    	 **/
    	Buffer.from = function (value, encodingOrOffset, length) {
    	  return from(value, encodingOrOffset, length)
    	};

    	// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    	// https://github.com/feross/buffer/pull/148
    	Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    	Object.setPrototypeOf(Buffer, Uint8Array);

    	function assertSize (size) {
    	  if (typeof size !== 'number') {
    	    throw new TypeError('"size" argument must be of type number')
    	  } else if (size < 0) {
    	    throw new RangeError('The value "' + size + '" is invalid for option "size"')
    	  }
    	}

    	function alloc (size, fill, encoding) {
    	  assertSize(size);
    	  if (size <= 0) {
    	    return createBuffer(size)
    	  }
    	  if (fill !== undefined) {
    	    // Only pay attention to encoding if it's a string. This
    	    // prevents accidentally sending in a number that would
    	    // be interpreted as a start offset.
    	    return typeof encoding === 'string'
    	      ? createBuffer(size).fill(fill, encoding)
    	      : createBuffer(size).fill(fill)
    	  }
    	  return createBuffer(size)
    	}

    	/**
    	 * Creates a new filled Buffer instance.
    	 * alloc(size[, fill[, encoding]])
    	 **/
    	Buffer.alloc = function (size, fill, encoding) {
    	  return alloc(size, fill, encoding)
    	};

    	function allocUnsafe (size) {
    	  assertSize(size);
    	  return createBuffer(size < 0 ? 0 : checked(size) | 0)
    	}

    	/**
    	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
    	 * */
    	Buffer.allocUnsafe = function (size) {
    	  return allocUnsafe(size)
    	};
    	/**
    	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
    	 */
    	Buffer.allocUnsafeSlow = function (size) {
    	  return allocUnsafe(size)
    	};

    	function fromString (string, encoding) {
    	  if (typeof encoding !== 'string' || encoding === '') {
    	    encoding = 'utf8';
    	  }

    	  if (!Buffer.isEncoding(encoding)) {
    	    throw new TypeError('Unknown encoding: ' + encoding)
    	  }

    	  const length = byteLength(string, encoding) | 0;
    	  let buf = createBuffer(length);

    	  const actual = buf.write(string, encoding);

    	  if (actual !== length) {
    	    // Writing a hex string, for example, that contains invalid characters will
    	    // cause everything after the first invalid character to be ignored. (e.g.
    	    // 'abxxcd' will be treated as 'ab')
    	    buf = buf.slice(0, actual);
    	  }

    	  return buf
    	}

    	function fromArrayLike (array) {
    	  const length = array.length < 0 ? 0 : checked(array.length) | 0;
    	  const buf = createBuffer(length);
    	  for (let i = 0; i < length; i += 1) {
    	    buf[i] = array[i] & 255;
    	  }
    	  return buf
    	}

    	function fromArrayView (arrayView) {
    	  if (isInstance(arrayView, Uint8Array)) {
    	    const copy = new Uint8Array(arrayView);
    	    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
    	  }
    	  return fromArrayLike(arrayView)
    	}

    	function fromArrayBuffer (array, byteOffset, length) {
    	  if (byteOffset < 0 || array.byteLength < byteOffset) {
    	    throw new RangeError('"offset" is outside of buffer bounds')
    	  }

    	  if (array.byteLength < byteOffset + (length || 0)) {
    	    throw new RangeError('"length" is outside of buffer bounds')
    	  }

    	  let buf;
    	  if (byteOffset === undefined && length === undefined) {
    	    buf = new Uint8Array(array);
    	  } else if (length === undefined) {
    	    buf = new Uint8Array(array, byteOffset);
    	  } else {
    	    buf = new Uint8Array(array, byteOffset, length);
    	  }

    	  // Return an augmented `Uint8Array` instance
    	  Object.setPrototypeOf(buf, Buffer.prototype);

    	  return buf
    	}

    	function fromObject (obj) {
    	  if (Buffer.isBuffer(obj)) {
    	    const len = checked(obj.length) | 0;
    	    const buf = createBuffer(len);

    	    if (buf.length === 0) {
    	      return buf
    	    }

    	    obj.copy(buf, 0, 0, len);
    	    return buf
    	  }

    	  if (obj.length !== undefined) {
    	    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
    	      return createBuffer(0)
    	    }
    	    return fromArrayLike(obj)
    	  }

    	  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    	    return fromArrayLike(obj.data)
    	  }
    	}

    	function checked (length) {
    	  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    	  // length is NaN (which is otherwise coerced to zero.)
    	  if (length >= K_MAX_LENGTH) {
    	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
    	                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    	  }
    	  return length | 0
    	}

    	function SlowBuffer (length) {
    	  if (+length != length) { // eslint-disable-line eqeqeq
    	    length = 0;
    	  }
    	  return Buffer.alloc(+length)
    	}

    	Buffer.isBuffer = function isBuffer (b) {
    	  return b != null && b._isBuffer === true &&
    	    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    	};

    	Buffer.compare = function compare (a, b) {
    	  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    	  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    	    throw new TypeError(
    	      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    	    )
    	  }

    	  if (a === b) return 0

    	  let x = a.length;
    	  let y = b.length;

    	  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    	    if (a[i] !== b[i]) {
    	      x = a[i];
    	      y = b[i];
    	      break
    	    }
    	  }

    	  if (x < y) return -1
    	  if (y < x) return 1
    	  return 0
    	};

    	Buffer.isEncoding = function isEncoding (encoding) {
    	  switch (String(encoding).toLowerCase()) {
    	    case 'hex':
    	    case 'utf8':
    	    case 'utf-8':
    	    case 'ascii':
    	    case 'latin1':
    	    case 'binary':
    	    case 'base64':
    	    case 'ucs2':
    	    case 'ucs-2':
    	    case 'utf16le':
    	    case 'utf-16le':
    	      return true
    	    default:
    	      return false
    	  }
    	};

    	Buffer.concat = function concat (list, length) {
    	  if (!Array.isArray(list)) {
    	    throw new TypeError('"list" argument must be an Array of Buffers')
    	  }

    	  if (list.length === 0) {
    	    return Buffer.alloc(0)
    	  }

    	  let i;
    	  if (length === undefined) {
    	    length = 0;
    	    for (i = 0; i < list.length; ++i) {
    	      length += list[i].length;
    	    }
    	  }

    	  const buffer = Buffer.allocUnsafe(length);
    	  let pos = 0;
    	  for (i = 0; i < list.length; ++i) {
    	    let buf = list[i];
    	    if (isInstance(buf, Uint8Array)) {
    	      if (pos + buf.length > buffer.length) {
    	        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    	        buf.copy(buffer, pos);
    	      } else {
    	        Uint8Array.prototype.set.call(
    	          buffer,
    	          buf,
    	          pos
    	        );
    	      }
    	    } else if (!Buffer.isBuffer(buf)) {
    	      throw new TypeError('"list" argument must be an Array of Buffers')
    	    } else {
    	      buf.copy(buffer, pos);
    	    }
    	    pos += buf.length;
    	  }
    	  return buffer
    	};

    	function byteLength (string, encoding) {
    	  if (Buffer.isBuffer(string)) {
    	    return string.length
    	  }
    	  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    	    return string.byteLength
    	  }
    	  if (typeof string !== 'string') {
    	    throw new TypeError(
    	      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
    	      'Received type ' + typeof string
    	    )
    	  }

    	  const len = string.length;
    	  const mustMatch = (arguments.length > 2 && arguments[2] === true);
    	  if (!mustMatch && len === 0) return 0

    	  // Use a for loop to avoid recursion
    	  let loweredCase = false;
    	  for (;;) {
    	    switch (encoding) {
    	      case 'ascii':
    	      case 'latin1':
    	      case 'binary':
    	        return len
    	      case 'utf8':
    	      case 'utf-8':
    	        return utf8ToBytes(string).length
    	      case 'ucs2':
    	      case 'ucs-2':
    	      case 'utf16le':
    	      case 'utf-16le':
    	        return len * 2
    	      case 'hex':
    	        return len >>> 1
    	      case 'base64':
    	        return base64ToBytes(string).length
    	      default:
    	        if (loweredCase) {
    	          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
    	        }
    	        encoding = ('' + encoding).toLowerCase();
    	        loweredCase = true;
    	    }
    	  }
    	}
    	Buffer.byteLength = byteLength;

    	function slowToString (encoding, start, end) {
    	  let loweredCase = false;

    	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    	  // property of a typed array.

    	  // This behaves neither like String nor Uint8Array in that we set start/end
    	  // to their upper/lower bounds if the value passed is out of range.
    	  // undefined is handled specially as per ECMA-262 6th Edition,
    	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    	  if (start === undefined || start < 0) {
    	    start = 0;
    	  }
    	  // Return early if start > this.length. Done here to prevent potential uint32
    	  // coercion fail below.
    	  if (start > this.length) {
    	    return ''
    	  }

    	  if (end === undefined || end > this.length) {
    	    end = this.length;
    	  }

    	  if (end <= 0) {
    	    return ''
    	  }

    	  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    	  end >>>= 0;
    	  start >>>= 0;

    	  if (end <= start) {
    	    return ''
    	  }

    	  if (!encoding) encoding = 'utf8';

    	  while (true) {
    	    switch (encoding) {
    	      case 'hex':
    	        return hexSlice(this, start, end)

    	      case 'utf8':
    	      case 'utf-8':
    	        return utf8Slice(this, start, end)

    	      case 'ascii':
    	        return asciiSlice(this, start, end)

    	      case 'latin1':
    	      case 'binary':
    	        return latin1Slice(this, start, end)

    	      case 'base64':
    	        return base64Slice(this, start, end)

    	      case 'ucs2':
    	      case 'ucs-2':
    	      case 'utf16le':
    	      case 'utf-16le':
    	        return utf16leSlice(this, start, end)

    	      default:
    	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
    	        encoding = (encoding + '').toLowerCase();
    	        loweredCase = true;
    	    }
    	  }
    	}

    	// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    	// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    	// reliably in a browserify context because there could be multiple different
    	// copies of the 'buffer' package in use. This method works even for Buffer
    	// instances that were created from another copy of the `buffer` package.
    	// See: https://github.com/feross/buffer/issues/154
    	Buffer.prototype._isBuffer = true;

    	function swap (b, n, m) {
    	  const i = b[n];
    	  b[n] = b[m];
    	  b[m] = i;
    	}

    	Buffer.prototype.swap16 = function swap16 () {
    	  const len = this.length;
    	  if (len % 2 !== 0) {
    	    throw new RangeError('Buffer size must be a multiple of 16-bits')
    	  }
    	  for (let i = 0; i < len; i += 2) {
    	    swap(this, i, i + 1);
    	  }
    	  return this
    	};

    	Buffer.prototype.swap32 = function swap32 () {
    	  const len = this.length;
    	  if (len % 4 !== 0) {
    	    throw new RangeError('Buffer size must be a multiple of 32-bits')
    	  }
    	  for (let i = 0; i < len; i += 4) {
    	    swap(this, i, i + 3);
    	    swap(this, i + 1, i + 2);
    	  }
    	  return this
    	};

    	Buffer.prototype.swap64 = function swap64 () {
    	  const len = this.length;
    	  if (len % 8 !== 0) {
    	    throw new RangeError('Buffer size must be a multiple of 64-bits')
    	  }
    	  for (let i = 0; i < len; i += 8) {
    	    swap(this, i, i + 7);
    	    swap(this, i + 1, i + 6);
    	    swap(this, i + 2, i + 5);
    	    swap(this, i + 3, i + 4);
    	  }
    	  return this
    	};

    	Buffer.prototype.toString = function toString () {
    	  const length = this.length;
    	  if (length === 0) return ''
    	  if (arguments.length === 0) return utf8Slice(this, 0, length)
    	  return slowToString.apply(this, arguments)
    	};

    	Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    	Buffer.prototype.equals = function equals (b) {
    	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    	  if (this === b) return true
    	  return Buffer.compare(this, b) === 0
    	};

    	Buffer.prototype.inspect = function inspect () {
    	  let str = '';
    	  const max = exports.INSPECT_MAX_BYTES;
    	  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    	  if (this.length > max) str += ' ... ';
    	  return '<Buffer ' + str + '>'
    	};
    	if (customInspectSymbol) {
    	  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    	}

    	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    	  if (isInstance(target, Uint8Array)) {
    	    target = Buffer.from(target, target.offset, target.byteLength);
    	  }
    	  if (!Buffer.isBuffer(target)) {
    	    throw new TypeError(
    	      'The "target" argument must be one of type Buffer or Uint8Array. ' +
    	      'Received type ' + (typeof target)
    	    )
    	  }

    	  if (start === undefined) {
    	    start = 0;
    	  }
    	  if (end === undefined) {
    	    end = target ? target.length : 0;
    	  }
    	  if (thisStart === undefined) {
    	    thisStart = 0;
    	  }
    	  if (thisEnd === undefined) {
    	    thisEnd = this.length;
    	  }

    	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    	    throw new RangeError('out of range index')
    	  }

    	  if (thisStart >= thisEnd && start >= end) {
    	    return 0
    	  }
    	  if (thisStart >= thisEnd) {
    	    return -1
    	  }
    	  if (start >= end) {
    	    return 1
    	  }

    	  start >>>= 0;
    	  end >>>= 0;
    	  thisStart >>>= 0;
    	  thisEnd >>>= 0;

    	  if (this === target) return 0

    	  let x = thisEnd - thisStart;
    	  let y = end - start;
    	  const len = Math.min(x, y);

    	  const thisCopy = this.slice(thisStart, thisEnd);
    	  const targetCopy = target.slice(start, end);

    	  for (let i = 0; i < len; ++i) {
    	    if (thisCopy[i] !== targetCopy[i]) {
    	      x = thisCopy[i];
    	      y = targetCopy[i];
    	      break
    	    }
    	  }

    	  if (x < y) return -1
    	  if (y < x) return 1
    	  return 0
    	};

    	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    	//
    	// Arguments:
    	// - buffer - a Buffer to search
    	// - val - a string, Buffer, or number
    	// - byteOffset - an index into `buffer`; will be clamped to an int32
    	// - encoding - an optional encoding, relevant is val is a string
    	// - dir - true for indexOf, false for lastIndexOf
    	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    	  // Empty buffer means no match
    	  if (buffer.length === 0) return -1

    	  // Normalize byteOffset
    	  if (typeof byteOffset === 'string') {
    	    encoding = byteOffset;
    	    byteOffset = 0;
    	  } else if (byteOffset > 0x7fffffff) {
    	    byteOffset = 0x7fffffff;
    	  } else if (byteOffset < -2147483648) {
    	    byteOffset = -2147483648;
    	  }
    	  byteOffset = +byteOffset; // Coerce to Number.
    	  if (numberIsNaN(byteOffset)) {
    	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    	    byteOffset = dir ? 0 : (buffer.length - 1);
    	  }

    	  // Normalize byteOffset: negative offsets start from the end of the buffer
    	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    	  if (byteOffset >= buffer.length) {
    	    if (dir) return -1
    	    else byteOffset = buffer.length - 1;
    	  } else if (byteOffset < 0) {
    	    if (dir) byteOffset = 0;
    	    else return -1
    	  }

    	  // Normalize val
    	  if (typeof val === 'string') {
    	    val = Buffer.from(val, encoding);
    	  }

    	  // Finally, search either indexOf (if dir is true) or lastIndexOf
    	  if (Buffer.isBuffer(val)) {
    	    // Special case: looking for empty string/buffer always fails
    	    if (val.length === 0) {
    	      return -1
    	    }
    	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    	  } else if (typeof val === 'number') {
    	    val = val & 0xFF; // Search for a byte value [0-255]
    	    if (typeof Uint8Array.prototype.indexOf === 'function') {
    	      if (dir) {
    	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
    	      } else {
    	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
    	      }
    	    }
    	    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
    	  }

    	  throw new TypeError('val must be string, number or Buffer')
    	}

    	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    	  let indexSize = 1;
    	  let arrLength = arr.length;
    	  let valLength = val.length;

    	  if (encoding !== undefined) {
    	    encoding = String(encoding).toLowerCase();
    	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
    	        encoding === 'utf16le' || encoding === 'utf-16le') {
    	      if (arr.length < 2 || val.length < 2) {
    	        return -1
    	      }
    	      indexSize = 2;
    	      arrLength /= 2;
    	      valLength /= 2;
    	      byteOffset /= 2;
    	    }
    	  }

    	  function read (buf, i) {
    	    if (indexSize === 1) {
    	      return buf[i]
    	    } else {
    	      return buf.readUInt16BE(i * indexSize)
    	    }
    	  }

    	  let i;
    	  if (dir) {
    	    let foundIndex = -1;
    	    for (i = byteOffset; i < arrLength; i++) {
    	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
    	        if (foundIndex === -1) foundIndex = i;
    	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
    	      } else {
    	        if (foundIndex !== -1) i -= i - foundIndex;
    	        foundIndex = -1;
    	      }
    	    }
    	  } else {
    	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    	    for (i = byteOffset; i >= 0; i--) {
    	      let found = true;
    	      for (let j = 0; j < valLength; j++) {
    	        if (read(arr, i + j) !== read(val, j)) {
    	          found = false;
    	          break
    	        }
    	      }
    	      if (found) return i
    	    }
    	  }

    	  return -1
    	}

    	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    	  return this.indexOf(val, byteOffset, encoding) !== -1
    	};

    	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    	};

    	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    	};

    	function hexWrite (buf, string, offset, length) {
    	  offset = Number(offset) || 0;
    	  const remaining = buf.length - offset;
    	  if (!length) {
    	    length = remaining;
    	  } else {
    	    length = Number(length);
    	    if (length > remaining) {
    	      length = remaining;
    	    }
    	  }

    	  const strLen = string.length;

    	  if (length > strLen / 2) {
    	    length = strLen / 2;
    	  }
    	  let i;
    	  for (i = 0; i < length; ++i) {
    	    const parsed = parseInt(string.substr(i * 2, 2), 16);
    	    if (numberIsNaN(parsed)) return i
    	    buf[offset + i] = parsed;
    	  }
    	  return i
    	}

    	function utf8Write (buf, string, offset, length) {
    	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    	}

    	function asciiWrite (buf, string, offset, length) {
    	  return blitBuffer(asciiToBytes(string), buf, offset, length)
    	}

    	function base64Write (buf, string, offset, length) {
    	  return blitBuffer(base64ToBytes(string), buf, offset, length)
    	}

    	function ucs2Write (buf, string, offset, length) {
    	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    	}

    	Buffer.prototype.write = function write (string, offset, length, encoding) {
    	  // Buffer#write(string)
    	  if (offset === undefined) {
    	    encoding = 'utf8';
    	    length = this.length;
    	    offset = 0;
    	  // Buffer#write(string, encoding)
    	  } else if (length === undefined && typeof offset === 'string') {
    	    encoding = offset;
    	    length = this.length;
    	    offset = 0;
    	  // Buffer#write(string, offset[, length][, encoding])
    	  } else if (isFinite(offset)) {
    	    offset = offset >>> 0;
    	    if (isFinite(length)) {
    	      length = length >>> 0;
    	      if (encoding === undefined) encoding = 'utf8';
    	    } else {
    	      encoding = length;
    	      length = undefined;
    	    }
    	  } else {
    	    throw new Error(
    	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    	    )
    	  }

    	  const remaining = this.length - offset;
    	  if (length === undefined || length > remaining) length = remaining;

    	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    	    throw new RangeError('Attempt to write outside buffer bounds')
    	  }

    	  if (!encoding) encoding = 'utf8';

    	  let loweredCase = false;
    	  for (;;) {
    	    switch (encoding) {
    	      case 'hex':
    	        return hexWrite(this, string, offset, length)

    	      case 'utf8':
    	      case 'utf-8':
    	        return utf8Write(this, string, offset, length)

    	      case 'ascii':
    	      case 'latin1':
    	      case 'binary':
    	        return asciiWrite(this, string, offset, length)

    	      case 'base64':
    	        // Warning: maxLength not taken into account in base64Write
    	        return base64Write(this, string, offset, length)

    	      case 'ucs2':
    	      case 'ucs-2':
    	      case 'utf16le':
    	      case 'utf-16le':
    	        return ucs2Write(this, string, offset, length)

    	      default:
    	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
    	        encoding = ('' + encoding).toLowerCase();
    	        loweredCase = true;
    	    }
    	  }
    	};

    	Buffer.prototype.toJSON = function toJSON () {
    	  return {
    	    type: 'Buffer',
    	    data: Array.prototype.slice.call(this._arr || this, 0)
    	  }
    	};

    	function base64Slice (buf, start, end) {
    	  if (start === 0 && end === buf.length) {
    	    return base64.fromByteArray(buf)
    	  } else {
    	    return base64.fromByteArray(buf.slice(start, end))
    	  }
    	}

    	function utf8Slice (buf, start, end) {
    	  end = Math.min(buf.length, end);
    	  const res = [];

    	  let i = start;
    	  while (i < end) {
    	    const firstByte = buf[i];
    	    let codePoint = null;
    	    let bytesPerSequence = (firstByte > 0xEF)
    	      ? 4
    	      : (firstByte > 0xDF)
    	          ? 3
    	          : (firstByte > 0xBF)
    	              ? 2
    	              : 1;

    	    if (i + bytesPerSequence <= end) {
    	      let secondByte, thirdByte, fourthByte, tempCodePoint;

    	      switch (bytesPerSequence) {
    	        case 1:
    	          if (firstByte < 0x80) {
    	            codePoint = firstByte;
    	          }
    	          break
    	        case 2:
    	          secondByte = buf[i + 1];
    	          if ((secondByte & 0xC0) === 0x80) {
    	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
    	            if (tempCodePoint > 0x7F) {
    	              codePoint = tempCodePoint;
    	            }
    	          }
    	          break
    	        case 3:
    	          secondByte = buf[i + 1];
    	          thirdByte = buf[i + 2];
    	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
    	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
    	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
    	              codePoint = tempCodePoint;
    	            }
    	          }
    	          break
    	        case 4:
    	          secondByte = buf[i + 1];
    	          thirdByte = buf[i + 2];
    	          fourthByte = buf[i + 3];
    	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
    	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
    	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
    	              codePoint = tempCodePoint;
    	            }
    	          }
    	      }
    	    }

    	    if (codePoint === null) {
    	      // we did not generate a valid codePoint so insert a
    	      // replacement char (U+FFFD) and advance only 1 byte
    	      codePoint = 0xFFFD;
    	      bytesPerSequence = 1;
    	    } else if (codePoint > 0xFFFF) {
    	      // encode to utf16 (surrogate pair dance)
    	      codePoint -= 0x10000;
    	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
    	      codePoint = 0xDC00 | codePoint & 0x3FF;
    	    }

    	    res.push(codePoint);
    	    i += bytesPerSequence;
    	  }

    	  return decodeCodePointsArray(res)
    	}

    	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
    	// the lowest limit is Chrome, with 0x10000 args.
    	// We go 1 magnitude less, for safety
    	const MAX_ARGUMENTS_LENGTH = 0x1000;

    	function decodeCodePointsArray (codePoints) {
    	  const len = codePoints.length;
    	  if (len <= MAX_ARGUMENTS_LENGTH) {
    	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    	  }

    	  // Decode in chunks to avoid "call stack size exceeded".
    	  let res = '';
    	  let i = 0;
    	  while (i < len) {
    	    res += String.fromCharCode.apply(
    	      String,
    	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    	    );
    	  }
    	  return res
    	}

    	function asciiSlice (buf, start, end) {
    	  let ret = '';
    	  end = Math.min(buf.length, end);

    	  for (let i = start; i < end; ++i) {
    	    ret += String.fromCharCode(buf[i] & 0x7F);
    	  }
    	  return ret
    	}

    	function latin1Slice (buf, start, end) {
    	  let ret = '';
    	  end = Math.min(buf.length, end);

    	  for (let i = start; i < end; ++i) {
    	    ret += String.fromCharCode(buf[i]);
    	  }
    	  return ret
    	}

    	function hexSlice (buf, start, end) {
    	  const len = buf.length;

    	  if (!start || start < 0) start = 0;
    	  if (!end || end < 0 || end > len) end = len;

    	  let out = '';
    	  for (let i = start; i < end; ++i) {
    	    out += hexSliceLookupTable[buf[i]];
    	  }
    	  return out
    	}

    	function utf16leSlice (buf, start, end) {
    	  const bytes = buf.slice(start, end);
    	  let res = '';
    	  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    	  for (let i = 0; i < bytes.length - 1; i += 2) {
    	    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
    	  }
    	  return res
    	}

    	Buffer.prototype.slice = function slice (start, end) {
    	  const len = this.length;
    	  start = ~~start;
    	  end = end === undefined ? len : ~~end;

    	  if (start < 0) {
    	    start += len;
    	    if (start < 0) start = 0;
    	  } else if (start > len) {
    	    start = len;
    	  }

    	  if (end < 0) {
    	    end += len;
    	    if (end < 0) end = 0;
    	  } else if (end > len) {
    	    end = len;
    	  }

    	  if (end < start) end = start;

    	  const newBuf = this.subarray(start, end);
    	  // Return an augmented `Uint8Array` instance
    	  Object.setPrototypeOf(newBuf, Buffer.prototype);

    	  return newBuf
    	};

    	/*
    	 * Need to make sure that buffer isn't trying to write out of bounds.
    	 */
    	function checkOffset (offset, ext, length) {
    	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    	}

    	Buffer.prototype.readUintLE =
    	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) checkOffset(offset, byteLength, this.length);

    	  let val = this[offset];
    	  let mul = 1;
    	  let i = 0;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    val += this[offset + i] * mul;
    	  }

    	  return val
    	};

    	Buffer.prototype.readUintBE =
    	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) {
    	    checkOffset(offset, byteLength, this.length);
    	  }

    	  let val = this[offset + --byteLength];
    	  let mul = 1;
    	  while (byteLength > 0 && (mul *= 0x100)) {
    	    val += this[offset + --byteLength] * mul;
    	  }

    	  return val
    	};

    	Buffer.prototype.readUint8 =
    	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 1, this.length);
    	  return this[offset]
    	};

    	Buffer.prototype.readUint16LE =
    	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  return this[offset] | (this[offset + 1] << 8)
    	};

    	Buffer.prototype.readUint16BE =
    	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  return (this[offset] << 8) | this[offset + 1]
    	};

    	Buffer.prototype.readUint32LE =
    	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return ((this[offset]) |
    	      (this[offset + 1] << 8) |
    	      (this[offset + 2] << 16)) +
    	      (this[offset + 3] * 0x1000000)
    	};

    	Buffer.prototype.readUint32BE =
    	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return (this[offset] * 0x1000000) +
    	    ((this[offset + 1] << 16) |
    	    (this[offset + 2] << 8) |
    	    this[offset + 3])
    	};

    	Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const lo = first +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 24;

    	  const hi = this[++offset] +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset] * 2 ** 16 +
    	    last * 2 ** 24;

    	  return BigInt(lo) + (BigInt(hi) << BigInt(32))
    	});

    	Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const hi = first * 2 ** 24 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset];

    	  const lo = this[++offset] * 2 ** 24 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    last;

    	  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
    	});

    	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) checkOffset(offset, byteLength, this.length);

    	  let val = this[offset];
    	  let mul = 1;
    	  let i = 0;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    val += this[offset + i] * mul;
    	  }
    	  mul *= 0x80;

    	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    	  return val
    	};

    	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) checkOffset(offset, byteLength, this.length);

    	  let i = byteLength;
    	  let mul = 1;
    	  let val = this[offset + --i];
    	  while (i > 0 && (mul *= 0x100)) {
    	    val += this[offset + --i] * mul;
    	  }
    	  mul *= 0x80;

    	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    	  return val
    	};

    	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 1, this.length);
    	  if (!(this[offset] & 0x80)) return (this[offset])
    	  return ((0xff - this[offset] + 1) * -1)
    	};

    	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  const val = this[offset] | (this[offset + 1] << 8);
    	  return (val & 0x8000) ? val | 0xFFFF0000 : val
    	};

    	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 2, this.length);
    	  const val = this[offset + 1] | (this[offset] << 8);
    	  return (val & 0x8000) ? val | 0xFFFF0000 : val
    	};

    	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return (this[offset]) |
    	    (this[offset + 1] << 8) |
    	    (this[offset + 2] << 16) |
    	    (this[offset + 3] << 24)
    	};

    	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);

    	  return (this[offset] << 24) |
    	    (this[offset + 1] << 16) |
    	    (this[offset + 2] << 8) |
    	    (this[offset + 3])
    	};

    	Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const val = this[offset + 4] +
    	    this[offset + 5] * 2 ** 8 +
    	    this[offset + 6] * 2 ** 16 +
    	    (last << 24); // Overflow

    	  return (BigInt(val) << BigInt(32)) +
    	    BigInt(first +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 24)
    	});

    	Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
    	  offset = offset >>> 0;
    	  validateNumber(offset, 'offset');
    	  const first = this[offset];
    	  const last = this[offset + 7];
    	  if (first === undefined || last === undefined) {
    	    boundsError(offset, this.length - 8);
    	  }

    	  const val = (first << 24) + // Overflow
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    this[++offset];

    	  return (BigInt(val) << BigInt(32)) +
    	    BigInt(this[++offset] * 2 ** 24 +
    	    this[++offset] * 2 ** 16 +
    	    this[++offset] * 2 ** 8 +
    	    last)
    	});

    	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);
    	  return ieee754$1.read(this, offset, true, 23, 4)
    	};

    	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 4, this.length);
    	  return ieee754$1.read(this, offset, false, 23, 4)
    	};

    	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 8, this.length);
    	  return ieee754$1.read(this, offset, true, 52, 8)
    	};

    	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    	  offset = offset >>> 0;
    	  if (!noAssert) checkOffset(offset, 8, this.length);
    	  return ieee754$1.read(this, offset, false, 52, 8)
    	};

    	function checkInt (buf, value, offset, ext, max, min) {
    	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
    	}

    	Buffer.prototype.writeUintLE =
    	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) {
    	    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    	    checkInt(this, value, offset, byteLength, maxBytes, 0);
    	  }

    	  let mul = 1;
    	  let i = 0;
    	  this[offset] = value & 0xFF;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    this[offset + i] = (value / mul) & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeUintBE =
    	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  byteLength = byteLength >>> 0;
    	  if (!noAssert) {
    	    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    	    checkInt(this, value, offset, byteLength, maxBytes, 0);
    	  }

    	  let i = byteLength - 1;
    	  let mul = 1;
    	  this[offset + i] = value & 0xFF;
    	  while (--i >= 0 && (mul *= 0x100)) {
    	    this[offset + i] = (value / mul) & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeUint8 =
    	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    	  this[offset] = (value & 0xff);
    	  return offset + 1
    	};

    	Buffer.prototype.writeUint16LE =
    	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    	  this[offset] = (value & 0xff);
    	  this[offset + 1] = (value >>> 8);
    	  return offset + 2
    	};

    	Buffer.prototype.writeUint16BE =
    	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    	  this[offset] = (value >>> 8);
    	  this[offset + 1] = (value & 0xff);
    	  return offset + 2
    	};

    	Buffer.prototype.writeUint32LE =
    	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    	  this[offset + 3] = (value >>> 24);
    	  this[offset + 2] = (value >>> 16);
    	  this[offset + 1] = (value >>> 8);
    	  this[offset] = (value & 0xff);
    	  return offset + 4
    	};

    	Buffer.prototype.writeUint32BE =
    	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    	  this[offset] = (value >>> 24);
    	  this[offset + 1] = (value >>> 16);
    	  this[offset + 2] = (value >>> 8);
    	  this[offset + 3] = (value & 0xff);
    	  return offset + 4
    	};

    	function wrtBigUInt64LE (buf, value, offset, min, max) {
    	  checkIntBI(value, min, max, buf, offset, 7);

    	  let lo = Number(value & BigInt(0xffffffff));
    	  buf[offset++] = lo;
    	  lo = lo >> 8;
    	  buf[offset++] = lo;
    	  lo = lo >> 8;
    	  buf[offset++] = lo;
    	  lo = lo >> 8;
    	  buf[offset++] = lo;
    	  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    	  buf[offset++] = hi;
    	  hi = hi >> 8;
    	  buf[offset++] = hi;
    	  hi = hi >> 8;
    	  buf[offset++] = hi;
    	  hi = hi >> 8;
    	  buf[offset++] = hi;
    	  return offset
    	}

    	function wrtBigUInt64BE (buf, value, offset, min, max) {
    	  checkIntBI(value, min, max, buf, offset, 7);

    	  let lo = Number(value & BigInt(0xffffffff));
    	  buf[offset + 7] = lo;
    	  lo = lo >> 8;
    	  buf[offset + 6] = lo;
    	  lo = lo >> 8;
    	  buf[offset + 5] = lo;
    	  lo = lo >> 8;
    	  buf[offset + 4] = lo;
    	  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    	  buf[offset + 3] = hi;
    	  hi = hi >> 8;
    	  buf[offset + 2] = hi;
    	  hi = hi >> 8;
    	  buf[offset + 1] = hi;
    	  hi = hi >> 8;
    	  buf[offset] = hi;
    	  return offset + 8
    	}

    	Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
    	  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    	});

    	Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
    	  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    	});

    	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    const limit = Math.pow(2, (8 * byteLength) - 1);

    	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
    	  }

    	  let i = 0;
    	  let mul = 1;
    	  let sub = 0;
    	  this[offset] = value & 0xFF;
    	  while (++i < byteLength && (mul *= 0x100)) {
    	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
    	      sub = 1;
    	    }
    	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    const limit = Math.pow(2, (8 * byteLength) - 1);

    	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
    	  }

    	  let i = byteLength - 1;
    	  let mul = 1;
    	  let sub = 0;
    	  this[offset + i] = value & 0xFF;
    	  while (--i >= 0 && (mul *= 0x100)) {
    	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
    	      sub = 1;
    	    }
    	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    	  }

    	  return offset + byteLength
    	};

    	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    	  if (value < 0) value = 0xff + value + 1;
    	  this[offset] = (value & 0xff);
    	  return offset + 1
    	};

    	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    	  this[offset] = (value & 0xff);
    	  this[offset + 1] = (value >>> 8);
    	  return offset + 2
    	};

    	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    	  this[offset] = (value >>> 8);
    	  this[offset + 1] = (value & 0xff);
    	  return offset + 2
    	};

    	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    	  this[offset] = (value & 0xff);
    	  this[offset + 1] = (value >>> 8);
    	  this[offset + 2] = (value >>> 16);
    	  this[offset + 3] = (value >>> 24);
    	  return offset + 4
    	};

    	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    	  if (value < 0) value = 0xffffffff + value + 1;
    	  this[offset] = (value >>> 24);
    	  this[offset + 1] = (value >>> 16);
    	  this[offset + 2] = (value >>> 8);
    	  this[offset + 3] = (value & 0xff);
    	  return offset + 4
    	};

    	Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
    	  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    	});

    	Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
    	  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    	});

    	function checkIEEE754 (buf, value, offset, ext, max, min) {
    	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
    	  if (offset < 0) throw new RangeError('Index out of range')
    	}

    	function writeFloat (buf, value, offset, littleEndian, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    checkIEEE754(buf, value, offset, 4);
    	  }
    	  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    	  return offset + 4
    	}

    	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    	  return writeFloat(this, value, offset, true, noAssert)
    	};

    	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    	  return writeFloat(this, value, offset, false, noAssert)
    	};

    	function writeDouble (buf, value, offset, littleEndian, noAssert) {
    	  value = +value;
    	  offset = offset >>> 0;
    	  if (!noAssert) {
    	    checkIEEE754(buf, value, offset, 8);
    	  }
    	  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    	  return offset + 8
    	}

    	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    	  return writeDouble(this, value, offset, true, noAssert)
    	};

    	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    	  return writeDouble(this, value, offset, false, noAssert)
    	};

    	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    	  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    	  if (!start) start = 0;
    	  if (!end && end !== 0) end = this.length;
    	  if (targetStart >= target.length) targetStart = target.length;
    	  if (!targetStart) targetStart = 0;
    	  if (end > 0 && end < start) end = start;

    	  // Copy 0 bytes; we're done
    	  if (end === start) return 0
    	  if (target.length === 0 || this.length === 0) return 0

    	  // Fatal error conditions
    	  if (targetStart < 0) {
    	    throw new RangeError('targetStart out of bounds')
    	  }
    	  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

    	  // Are we oob?
    	  if (end > this.length) end = this.length;
    	  if (target.length - targetStart < end - start) {
    	    end = target.length - targetStart + start;
    	  }

    	  const len = end - start;

    	  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    	    // Use built-in when available, missing from IE11
    	    this.copyWithin(targetStart, start, end);
    	  } else {
    	    Uint8Array.prototype.set.call(
    	      target,
    	      this.subarray(start, end),
    	      targetStart
    	    );
    	  }

    	  return len
    	};

    	// Usage:
    	//    buffer.fill(number[, offset[, end]])
    	//    buffer.fill(buffer[, offset[, end]])
    	//    buffer.fill(string[, offset[, end]][, encoding])
    	Buffer.prototype.fill = function fill (val, start, end, encoding) {
    	  // Handle string cases:
    	  if (typeof val === 'string') {
    	    if (typeof start === 'string') {
    	      encoding = start;
    	      start = 0;
    	      end = this.length;
    	    } else if (typeof end === 'string') {
    	      encoding = end;
    	      end = this.length;
    	    }
    	    if (encoding !== undefined && typeof encoding !== 'string') {
    	      throw new TypeError('encoding must be a string')
    	    }
    	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
    	      throw new TypeError('Unknown encoding: ' + encoding)
    	    }
    	    if (val.length === 1) {
    	      const code = val.charCodeAt(0);
    	      if ((encoding === 'utf8' && code < 128) ||
    	          encoding === 'latin1') {
    	        // Fast path: If `val` fits into a single byte, use that numeric value.
    	        val = code;
    	      }
    	    }
    	  } else if (typeof val === 'number') {
    	    val = val & 255;
    	  } else if (typeof val === 'boolean') {
    	    val = Number(val);
    	  }

    	  // Invalid ranges are not set to a default, so can range check early.
    	  if (start < 0 || this.length < start || this.length < end) {
    	    throw new RangeError('Out of range index')
    	  }

    	  if (end <= start) {
    	    return this
    	  }

    	  start = start >>> 0;
    	  end = end === undefined ? this.length : end >>> 0;

    	  if (!val) val = 0;

    	  let i;
    	  if (typeof val === 'number') {
    	    for (i = start; i < end; ++i) {
    	      this[i] = val;
    	    }
    	  } else {
    	    const bytes = Buffer.isBuffer(val)
    	      ? val
    	      : Buffer.from(val, encoding);
    	    const len = bytes.length;
    	    if (len === 0) {
    	      throw new TypeError('The value "' + val +
    	        '" is invalid for argument "value"')
    	    }
    	    for (i = 0; i < end - start; ++i) {
    	      this[i + start] = bytes[i % len];
    	    }
    	  }

    	  return this
    	};

    	// CUSTOM ERRORS
    	// =============

    	// Simplified versions from Node, changed for Buffer-only usage
    	const errors = {};
    	function E (sym, getMessage, Base) {
    	  errors[sym] = class NodeError extends Base {
    	    constructor () {
    	      super();

    	      Object.defineProperty(this, 'message', {
    	        value: getMessage.apply(this, arguments),
    	        writable: true,
    	        configurable: true
    	      });

    	      // Add the error code to the name to include it in the stack trace.
    	      this.name = `${this.name} [${sym}]`;
    	      // Access the stack to generate the error message including the error code
    	      // from the name.
    	      this.stack; // eslint-disable-line no-unused-expressions
    	      // Reset the name to the actual name.
    	      delete this.name;
    	    }

    	    get code () {
    	      return sym
    	    }

    	    set code (value) {
    	      Object.defineProperty(this, 'code', {
    	        configurable: true,
    	        enumerable: true,
    	        value,
    	        writable: true
    	      });
    	    }

    	    toString () {
    	      return `${this.name} [${sym}]: ${this.message}`
    	    }
    	  };
    	}

    	E('ERR_BUFFER_OUT_OF_BOUNDS',
    	  function (name) {
    	    if (name) {
    	      return `${name} is outside of buffer bounds`
    	    }

    	    return 'Attempt to access memory outside buffer bounds'
    	  }, RangeError);
    	E('ERR_INVALID_ARG_TYPE',
    	  function (name, actual) {
    	    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
    	  }, TypeError);
    	E('ERR_OUT_OF_RANGE',
    	  function (str, range, input) {
    	    let msg = `The value of "${str}" is out of range.`;
    	    let received = input;
    	    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
    	      received = addNumericalSeparator(String(input));
    	    } else if (typeof input === 'bigint') {
    	      received = String(input);
    	      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
    	        received = addNumericalSeparator(received);
    	      }
    	      received += 'n';
    	    }
    	    msg += ` It must be ${range}. Received ${received}`;
    	    return msg
    	  }, RangeError);

    	function addNumericalSeparator (val) {
    	  let res = '';
    	  let i = val.length;
    	  const start = val[0] === '-' ? 1 : 0;
    	  for (; i >= start + 4; i -= 3) {
    	    res = `_${val.slice(i - 3, i)}${res}`;
    	  }
    	  return `${val.slice(0, i)}${res}`
    	}

    	// CHECK FUNCTIONS
    	// ===============

    	function checkBounds (buf, offset, byteLength) {
    	  validateNumber(offset, 'offset');
    	  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    	    boundsError(offset, buf.length - (byteLength + 1));
    	  }
    	}

    	function checkIntBI (value, min, max, buf, offset, byteLength) {
    	  if (value > max || value < min) {
    	    const n = typeof min === 'bigint' ? 'n' : '';
    	    let range;
    	    {
    	      if (min === 0 || min === BigInt(0)) {
    	        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
    	      } else {
    	        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
    	                `${(byteLength + 1) * 8 - 1}${n}`;
    	      }
    	    }
    	    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
    	  }
    	  checkBounds(buf, offset, byteLength);
    	}

    	function validateNumber (value, name) {
    	  if (typeof value !== 'number') {
    	    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
    	  }
    	}

    	function boundsError (value, length, type) {
    	  if (Math.floor(value) !== value) {
    	    validateNumber(value, type);
    	    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value)
    	  }

    	  if (length < 0) {
    	    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
    	  }

    	  throw new errors.ERR_OUT_OF_RANGE('offset',
    	                                    `>= ${0} and <= ${length}`,
    	                                    value)
    	}

    	// HELPER FUNCTIONS
    	// ================

    	const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    	function base64clean (str) {
    	  // Node takes equal signs as end of the Base64 encoding
    	  str = str.split('=')[0];
    	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
    	  str = str.trim().replace(INVALID_BASE64_RE, '');
    	  // Node converts strings with length < 2 to ''
    	  if (str.length < 2) return ''
    	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    	  while (str.length % 4 !== 0) {
    	    str = str + '=';
    	  }
    	  return str
    	}

    	function utf8ToBytes (string, units) {
    	  units = units || Infinity;
    	  let codePoint;
    	  const length = string.length;
    	  let leadSurrogate = null;
    	  const bytes = [];

    	  for (let i = 0; i < length; ++i) {
    	    codePoint = string.charCodeAt(i);

    	    // is surrogate component
    	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
    	      // last char was a lead
    	      if (!leadSurrogate) {
    	        // no lead yet
    	        if (codePoint > 0xDBFF) {
    	          // unexpected trail
    	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	          continue
    	        } else if (i + 1 === length) {
    	          // unpaired lead
    	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	          continue
    	        }

    	        // valid lead
    	        leadSurrogate = codePoint;

    	        continue
    	      }

    	      // 2 leads in a row
    	      if (codePoint < 0xDC00) {
    	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	        leadSurrogate = codePoint;
    	        continue
    	      }

    	      // valid surrogate pair
    	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    	    } else if (leadSurrogate) {
    	      // valid bmp char, but last char was a lead
    	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    	    }

    	    leadSurrogate = null;

    	    // encode utf8
    	    if (codePoint < 0x80) {
    	      if ((units -= 1) < 0) break
    	      bytes.push(codePoint);
    	    } else if (codePoint < 0x800) {
    	      if ((units -= 2) < 0) break
    	      bytes.push(
    	        codePoint >> 0x6 | 0xC0,
    	        codePoint & 0x3F | 0x80
    	      );
    	    } else if (codePoint < 0x10000) {
    	      if ((units -= 3) < 0) break
    	      bytes.push(
    	        codePoint >> 0xC | 0xE0,
    	        codePoint >> 0x6 & 0x3F | 0x80,
    	        codePoint & 0x3F | 0x80
    	      );
    	    } else if (codePoint < 0x110000) {
    	      if ((units -= 4) < 0) break
    	      bytes.push(
    	        codePoint >> 0x12 | 0xF0,
    	        codePoint >> 0xC & 0x3F | 0x80,
    	        codePoint >> 0x6 & 0x3F | 0x80,
    	        codePoint & 0x3F | 0x80
    	      );
    	    } else {
    	      throw new Error('Invalid code point')
    	    }
    	  }

    	  return bytes
    	}

    	function asciiToBytes (str) {
    	  const byteArray = [];
    	  for (let i = 0; i < str.length; ++i) {
    	    // Node's code seems to be doing this and not & 0x7F..
    	    byteArray.push(str.charCodeAt(i) & 0xFF);
    	  }
    	  return byteArray
    	}

    	function utf16leToBytes (str, units) {
    	  let c, hi, lo;
    	  const byteArray = [];
    	  for (let i = 0; i < str.length; ++i) {
    	    if ((units -= 2) < 0) break

    	    c = str.charCodeAt(i);
    	    hi = c >> 8;
    	    lo = c % 256;
    	    byteArray.push(lo);
    	    byteArray.push(hi);
    	  }

    	  return byteArray
    	}

    	function base64ToBytes (str) {
    	  return base64.toByteArray(base64clean(str))
    	}

    	function blitBuffer (src, dst, offset, length) {
    	  let i;
    	  for (i = 0; i < length; ++i) {
    	    if ((i + offset >= dst.length) || (i >= src.length)) break
    	    dst[i + offset] = src[i];
    	  }
    	  return i
    	}

    	// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    	// the `instanceof` check but they should be treated as of that type.
    	// See: https://github.com/feross/buffer/issues/166
    	function isInstance (obj, type) {
    	  return obj instanceof type ||
    	    (obj != null && obj.constructor != null && obj.constructor.name != null &&
    	      obj.constructor.name === type.name)
    	}
    	function numberIsNaN (obj) {
    	  // For IE11 support
    	  return obj !== obj // eslint-disable-line no-self-compare
    	}

    	// Create lookup table for `toString('hex')`
    	// See: https://github.com/feross/buffer/issues/219
    	const hexSliceLookupTable = (function () {
    	  const alphabet = '0123456789abcdef';
    	  const table = new Array(256);
    	  for (let i = 0; i < 16; ++i) {
    	    const i16 = i * 16;
    	    for (let j = 0; j < 16; ++j) {
    	      table[i16 + j] = alphabet[i] + alphabet[j];
    	    }
    	  }
    	  return table
    	})();

    	// Return not function with Error if BigInt not supported
    	function defineBigIntMethod (fn) {
    	  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
    	}

    	function BufferBigIntNotDefined () {
    	  throw new Error('BigInt not supported')
    	} 
    } (buffer));

    /*!
     * hash-wasm (https://www.npmjs.com/package/hash-wasm)
     * (c) Dani Biro
     * @license MIT
     */


    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, [])).next());
        });
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    class Mutex {
        constructor() {
            this.mutex = Promise.resolve();
        }
        lock() {
            let begin = () => { };
            this.mutex = this.mutex.then(() => new Promise(begin));
            return new Promise((res) => {
                begin = res;
            });
        }
        dispatch(fn) {
            return __awaiter(this, void 0, void 0, function* () {
                const unlock = yield this.lock();
                try {
                    return yield Promise.resolve(fn());
                }
                finally {
                    unlock();
                }
            });
        }
    }

    var _a;
    function getGlobal() {
        if (typeof globalThis !== "undefined")
            return globalThis;
        if (typeof self !== "undefined")
            return self;
        if (typeof window !== "undefined")
            return window;
        return global;
    }
    const globalObject = getGlobal();
    const nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;
    const textEncoder = globalObject.TextEncoder
        ? new globalObject.TextEncoder()
        : null;
    function hexCharCodesToInt(a, b) {
        return ((((a & 0xf) + ((a >> 6) | ((a >> 3) & 0x8))) << 4) |
            ((b & 0xf) + ((b >> 6) | ((b >> 3) & 0x8))));
    }
    function writeHexToUInt8(buf, str) {
        const size = str.length >> 1;
        for (let i = 0; i < size; i++) {
            const index = i << 1;
            buf[i] = hexCharCodesToInt(str.charCodeAt(index), str.charCodeAt(index + 1));
        }
    }
    function hexStringEqualsUInt8(str, buf) {
        if (str.length !== buf.length * 2) {
            return false;
        }
        for (let i = 0; i < buf.length; i++) {
            const strIndex = i << 1;
            if (buf[i] !==
                hexCharCodesToInt(str.charCodeAt(strIndex), str.charCodeAt(strIndex + 1))) {
                return false;
            }
        }
        return true;
    }
    const alpha = "a".charCodeAt(0) - 10;
    const digit = "0".charCodeAt(0);
    function getDigestHex(tmpBuffer, input, hashLength) {
        let p = 0;
        for (let i = 0; i < hashLength; i++) {
            let nibble = input[i] >>> 4;
            tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
            nibble = input[i] & 0xf;
            tmpBuffer[p++] = nibble > 9 ? nibble + alpha : nibble + digit;
        }
        return String.fromCharCode.apply(null, tmpBuffer);
    }
    const getUInt8Buffer = nodeBuffer !== null
        ? (data) => {
            if (typeof data === "string") {
                const buf = nodeBuffer.from(data, "utf8");
                return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
            }
            if (nodeBuffer.isBuffer(data)) {
                return new Uint8Array(data.buffer, data.byteOffset, data.length);
            }
            if (ArrayBuffer.isView(data)) {
                return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
            }
            throw new Error("Invalid data type!");
        }
        : (data) => {
            if (typeof data === "string") {
                return textEncoder.encode(data);
            }
            if (ArrayBuffer.isView(data)) {
                return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
            }
            throw new Error("Invalid data type!");
        };
    const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    const base64Lookup = new Uint8Array(256);
    for (let i = 0; i < base64Chars.length; i++) {
        base64Lookup[base64Chars.charCodeAt(i)] = i;
    }
    function getDecodeBase64Length(data) {
        let bufferLength = Math.floor(data.length * 0.75);
        const len = data.length;
        if (data[len - 1] === "=") {
            bufferLength -= 1;
            if (data[len - 2] === "=") {
                bufferLength -= 1;
            }
        }
        return bufferLength;
    }
    function decodeBase64(data) {
        const bufferLength = getDecodeBase64Length(data);
        const len = data.length;
        const bytes = new Uint8Array(bufferLength);
        let p = 0;
        for (let i = 0; i < len; i += 4) {
            const encoded1 = base64Lookup[data.charCodeAt(i)];
            const encoded2 = base64Lookup[data.charCodeAt(i + 1)];
            const encoded3 = base64Lookup[data.charCodeAt(i + 2)];
            const encoded4 = base64Lookup[data.charCodeAt(i + 3)];
            bytes[p] = (encoded1 << 2) | (encoded2 >> 4);
            p += 1;
            bytes[p] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            p += 1;
            bytes[p] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            p += 1;
        }
        return bytes;
    }

    const MAX_HEAP = 16 * 1024;
    const WASM_FUNC_HASH_LENGTH = 4;
    const wasmMutex = new Mutex();
    const wasmModuleCache = new Map();
    function WASMInterface(binary, hashLength) {
        return __awaiter(this, void 0, void 0, function* () {
            let wasmInstance = null;
            let memoryView = null;
            let initialized = false;
            if (typeof WebAssembly === "undefined") {
                throw new Error("WebAssembly is not supported in this environment!");
            }
            const writeMemory = (data, offset = 0) => {
                memoryView.set(data, offset);
            };
            const getMemory = () => memoryView;
            const getExports = () => wasmInstance.exports;
            const setMemorySize = (totalSize) => {
                wasmInstance.exports.Hash_SetMemorySize(totalSize);
                const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
                const memoryBuffer = wasmInstance.exports.memory.buffer;
                memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
            };
            const getStateSize = () => {
                const view = new DataView(wasmInstance.exports.memory.buffer);
                const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
                return stateSize;
            };
            const loadWASMPromise = wasmMutex.dispatch(() => __awaiter(this, void 0, void 0, function* () {
                if (!wasmModuleCache.has(binary.name)) {
                    const asm = decodeBase64(binary.data);
                    const promise = WebAssembly.compile(asm);
                    wasmModuleCache.set(binary.name, promise);
                }
                const module = yield wasmModuleCache.get(binary.name);
                wasmInstance = yield WebAssembly.instantiate(module, {
                // env: {
                //   emscripten_memcpy_big: (dest, src, num) => {
                //     const memoryBuffer = wasmInstance.exports.memory.buffer;
                //     const memView = new Uint8Array(memoryBuffer, 0);
                //     memView.set(memView.subarray(src, src + num), dest);
                //   },
                //   print_memory: (offset, len) => {
                //     const memoryBuffer = wasmInstance.exports.memory.buffer;
                //     const memView = new Uint8Array(memoryBuffer, 0);
                //     console.log('print_int32', memView.subarray(offset, offset + len));
                //   },
                // },
                });
                // wasmInstance.exports._start();
            }));
            const setupInterface = () => __awaiter(this, void 0, void 0, function* () {
                if (!wasmInstance) {
                    yield loadWASMPromise;
                }
                const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
                const memoryBuffer = wasmInstance.exports.memory.buffer;
                memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
            });
            const init = (bits = null) => {
                initialized = true;
                wasmInstance.exports.Hash_Init(bits);
            };
            const updateUInt8Array = (data) => {
                let read = 0;
                while (read < data.length) {
                    const chunk = data.subarray(read, read + MAX_HEAP);
                    read += chunk.length;
                    memoryView.set(chunk);
                    wasmInstance.exports.Hash_Update(chunk.length);
                }
            };
            const update = (data) => {
                if (!initialized) {
                    throw new Error("update() called before init()");
                }
                const Uint8Buffer = getUInt8Buffer(data);
                updateUInt8Array(Uint8Buffer);
            };
            const digestChars = new Uint8Array(hashLength * 2);
            const digest = (outputType, padding = null) => {
                if (!initialized) {
                    throw new Error("digest() called before init()");
                }
                initialized = false;
                wasmInstance.exports.Hash_Final(padding);
                if (outputType === "binary") {
                    // the data is copied to allow GC of the original memory object
                    return memoryView.slice(0, hashLength);
                }
                return getDigestHex(digestChars, memoryView, hashLength);
            };
            const save = () => {
                if (!initialized) {
                    throw new Error("save() can only be called after init() and before digest()");
                }
                const stateOffset = wasmInstance.exports.Hash_GetState();
                const stateLength = getStateSize();
                const memoryBuffer = wasmInstance.exports.memory.buffer;
                const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
                // prefix is 4 bytes from SHA1 hash of the WASM binary
                // it is used to detect incompatible internal states between different versions of hash-wasm
                const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
                writeHexToUInt8(prefixedState, binary.hash);
                prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
                return prefixedState;
            };
            const load = (state) => {
                if (!(state instanceof Uint8Array)) {
                    throw new Error("load() expects an Uint8Array generated by save()");
                }
                const stateOffset = wasmInstance.exports.Hash_GetState();
                const stateLength = getStateSize();
                const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
                const memoryBuffer = wasmInstance.exports.memory.buffer;
                if (state.length !== overallLength) {
                    throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
                }
                if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
                    throw new Error("This state was written by an incompatible hash implementation");
                }
                const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
                new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
                initialized = true;
            };
            const isDataShort = (data) => {
                if (typeof data === "string") {
                    // worst case is 4 bytes / char
                    return data.length < MAX_HEAP / 4;
                }
                return data.byteLength < MAX_HEAP;
            };
            let canSimplify = isDataShort;
            switch (binary.name) {
                case "argon2":
                case "scrypt":
                    canSimplify = () => true;
                    break;
                case "blake2b":
                case "blake2s":
                    // if there is a key at blake2 then cannot simplify
                    canSimplify = (data, initParam) => initParam <= 512 && isDataShort(data);
                    break;
                case "blake3":
                    // if there is a key at blake3 then cannot simplify
                    canSimplify = (data, initParam) => initParam === 0 && isDataShort(data);
                    break;
                case "xxhash64": // cannot simplify
                case "xxhash3":
                case "xxhash128":
                case "crc64":
                    canSimplify = () => false;
                    break;
            }
            // shorthand for (init + update + digest) for better performance
            const calculate = (data, initParam = null, digestParam = null) => {
                if (!canSimplify(data, initParam)) {
                    init(initParam);
                    update(data);
                    return digest("hex", digestParam);
                }
                const buffer = getUInt8Buffer(data);
                memoryView.set(buffer);
                wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
                return getDigestHex(digestChars, memoryView, hashLength);
            };
            yield setupInterface();
            return {
                getMemory,
                writeMemory,
                getExports,
                setMemorySize,
                init,
                update,
                digest,
                save,
                load,
                calculate,
                hashLength,
            };
        });
    }

    function lockedCreate(mutex, binary, hashLength) {
        return __awaiter(this, void 0, void 0, function* () {
            const unlock = yield mutex.lock();
            const wasm = yield WASMInterface(binary, hashLength);
            unlock();
            return wasm;
        });
    }

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    var name$c = "sha1";
    var data$c = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwkIAAECAwECAAEFBAEBAgIGDgJ/AUHgiQULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAILSGFzaF9VcGRhdGUABApIYXNoX0ZpbmFsAAUNSGFzaF9HZXRTdGF0ZQAGDkhhc2hfQ2FsY3VsYXRlAAcKU1RBVEVfU0laRQMBCpoqCAUAQYAJC68iCgF+An8BfgF/AX4DfwF+AX8Bfkd/QQAgACkDECIBQiCIpyICQRh0IAJBgP4DcUEIdHIgAUIoiKdBgP4DcSABQjiIp3JyIgMgACkDCCIEQiCIpyICQRh0IAJBgP4DcUEIdHIgBEIoiKdBgP4DcSAEQjiIp3JyIgVzIAApAygiBkIgiKciAkEYdCACQYD+A3FBCHRyIAZCKIinQYD+A3EgBkI4iKdyciIHcyAEpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciIIIAApAwAiBKciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCXMgACkDICIKpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciILcyAAKQMwIgxCIIinIgJBGHQgAkGA/gNxQQh0ciAMQiiIp0GA/gNxIAxCOIincnIiAnNBAXciDXNBAXciDiAFIARCIIinIg9BGHQgD0GA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiEHMgCkIgiKciD0EYdCAPQYD+A3FBCHRyIApCKIinQYD+A3EgCkI4iKdyciIRcyAAKQM4IgSnIg9BGHQgD0GA/gNxQQh0ciAPQQh2QYD+A3EgD0EYdnJyIg9zQQF3IhJzIAcgEXMgEnMgCyAAKQMYIgqnIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIhNzIA9zIA5zQQF3IgBzQQF3IhRzIA0gD3MgAHMgAiAHcyAOcyAGpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIWIAtzIA1zIApCIIinIhVBGHQgFUGA/gNxQQh0ciAKQiiIp0GA/gNxIApCOIincnIiFyADcyACcyABpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIYIAhzIBZzIARCIIinIhVBGHQgFUGA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiFXNBAXciGXNBAXciGnNBAXciG3NBAXciHHNBAXciHXNBAXciHiASIBVzIBEgF3MgFXMgEyAYcyAMpyIfQRh0IB9BgP4DcUEIdHIgH0EIdkGA/gNxIB9BGHZyciIgcyASc0EBdyIfc0EBdyIhcyAPICBzIB9zIBRzQQF3IiJzQQF3IiNzIBQgIXMgI3MgACAfcyAicyAec0EBdyIkc0EBdyIlcyAdICJzICRzIBwgFHMgHnMgGyAAcyAdcyAaIA5zIBxzIBkgDXMgG3MgFSACcyAacyAgIBZzIBlzICFzQQF3IiZzQQF3IidzQQF3IihzQQF3IilzQQF3IipzQQF3IitzQQF3IixzQQF3Ii0gIyAncyAhIBpzICdzIB8gGXMgJnMgI3NBAXciLnNBAXciL3MgIiAmcyAucyAlc0EBdyIwc0EBdyIxcyAlIC9zIDFzICQgLnMgMHMgLXNBAXciMnNBAXciM3MgLCAwcyAycyArICVzIC1zICogJHMgLHMgKSAecyArcyAoIB1zICpzICcgHHMgKXMgJiAbcyAocyAvc0EBdyI0c0EBdyI1c0EBdyI2c0EBdyI3c0EBdyI4c0EBdyI5c0EBdyI6c0EBdyI7IDEgNXMgLyApcyA1cyAuIChzIDRzIDFzQQF3IjxzQQF3Ij1zIDAgNHMgPHMgM3NBAXciPnNBAXciP3MgMyA9cyA/cyAyIDxzID5zIDtzQQF3IkBzQQF3IkFzIDogPnMgQHMgOSAzcyA7cyA4IDJzIDpzIDcgLXMgOXMgNiAscyA4cyA1ICtzIDdzIDQgKnMgNnMgPXNBAXciQnNBAXciQ3NBAXciRHNBAXciRXNBAXciRnNBAXciR3NBAXciSHNBAXciSSA+IEJzIDwgNnMgQnMgP3NBAXciSnMgQXNBAXciSyA9IDdzIENzIEpzQQF3IkwgRCA5IDIgMSA0ICkgHSAUIB8gFSAWQQAoAoCJASJNQQV3QQAoApCJASJOaiAJakEAKAKMiQEiT0EAKAKIiQEiCXNBACgChIkBIlBxIE9zakGZ84nUBWoiUUEedyJSIANqIFBBHnciAyAFaiBPIAMgCXMgTXEgCXNqIBBqIFFBBXdqQZnzidQFaiIQIFIgTUEedyIFc3EgBXNqIAkgCGogUSADIAVzcSADc2ogEEEFd2pBmfOJ1AVqIlFBBXdqQZnzidQFaiJTIFFBHnciAyAQQR53IghzcSAIc2ogBSAYaiBRIAggUnNxIFJzaiBTQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhhBHnciUmogU0EedyIWIAtqIAggE2ogBSAWIANzcSADc2ogGEEFd2pBmfOJ1AVqIgggUiAFQR53IgtzcSALc2ogAyAXaiAYIAsgFnNxIBZzaiAIQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhMgBUEedyIWIAhBHnciA3NxIANzaiALIBFqIAUgAyBSc3EgUnNqIBNBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiUkEedyILaiACIBNBHnciFWogByADaiARIBUgFnNxIBZzaiBSQQV3akGZ84nUBWoiByALIBFBHnciAnNxIAJzaiAgIBZqIFIgAiAVc3EgFXNqIAdBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiFiARQR53IhUgB0EedyIHc3EgB3NqIA8gAmogESAHIAtzcSALc2ogFkEFd2pBmfOJ1AVqIgtBBXdqQZnzidQFaiIRQR53IgJqIBIgFWogESALQR53Ig8gFkEedyISc3EgEnNqIA0gB2ogCyASIBVzcSAVc2ogEUEFd2pBmfOJ1AVqIg1BBXdqQZnzidQFaiIVQR53Ih8gDUEedyIHcyAZIBJqIA0gAiAPc3EgD3NqIBVBBXdqQZnzidQFaiINc2ogDiAPaiAVIAcgAnNxIAJzaiANQQV3akGZ84nUBWoiAkEFd2pBodfn9gZqIg5BHnciD2ogACAfaiACQR53IgAgDUEedyINcyAOc2ogGiAHaiANIB9zIAJzaiAOQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg5BHnciEiACQR53IhRzICEgDWogDyAAcyACc2ogDkEFd2pBodfn9gZqIgJzaiAbIABqIBQgD3MgDnNqIAJBBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyIOaiAcIBJqIABBHnciDyACQR53IgJzIA1zaiAmIBRqIAIgEnMgAHNqIA1BBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyISIABBHnciFHMgIiACaiAOIA9zIABzaiANQQV3akGh1+f2BmoiAHNqICcgD2ogFCAOcyANc2ogAEEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53Ig5qICggEmogAkEedyIPIABBHnciAHMgDXNqICMgFGogACAScyACc2ogDUEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53IhIgAkEedyIUcyAeIABqIA4gD3MgAnNqIA1BBXdqQaHX5/YGaiIAc2ogLiAPaiAUIA5zIA1zaiAAQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg1BHnciDmogKiAAQR53IgBqIA4gAkEedyIPcyAkIBRqIAAgEnMgAnNqIA1BBXdqQaHX5/YGaiIUc2ogLyASaiAPIABzIA1zaiAUQQV3akGh1+f2BmoiDUEFd2pBodfn9gZqIgAgDUEedyICciAUQR53IhJxIAAgAnFyaiAlIA9qIBIgDnMgDXNqIABBBXdqQaHX5/YGaiINQQV3akHc+e74eGoiDkEedyIPaiA1IABBHnciAGogKyASaiANIAByIAJxIA0gAHFyaiAOQQV3akHc+e74eGoiEiAPciANQR53Ig1xIBIgD3FyaiAwIAJqIA4gDXIgAHEgDiANcXJqIBJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAiAAQR53Ig5yIBJBHnciEnEgAiAOcXJqICwgDWogACASciAPcSAAIBJxcmogAkEFd2pB3Pnu+HhqIgBBBXdqQdz57vh4aiINQR53Ig9qIDwgAkEedyICaiA2IBJqIAAgAnIgDnEgACACcXJqIA1BBXdqQdz57vh4aiISIA9yIABBHnciAHEgEiAPcXJqIC0gDmogDSAAciACcSANIABxcmogEkEFd2pB3Pnu+HhqIgJBBXdqQdz57vh4aiINIAJBHnciDnIgEkEedyIScSANIA5xcmogNyAAaiACIBJyIA9xIAIgEnFyaiANQQV3akHc+e74eGoiAEEFd2pB3Pnu+HhqIgJBHnciD2ogMyANQR53Ig1qID0gEmogACANciAOcSAAIA1xcmogAkEFd2pB3Pnu+HhqIhIgD3IgAEEedyIAcSASIA9xcmogOCAOaiACIAByIA1xIAIgAHFyaiASQQV3akHc+e74eGoiAkEFd2pB3Pnu+HhqIg0gAkEedyIOciASQR53IhJxIA0gDnFyaiBCIABqIAIgEnIgD3EgAiAScXJqIA1BBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyIPaiBDIA5qIAIgAEEedyIUciANQR53Ig1xIAIgFHFyaiA+IBJqIAAgDXIgDnEgACANcXJqIAJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyISIABBHnciDnMgOiANaiAAIA9yIBRxIAAgD3FyaiACQQV3akHc+e74eGoiAHNqID8gFGogAiAOciAPcSACIA5xcmogAEEFd2pB3Pnu+HhqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEogEmogAkEedyIUIABBHnciAHMgDXNqIDsgDmogACAScyACc2ogDUEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig4gAkEedyIScyBFIABqIA8gFHMgAnNqIA1BBXdqQdaDi9N8aiIAc2ogQCAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciD2ogQSAOaiACQR53IhQgAEEedyIAcyANc2ogRiASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzIEIgOHMgRHMgTHNBAXciFSAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEcgFGogEiAPcyANc2ogAEEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEggDmogAkEedyIUIABBHnciAHMgDXNqIEMgOXMgRXMgFXNBAXciGSASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzID8gQ3MgTHMgS3NBAXciGiAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEQgOnMgRnMgGXNBAXciGyAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDyBOajYCkIkBQQAgTyBKIERzIBVzIBpzQQF3IhQgEmogAEEedyIAIA5zIAJzaiANQQV3akHWg4vTfGoiEkEedyIVajYCjIkBQQAgCSBFIDtzIEdzIBtzQQF3IA5qIAJBHnciAiAAcyANc2ogEkEFd2pB1oOL03xqIg1BHndqNgKIiQFBACBQIEAgSnMgS3MgSXNBAXcgAGogDyACcyASc2ogDUEFd2pB1oOL03xqIgBqNgKEiQFBACBNIEwgRXMgGXMgFHNBAXdqIAJqIBUgD3MgDXNqIABBBXdqQdaDi9N8ajYCgIkBCzoAQQBC/rnrxemOlZkQNwKIiQFBAEKBxpS6lvHq5m83AoCJAUEAQvDDy54MNwKQiQFBAEEANgKYiQELqAMBCH9BACECQQBBACgClIkBIgMgAUEDdGoiBDYClIkBQQBBACgCmIkBIAQgA0lqIAFBHXZqNgKYiQECQCADQQN2QT9xIgUgAWpBwABJDQBBwAAgBWsiAkEDcSEGQQAhAwJAIAVBP3NBA0kNACAFQYCJAWohByACQfwAcSEIQQAhAwNAIAcgA2oiBEEcaiAAIANqIgktAAA6AAAgBEEdaiAJQQFqLQAAOgAAIARBHmogCUECai0AADoAACAEQR9qIAlBA2otAAA6AAAgCCADQQRqIgNHDQALCwJAIAZFDQAgACADaiEEIAMgBWpBnIkBaiEDA0AgAyAELQAAOgAAIARBAWohBCADQQFqIQMgBkF/aiIGDQALC0GciQEQASAFQf8AcyEDQQAhBSADIAFPDQADQCAAIAJqEAEgAkH/AGohAyACQcAAaiIEIQIgAyABSQ0ACyAEIQILAkAgASACRg0AIAEgAmshCSAAIAJqIQIgBUGciQFqIQNBACEEA0AgAyACLQAAOgAAIAJBAWohAiADQQFqIQMgCSAEQQFqIgRB/wFxSw0ACwsLCQBBgAkgABADC6YDAQJ/IwBBEGsiACQAIABBgAE6AAcgAEEAKAKYiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAggAEEAKAKUiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAwgAEEHakEBEAMCQEEAKAKUiQFB+ANxQcADRg0AA0AgAEEAOgAHIABBB2pBARADQQAoApSJAUH4A3FBwANHDQALCyAAQQhqQQgQA0EAQQAoAoCJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAlBAEEAKAKEiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AoQJQQBBACgCiIkBIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyNgKICUEAQQAoAoyJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCjAlBAEEAKAKQiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2ApAJIABBEGokAAsGAEGAiQELQwBBAEL+uevF6Y6VmRA3AoiJAUEAQoHGlLqW8ermbzcCgIkBQQBC8MPLngw3ApCJAUEAQQA2ApiJAUGACSAAEAMQBQsLCwEAQYAICwRcAAAA";
    var hash$c = "6b530c24";
    var wasmJson$c = {
    	name: name$c,
    	data: data$c,
    	hash: hash$c
    };

    const mutex$d = new Mutex();
    let wasmCache$d = null;
    /**
     * Calculates SHA-1 hash
     * @param data Input data (string, Buffer or TypedArray)
     * @returns Computed hash as a hexadecimal string
     */
    function sha1(data) {
        if (wasmCache$d === null) {
            return lockedCreate(mutex$d, wasmJson$c, 20).then((wasm) => {
                wasmCache$d = wasm;
                return wasmCache$d.calculate(data);
            });
        }
        try {
            const hash = wasmCache$d.calculate(data);
            return Promise.resolve(hash);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * Creates a new SHA-1 hash instance
     */
    function createSHA1() {
        return WASMInterface(wasmJson$c, 20).then((wasm) => {
            wasm.init();
            const obj = {
                init: () => {
                    wasm.init();
                    return obj;
                },
                update: (data) => {
                    wasm.update(data);
                    return obj;
                },
                // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
                digest: (outputType) => wasm.digest(outputType),
                save: () => wasm.save(),
                load: (data) => {
                    wasm.load(data);
                    return obj;
                },
                blockSize: 64,
                digestSize: 20,
            };
            return obj;
        });
    }

    new Mutex();

    new Mutex();

    var name$a = "sha256";
    var data$a = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQfCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKnEoHBQBBgAkLnQEAQQBCADcDwIkBQQBBHEEgIABB4AFGIgAbNgLoiQFBAEKnn+anxvST/b5/Qquzj/yRo7Pw2wAgABs3A+CJAUEAQrGWgP6fooWs6ABC/6S5iMWR2oKbfyAAGzcD2IkBQQBCl7rDg5Onlod3QvLmu+Ojp/2npX8gABs3A9CJAUEAQti9loj8oLW+NkLnzKfQ1tDrs7t/IAAbNwPIiQEL7wICAX4Gf0EAQQApA8CJASIBIACtfDcDwIkBAkACQAJAIAGnQT9xIgINAEGACSEDDAELAkBBwAAgAmsiBCAAIAQgAEkbIgNFDQAgA0EDcSEFIAJBgIkBaiEGQQAhAgJAIANBBEkNACADQfwAcSEHQQAhAgNAIAYgAmoiAyACQYAJai0AADoAACADQQFqIAJBgQlqLQAAOgAAIANBAmogAkGCCWotAAA6AAAgA0EDaiACQYMJai0AADoAACAHIAJBBGoiAkcNAAsLIAVFDQADQCAGIAJqIAJBgAlqLQAAOgAAIAJBAWohAiAFQX9qIgUNAAsLIAAgBEkNAUGAiQEQAyAAIARrIQAgBEGACWohAwsCQCAAQcAASQ0AA0AgAxADIANBwABqIQMgAEFAaiIAQT9LDQALCyAARQ0AQQAhAkEAIQUDQCACQYCJAWogAyACai0AADoAACACQQFqIQIgACAFQQFqIgVB/wFxSw0ACwsLoz4BRX9BACAAKAI8IgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyIgFBGXcgAUEOd3MgAUEDdnMgACgCOCICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciICaiAAKAIgIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIgRBGXcgBEEOd3MgBEEDdnMgACgCHCIDQRh0IANBgP4DcUEIdHIgA0EIdkGA/gNxIANBGHZyciIFaiAAKAIEIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIgZBGXcgBkEOd3MgBkEDdnMgACgCACIDQRh0IANBgP4DcUEIdHIgA0EIdkGA/gNxIANBGHZyciIHaiAAKAIkIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIghqIAJBD3cgAkENd3MgAkEKdnNqIgNqIAAoAhgiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiCkEZdyAKQQ53cyAKQQN2cyAAKAIUIglBGHQgCUGA/gNxQQh0ciAJQQh2QYD+A3EgCUEYdnJyIgtqIAJqIAAoAhAiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiDEEZdyAMQQ53cyAMQQN2cyAAKAIMIglBGHQgCUGA/gNxQQh0ciAJQQh2QYD+A3EgCUEYdnJyIg1qIAAoAjAiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiDmogACgCCCIJQRh0IAlBgP4DcUEIdHIgCUEIdkGA/gNxIAlBGHZyciIPQRl3IA9BDndzIA9BA3ZzIAZqIAAoAigiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiEGogAUEPdyABQQ13cyABQQp2c2oiCUEPdyAJQQ13cyAJQQp2c2oiEUEPdyARQQ13cyARQQp2c2oiEkEPdyASQQ13cyASQQp2c2oiE2ogACgCNCIUQRh0IBRBgP4DcUEIdHIgFEEIdkGA/gNxIBRBGHZyciIVQRl3IBVBDndzIBVBA3ZzIA5qIBJqIAAoAiwiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnIiFkEZdyAWQQ53cyAWQQN2cyAQaiARaiAIQRl3IAhBDndzIAhBA3ZzIARqIAlqIAVBGXcgBUEOd3MgBUEDdnMgCmogAWogC0EZdyALQQ53cyALQQN2cyAMaiAVaiANQRl3IA1BDndzIA1BA3ZzIA9qIBZqIANBD3cgA0ENd3MgA0EKdnNqIhRBD3cgFEENd3MgFEEKdnNqIhdBD3cgF0ENd3MgF0EKdnNqIhhBD3cgGEENd3MgGEEKdnNqIhlBD3cgGUENd3MgGUEKdnNqIhpBD3cgGkENd3MgGkEKdnNqIhtBD3cgG0ENd3MgG0EKdnNqIhxBGXcgHEEOd3MgHEEDdnMgAkEZdyACQQ53cyACQQN2cyAVaiAYaiAOQRl3IA5BDndzIA5BA3ZzIBZqIBdqIBBBGXcgEEEOd3MgEEEDdnMgCGogFGogE0EPdyATQQ13cyATQQp2c2oiHUEPdyAdQQ13cyAdQQp2c2oiHkEPdyAeQQ13cyAeQQp2c2oiH2ogE0EZdyATQQ53cyATQQN2cyAYaiADQRl3IANBDndzIANBA3ZzIAFqIBlqIB9BD3cgH0ENd3MgH0EKdnNqIiBqIBJBGXcgEkEOd3MgEkEDdnMgF2ogH2ogEUEZdyARQQ53cyARQQN2cyAUaiAeaiAJQRl3IAlBDndzIAlBA3ZzIANqIB1qIBxBD3cgHEENd3MgHEEKdnNqIiFBD3cgIUENd3MgIUEKdnNqIiJBD3cgIkENd3MgIkEKdnNqIiNBD3cgI0ENd3MgI0EKdnNqIiRqIBtBGXcgG0EOd3MgG0EDdnMgHmogI2ogGkEZdyAaQQ53cyAaQQN2cyAdaiAiaiAZQRl3IBlBDndzIBlBA3ZzIBNqICFqIBhBGXcgGEEOd3MgGEEDdnMgEmogHGogF0EZdyAXQQ53cyAXQQN2cyARaiAbaiAUQRl3IBRBDndzIBRBA3ZzIAlqIBpqICBBD3cgIEENd3MgIEEKdnNqIiVBD3cgJUENd3MgJUEKdnNqIiZBD3cgJkENd3MgJkEKdnNqIidBD3cgJ0ENd3MgJ0EKdnNqIihBD3cgKEENd3MgKEEKdnNqIilBD3cgKUENd3MgKUEKdnNqIipBD3cgKkENd3MgKkEKdnNqIitBGXcgK0EOd3MgK0EDdnMgH0EZdyAfQQ53cyAfQQN2cyAbaiAnaiAeQRl3IB5BDndzIB5BA3ZzIBpqICZqIB1BGXcgHUEOd3MgHUEDdnMgGWogJWogJEEPdyAkQQ13cyAkQQp2c2oiLEEPdyAsQQ13cyAsQQp2c2oiLUEPdyAtQQ13cyAtQQp2c2oiLmogJEEZdyAkQQ53cyAkQQN2cyAnaiAgQRl3ICBBDndzICBBA3ZzIBxqIChqIC5BD3cgLkENd3MgLkEKdnNqIi9qICNBGXcgI0EOd3MgI0EDdnMgJmogLmogIkEZdyAiQQ53cyAiQQN2cyAlaiAtaiAhQRl3ICFBDndzICFBA3ZzICBqICxqICtBD3cgK0ENd3MgK0EKdnNqIjBBD3cgMEENd3MgMEEKdnNqIjFBD3cgMUENd3MgMUEKdnNqIjJBD3cgMkENd3MgMkEKdnNqIjNqICpBGXcgKkEOd3MgKkEDdnMgLWogMmogKUEZdyApQQ53cyApQQN2cyAsaiAxaiAoQRl3IChBDndzIChBA3ZzICRqIDBqICdBGXcgJ0EOd3MgJ0EDdnMgI2ogK2ogJkEZdyAmQQ53cyAmQQN2cyAiaiAqaiAlQRl3ICVBDndzICVBA3ZzICFqIClqIC9BD3cgL0ENd3MgL0EKdnNqIjRBD3cgNEENd3MgNEEKdnNqIjVBD3cgNUENd3MgNUEKdnNqIjZBD3cgNkENd3MgNkEKdnNqIjdBD3cgN0ENd3MgN0EKdnNqIjhBD3cgOEENd3MgOEEKdnNqIjlBD3cgOUENd3MgOUEKdnNqIjogOCA0IC4gLCAhIBsgGSADIA4gBEEAKALYiQEiO0EadyA7QRV3cyA7QQd3c0EAKALkiQEiPGpBACgC4IkBIj1BACgC3IkBIj5zIDtxID1zaiAHakGY36iUBGoiB0EAKALUiQEiP2oiACAMaiA7IA1qID4gD2ogPSAGaiAAID4gO3NxID5zaiAAQRp3IABBFXdzIABBB3dzakGRid2JB2oiQEEAKALQiQEiQWoiDCAAIDtzcSA7c2ogDEEadyAMQRV3cyAMQQd3c2pBz/eDrntqIkJBACgCzIkBIkNqIg0gDCAAc3EgAHNqIA1BGncgDUEVd3MgDUEHd3NqQaW3181+aiJEQQAoAsiJASIAaiIPIA0gDHNxIAxzaiAPQRp3IA9BFXdzIA9BB3dzakHbhNvKA2oiRSBBIEMgAHNxIEMgAHFzIABBHncgAEETd3MgAEEKd3NqIAdqIgZqIgdqIAUgD2ogCiANaiALIAxqIAcgDyANc3EgDXNqIAdBGncgB0EVd3MgB0EHd3NqQfGjxM8FaiIKIAYgAHMgQ3EgBiAAcXMgBkEedyAGQRN3cyAGQQp3c2ogQGoiDGoiBCAHIA9zcSAPc2ogBEEadyAEQRV3cyAEQQd3c2pBpIX+kXlqIgsgDCAGcyAAcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiBCaiINaiIPIAQgB3NxIAdzaiAPQRp3IA9BFXdzIA9BB3dzakHVvfHYemoiQCANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIERqIgZqIgcgDyAEc3EgBHNqIAdBGncgB0EVd3MgB0EHd3NqQZjVnsB9aiJCIAYgDXMgDHEgBiANcXMgBkEedyAGQRN3cyAGQQp3c2ogRWoiDGoiBWogFiAHaiAQIA9qIAggBGogBSAHIA9zcSAPc2ogBUEadyAFQRV3cyAFQQd3c2pBgbaNlAFqIgggDCAGcyANcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiAKaiINaiIPIAUgB3NxIAdzaiAPQRp3IA9BFXdzIA9BB3dzakG+i8ahAmoiDiANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIAtqIgZqIgcgDyAFc3EgBXNqIAdBGncgB0EVd3MgB0EHd3NqQcP7sagFaiIQIAYgDXMgDHEgBiANcXMgBkEedyAGQRN3cyAGQQp3c2ogQGoiDGoiBCAHIA9zcSAPc2ogBEEadyAEQRV3cyAEQQd3c2pB9Lr5lQdqIhYgDCAGcyANcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiBCaiINaiIFaiABIARqIAIgB2ogFSAPaiAFIAQgB3NxIAdzaiAFQRp3IAVBFXdzIAVBB3dzakH+4/qGeGoiByANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIAhqIgFqIgYgBSAEc3EgBHNqIAZBGncgBkEVd3MgBkEHd3NqQaeN8N55aiIEIAEgDXMgDHEgASANcXMgAUEedyABQRN3cyABQQp3c2ogDmoiAmoiDCAGIAVzcSAFc2ogDEEadyAMQRV3cyAMQQd3c2pB9OLvjHxqIgUgAiABcyANcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAQaiIDaiINIAwgBnNxIAZzaiANQRp3IA1BFXdzIA1BB3dzakHB0+2kfmoiCCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBZqIgFqIg8gF2ogESANaiAUIAxqIAkgBmogDyANIAxzcSAMc2ogD0EadyAPQRV3cyAPQQd3c2pBho/5/X5qIgYgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAHaiICaiIJIA8gDXNxIA1zaiAJQRp3IAlBFXdzIAlBB3dzakHGu4b+AGoiDCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIARqIgNqIhEgCSAPc3EgD3NqIBFBGncgEUEVd3MgEUEHd3NqQczDsqACaiINIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogBWoiAWoiFCARIAlzcSAJc2ogFEEadyAUQRV3cyAUQQd3c2pB79ik7wJqIg8gASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAIaiICaiIXaiATIBRqIBggEWogEiAJaiAXIBQgEXNxIBFzaiAXQRp3IBdBFXdzIBdBB3dzakGqidLTBGoiGCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIAZqIgNqIgkgFyAUc3EgFHNqIAlBGncgCUEVd3MgCUEHd3NqQdzTwuUFaiIUIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogDGoiAWoiESAJIBdzcSAXc2ogEUEadyARQRV3cyARQQd3c2pB2pHmtwdqIhcgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiANaiICaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakHSovnBeWoiGSACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIA9qIgNqIhNqIB4gEmogGiARaiAdIAlqIBMgEiARc3EgEXNqIBNBGncgE0EVd3MgE0EHd3NqQe2Mx8F6aiIaIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGGoiAWoiCSATIBJzcSASc2ogCUEadyAJQRV3cyAJQQd3c2pByM+MgHtqIhggASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAUaiICaiIRIAkgE3NxIBNzaiARQRp3IBFBFXdzIBFBB3dzakHH/+X6e2oiFCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBdqIgNqIhIgESAJc3EgCXNqIBJBGncgEkEVd3MgEkEHd3NqQfOXgLd8aiIXIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGWoiAWoiE2ogICASaiAcIBFqIB8gCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBx6KerX1qIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakHRxqk2aiIaIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGGoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB59KkoQFqIhggAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAUaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGFldy9AmoiFCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBdqIgJqIhMgI2ogJiASaiAiIBFqICUgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBuMLs8AJqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakH827HpBGoiGSADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBpqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQZOa4JkFaiIaIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGGoiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pB1OapqAZqIhggAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAUaiIDaiITaiAoIBJqICQgEWogJyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakG7laizB2oiFCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBdqIgFqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQa6Si454aiIXIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGWoiAmoiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pBhdnIk3lqIhkgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAaaiIDaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGh0f+VemoiGiADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBhqIgFqIhNqICogEmogLSARaiApIAlqIBMgEiARc3EgEXNqIBNBGncgE0EVd3MgE0EHd3NqQcvM6cB6aiIYIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogFGoiAmoiCSATIBJzcSASc2ogCUEadyAJQRV3cyAJQQd3c2pB8JauknxqIhQgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAXaiIDaiIRIAkgE3NxIBNzaiARQRp3IBFBFXdzIBFBB3dzakGjo7G7fGoiFyADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBlqIgFqIhIgESAJc3EgCXNqIBJBGncgEkEVd3MgEkEHd3NqQZnQy4x9aiIZIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGmoiAmoiE2ogMCASaiAvIBFqICsgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBpIzktH1qIhogAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAYaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakGF67igf2oiGCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBRqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQfDAqoMBaiIUIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogF2oiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pBloKTzQFqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiITIDZqIDIgEmogNSARaiAxIAlqIBMgEiARc3EgEXNqIBNBGncgE0EVd3MgE0EHd3NqQYjY3fEBaiIZIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGmoiAWoiCSATIBJzcSASc2ogCUEadyAJQRV3cyAJQQd3c2pBzO6hugJqIhogASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAYaiICaiIRIAkgE3NxIBNzaiARQRp3IBFBFXdzIBFBB3dzakG1+cKlA2oiGCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBRqIgNqIhIgESAJc3EgCXNqIBJBGncgEkEVd3MgEkEHd3NqQbOZ8MgDaiIUIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogF2oiAWoiE2ogLEEZdyAsQQ53cyAsQQN2cyAoaiA0aiAzQQ93IDNBDXdzIDNBCnZzaiIXIBJqIDcgEWogMyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakHK1OL2BGoiGyABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBlqIgJqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQc+U89wFaiIZIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGmoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB89+5wQZqIhogAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAYaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakHuhb6kB2oiHCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBRqIgJqIhNqIC5BGXcgLkEOd3MgLkEDdnMgKmogNmogLUEZdyAtQQ53cyAtQQN2cyApaiA1aiAXQQ93IBdBDXdzIBdBCnZzaiIUQQ93IBRBDXdzIBRBCnZzaiIYIBJqIDkgEWogFCAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakHvxpXFB2oiCSACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBtqIgNqIhEgEyASc3EgEnNqIBFBGncgEUEVd3MgEUEHd3NqQZTwoaZ4aiIbIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGWoiAWoiEiARIBNzcSATc2ogEkEadyASQRV3cyASQQd3c2pBiISc5nhqIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiITIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakH6//uFeWoiGiACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBxqIgNqIhQgPGo2AuSJAUEAID8gAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAJaiIBIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBtqIgIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGWoiAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAaaiIJajYC1IkBQQAgPSAvQRl3IC9BDndzIC9BA3ZzICtqIDdqIBhBD3cgGEENd3MgGEEKdnNqIhggEWogFCATIBJzcSASc2ogFEEadyAUQRV3cyAUQQd3c2pB69nBonpqIhkgAWoiEWo2AuCJAUEAIEEgCSADcyACcSAJIANxcyAJQR53IAlBE3dzIAlBCndzaiAZaiIBajYC0IkBQQAgPiAwQRl3IDBBDndzIDBBA3ZzIC9qIBdqIDpBD3cgOkENd3MgOkEKdnNqIBJqIBEgFCATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQffH5vd7aiIXIAJqIhJqNgLciQFBACBDIAEgCXMgA3EgASAJcXMgAUEedyABQRN3cyABQQp3c2ogF2oiAmo2AsyJAUEAIDsgNEEZdyA0QQ53cyA0QQN2cyAwaiA4aiAYQQ93IBhBDXdzIBhBCnZzaiATaiASIBEgFHNxIBRzaiASQRp3IBJBFXdzIBJBB3dzakHy8cWzfGoiESADamo2AtiJAUEAIAAgAiABcyAJcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiARamo2AsiJAQuyBgIEfwF+QQAoAsCJASIAQQJ2QQ9xIgFBAnRBgIkBaiICIAIoAgBBfyAAQQN0IgB0QX9zcUGAASAAdHM2AgACQAJAAkAgAUEOSQ0AAkAgAUEORw0AQQBBADYCvIkBC0GAiQEQA0EAIQIMAQsgAUENRg0BIAFBAWohAgsgAiEDAkBBBiACa0EHcSIARQ0AIAIgAGohAyACQQJ0QYCJAWohAQNAIAFBADYCACABQQRqIQEgAEF/aiIADQALCyACQXlqQQdJDQAgA0ECdCEBA0AgAUGYiQFqQgA3AgAgAUGQiQFqQgA3AgAgAUGIiQFqQgA3AgAgAUGAiQFqQgA3AgAgAUEgaiIBQThHDQALC0EAIQFBAEEAKQPAiQEiBKciAEEbdCAAQQt0QYCA/AdxciAAQQV2QYD+A3EgAEEDdEEYdnJyNgK8iQFBACAEQh2IpyIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycjYCuIkBQYCJARADQQBBACgC5IkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgLkiQFBAEEAKALgiQEiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AuCJAUEAQQAoAtyJASIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycjYC3IkBQQBBACgC2IkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgLYiQFBAEEAKALUiQEiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AtSJAUEAQQAoAtCJASIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycjYC0IkBQQBBACgCzIkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgLMiQFBAEEAKALIiQEiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AsiJAQJAQQAoAuiJASICRQ0AQQAhAANAIAFBgAlqIAFByIkBai0AADoAACABQQFqIQEgAiAAQQFqIgBB/wFxSw0ACwsLBgBBgIkBC6MBAEEAQgA3A8CJAUEAQRxBICABQeABRiIBGzYC6IkBQQBCp5/mp8b0k/2+f0Krs4/8kaOz8NsAIAEbNwPgiQFBAEKxloD+n6KFrOgAQv+kuYjFkdqCm38gARs3A9iJAUEAQpe6w4OTp5aHd0Ly5rvjo6f9p6V/IAEbNwPQiQFBAELYvZaI/KC1vjZC58yn0NbQ67O7fyABGzcDyIkBIAAQAhAECwsLAQBBgAgLBHAAAAA=";
    var hash$a = "8c18dd94";
    var wasmJson$a = {
    	name: name$a,
    	data: data$a,
    	hash: hash$a
    };

    new Mutex();

    new Mutex();
    /**
     * Creates a new SHA-2 (SHA-256) hash instance
     */
    function createSHA256() {
        return WASMInterface(wasmJson$a, 32).then((wasm) => {
            wasm.init(256);
            const obj = {
                init: () => {
                    wasm.init(256);
                    return obj;
                },
                update: (data) => {
                    wasm.update(data);
                    return obj;
                },
                // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
                digest: (outputType) => wasm.digest(outputType),
                save: () => wasm.save(),
                load: (data) => {
                    wasm.load(data);
                    return obj;
                },
                blockSize: 64,
                digestSize: 32,
            };
            return obj;
        });
    }

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    new Mutex();

    function calculateKeyBuffer(hasher, key) {
        const { blockSize } = hasher;
        const buf = getUInt8Buffer(key);
        if (buf.length > blockSize) {
            hasher.update(buf);
            const uintArr = hasher.digest("binary");
            hasher.init();
            return uintArr;
        }
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
    }
    function calculateHmac(hasher, key) {
        hasher.init();
        const { blockSize } = hasher;
        const keyBuf = calculateKeyBuffer(hasher, key);
        const keyBuffer = new Uint8Array(blockSize);
        keyBuffer.set(keyBuf);
        const opad = new Uint8Array(blockSize);
        for (let i = 0; i < blockSize; i++) {
            const v = keyBuffer[i];
            opad[i] = v ^ 0x5c;
            keyBuffer[i] = v ^ 0x36;
        }
        hasher.update(keyBuffer);
        const obj = {
            init: () => {
                hasher.init();
                hasher.update(keyBuffer);
                return obj;
            },
            update: (data) => {
                hasher.update(data);
                return obj;
            },
            digest: ((outputType) => {
                const uintArr = hasher.digest("binary");
                hasher.init();
                hasher.update(opad);
                hasher.update(uintArr);
                return hasher.digest(outputType);
                // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
            }),
            save: () => {
                throw new Error("save() not supported");
            },
            load: () => {
                throw new Error("load() not supported");
            },
            blockSize: hasher.blockSize,
            digestSize: hasher.digestSize,
        };
        return obj;
    }
    /**
     * Calculates HMAC hash
     * @param hash Hash algorithm to use. It has to be the return value of a function like createSHA1()
     * @param key Key (string, Buffer or TypedArray)
     */
    function createHMAC(hash, key) {
        if (!hash || !hash.then) {
            throw new Error('Invalid hash function is provided! Usage: createHMAC(createMD5(), "key").');
        }
        return hash.then((hasher) => calculateHmac(hasher, key));
    }

    new Mutex();

    new Mutex();

    var _Hash_hash;
    class FormData {
    }
    class utilLib {
    }
    utilLib.inspect = {
        custom: 'inspect.custom',
    };
    class Hash {
        constructor({ algorithm }) {
            _Hash_hash.set(this, void 0);
            this.algorithm = algorithm;
            __classPrivateFieldSet(this, _Hash_hash, undefined, "f");
        }
        initializeBrowserHash() {
            return __awaiter$1(this, void 0, void 0, function* () {
                switch (this.algorithm) {
                    case 'sha1':
                        __classPrivateFieldSet(this, _Hash_hash, yield createSHA1(), "f");
                        __classPrivateFieldGet(this, _Hash_hash, "f").init();
                        break;
                    default:
                        throw new Error(`Unsupported algorithm: ${this.algorithm}`);
                }
            });
        }
        updateHash(data) {
            return __awaiter$1(this, void 0, void 0, function* () {
                if (!__classPrivateFieldGet(this, _Hash_hash, "f")) {
                    yield this.initializeBrowserHash();
                }
                __classPrivateFieldGet(this, _Hash_hash, "f").update(data);
            });
        }
        digestHash() {
            return __awaiter$1(this, arguments, void 0, function* (encoding = 'base64') {
                if (!__classPrivateFieldGet(this, _Hash_hash, "f")) {
                    yield this.initializeBrowserHash();
                }
                const d = __classPrivateFieldGet(this, _Hash_hash, "f").digest('binary');
                switch (encoding) {
                    case 'base64':
                        return buffer.Buffer.from(d).toString('base64');
                    default:
                        throw new Error(`Unsupported encoding: ${encoding}`);
                }
            });
        }
    }
    _Hash_hash = new WeakMap();
    function generateByteStreamFromBuffer(buffer) {
        return new ReadableStream({
            start(controller) {
                controller.enqueue(new Uint8Array(buffer));
                controller.close();
            },
        });
    }
    function readByteStream(byteStream) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const buffers = [];
            // Browser ReadableStream
            const reader = byteStream.getReader();
            while (true) {
                const { done, value } = yield reader.read();
                if (done)
                    break;
                buffers.push(buffer.Buffer.from(value));
            }
            return buffer.Buffer.concat(buffers);
        });
    }
    function iterateChunks(stream, chunkSize, fileSize) {
        return __asyncGenerator(this, arguments, function* iterateChunks_1() {
            let buffers = [];
            let totalSize = 0;
            let consumedSize = 0;
            const reader = stream.getReader();
            while (consumedSize < fileSize) {
                const { done, value } = yield __await(reader.read());
                if (done)
                    break;
                const data = buffer.Buffer.from(value);
                consumedSize += data.length;
                buffers.push(data);
                totalSize += data.length;
                yield __await(yield* __asyncDelegator(__asyncValues(yieldChunks())));
            }
            if (consumedSize !== fileSize) {
                throw new Error(`Stream size ${consumedSize} does not match expected file size ${fileSize}`);
            }
            if (totalSize > 0) {
                yield yield __await(yield __await(generateByteStreamFromBuffer(buffer.Buffer.concat(buffers))));
            }
            /**
             * Yields chunks of the desired `chunkSize` if enough data is available.
             */
            function yieldChunks() {
                return __asyncGenerator(this, arguments, function* yieldChunks_1() {
                    if (totalSize < chunkSize)
                        return yield __await(void 0);
                    const buffer$1 = buffer.Buffer.concat(buffers);
                    let start = 0;
                    while (totalSize >= chunkSize) {
                        yield yield __await(yield __await(generateByteStreamFromBuffer(buffer$1.subarray(start, start + chunkSize))));
                        start += chunkSize;
                        totalSize -= chunkSize;
                    }
                    buffers = totalSize > 0 ? [buffer$1.subarray(start)] : [];
                });
            }
        });
    }
    class DefaultPrivateKeyDecryptor {
        constructor(fields) { }
    }
    /**
     * Creates a JWT assertion.
     *
     * @param claims
     * @param key
     * @param options
     * @returns
     */
    function createJwtAssertion(claims, key, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
            throw new Error('This function is not supported in the browser');
        });
    }
    /**
     * Reads a text file and returns its content.
     */
    function readTextFromFile(filepath) {
        throw new Error('This function is not supported in the browser');
    }
    /**
     * Create web agent from proxy agent options.
     */
    function createAgent(options, proxyConfig) {
        return undefined;
    }
    /**
     * Stringify JSON with escaped multibyte Unicode characters to ensure computed signatures match PHP's default behavior
     *
     * @param {Object} body - The parsed JSON object
     * @returns {string} - Stringified JSON with escaped multibyte Unicode characters
     * @private
     */
    function jsonStringifyWithEscapedUnicode(body) {
        return body
            .replace(/[\u007f-\uffff]/g, (char) => `\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`)
            .replace(/(?<!\\)\//g, '\\/');
    }
    /**
     * Compute the message signature
     * @see {@Link https://developer.box.com/en/guides/webhooks/handle/setup-signatures/}
     *
     * @param {string} body - The request body of the webhook message
     * @param {Object} headers - The request headers of the webhook message
     * @param {string} signatureKey - The signature to verify the message with
     * @param {string} escapeBody - Indicates if payload should be escaped or left as is
     * @returns {?string} - The message signature (or null, if it can't be computed)
     * @private
     */
    function computeWebhookSignature(body_1, headers_1, signatureKey_1) {
        return __awaiter$1(this, arguments, void 0, function* (body, headers, signatureKey, escapeBody = false) {
            if (headers['box-signature-version'] !== '1') {
                return null;
            }
            if (headers['box-signature-algorithm'] !== 'HmacSHA256') {
                return null;
            }
            let signature = null;
            const escapedBody = escapeBody ? jsonStringifyWithEscapedUnicode(body) : body;
            const hashFunc = createSHA256();
            const hmac = yield createHMAC(hashFunc, signatureKey);
            hmac.init();
            hmac.update(escapedBody);
            hmac.update(headers['box-delivery-timestamp']);
            const result = yield hmac.digest('binary');
            signature = buffer.Buffer.from(result).toString('base64');
            return signature;
        });
    }
    function compareSignatures(expectedSignature, receivedSignature) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!expectedSignature || !receivedSignature) {
                return false;
            }
            if (expectedSignature.length !== receivedSignature.length)
                return false;
            let result = 0;
            for (let i = 0; i < expectedSignature.length; i++) {
                result |= expectedSignature.charCodeAt(i) ^ receivedSignature.charCodeAt(i);
            }
            return result === 0;
        });
    }
    function calculateMD5Hash(data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            return yield sha1(data);
        });
    }

    function jsonToSerializedData(text) {
        return JSON.parse(text);
    }
    function sdToJson(data) {
        return JSON.stringify(data);
    }
    function sdToUrlParams(data) {
        if (!sdIsMap(data) && !sdIsString(data)) {
            throw new Error('Expecting an object or string as an argument for sdToUrlParams');
        }
        const dataAsMap = sdIsString(data)
            ? JSON.parse(data)
            : data;
        return new URLSearchParams(Object.fromEntries(Object.entries(dataAsMap).filter(([key, value]) => value != null))).toString();
    }
    function sdIsBoolean(data) {
        return typeof data == 'boolean';
    }
    function sdIsNumber(data) {
        return typeof data == 'number';
    }
    function sdIsString(data) {
        return typeof data == 'string';
    }
    function sdIsList(data) {
        return Array.isArray(data);
    }
    function sdIsMap(data) {
        return typeof data === 'object' && data != null && !Array.isArray(data);
    }
    /**
     * Returns a string replacement for sensitive data.
     */
    function sanitizedValue() {
        return '---[redacted]---';
    }
    /**
     * Sanitize serialized data by replacing sensitive values with a placeholder.
     * @param sd SerializedData to sanitize
     * @param keysToSanitize Keys to sanitize
     */
    function sanitizeSerializedData(sd, keysToSanitize) {
        if (!sdIsMap(sd)) {
            return sd;
        }
        const sanitizedDictionary = {};
        for (const [key, value] of Object.entries(sd)) {
            if (key.toLowerCase() in keysToSanitize && typeof value === 'string') {
                sanitizedDictionary[key] = sanitizedValue();
            }
            else if (typeof value === 'object') {
                sanitizedDictionary[key] = sanitizeSerializedData(value, keysToSanitize);
            }
            else {
                sanitizedDictionary[key] = value;
            }
        }
        return sanitizedDictionary;
    }

    function isBrowser() {
        return (typeof window === 'object' && typeof document === 'object' && window.crypto);
    }
    function getUuid() {
        return v4();
    }
    function hexToBase64(data) {
        return buffer.Buffer.from(data, 'hex').toString('base64');
    }
    // using wrappers for date/datetime because of inability to export built-in Date types
    class DateWrapper {
        constructor(value) {
            this.value = value;
        }
    }
    class DateTimeWrapper {
        constructor(value) {
            this.value = value;
        }
    }
    function dateFromString(value) {
        return new DateWrapper(new Date(value));
    }
    function dateToString(date) {
        return date.value.toISOString().match(/^\d{4}-\d{2}-\d{2}/)[0];
    }
    function dateTimeFromString(value) {
        return new DateTimeWrapper(new Date(value));
    }
    function dateTimeToString(dateTime) {
        return (dateTime.value
            .toISOString()
            .match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)[0] + '+00:00');
    }
    function dateTimeToEpochSeconds(dateTime) {
        return Math.floor(dateTime.value.getTime() / 1000);
    }
    function bufferLength(buffer) {
        return buffer.length;
    }
    function reduceIterator(iterator, reducer, initialValue) {
        return __awaiter$1(this, void 0, void 0, function* () {
            let result = initialValue;
            let iteration = yield iterator.next();
            while (!iteration.done) {
                result = yield reducer(result, iteration.value);
                iteration = yield iterator.next();
            }
            return result;
        });
    }
    function prepareParams(map) {
        if (!map || typeof map !== 'object') {
            throw new Error('Expecting obj to be an object in prepareParams');
        }
        return Object.fromEntries(Object.entries(map).filter((entry) => typeof entry[1] === 'string'));
    }
    function toString(value) {
        if (typeof value === 'string' || value == null) {
            return value;
        }
        return String(value);
    }
    /**
     * Get current epoch time in seconds.
     */
    function getEpochTimeInSeconds() {
        return Math.floor(Date.now() / 1000);
    }
    /**
     * Create a cancellation controller.
     */
    function createCancellationController() {
        return new AbortController();
    }
    function random(min, max) {
        return Math.random() * (max - min) + min;
    }
    function multipartStreamToBuffer(multipart) {
        return __awaiter$1(this, void 0, void 0, function* () {
            return yield Promise.all(multipart.map((item) => __awaiter$1(this, void 0, void 0, function* () {
                if (!item.fileStream) {
                    return item;
                }
                return Object.assign(Object.assign({}, item), { fileStream: undefined, fileStreamBuffer: item.fileStream
                        ? yield readByteStream(item.fileStream)
                        : undefined });
            })));
        });
    }
    function multipartBufferToStream(multipart) {
        return multipart.map((item) => {
            if (!item.fileStreamBuffer) {
                return item;
            }
            return Object.assign(Object.assign({}, item), { fileStreamBuffer: undefined, fileStream: item.fileStreamBuffer
                    ? generateByteStreamFromBuffer(item.fileStreamBuffer)
                    : undefined });
        });
    }
    /**
     * Sanitize a map by replacing sensitive values with a placeholder.
     * @param dictionary The map to sanitize
     * @param keysToSanitize Keys to sanitize
     */
    function sanitizeMap(dictionary, keysToSanitize) {
        return Object.fromEntries(Object.entries(dictionary).map(([k, v]) => k.toLowerCase() in keysToSanitize ? [k, sanitizedValue()] : [k, v]));
    }

    class DataSanitizer {
        constructor(fields) {
            this.keysToSanitize = {
                ['authorization']: '',
                ['access_token']: '',
                ['refresh_token']: '',
                ['subject_token']: '',
                ['token']: '',
                ['client_id']: '',
                ['client_secret']: '',
                ['shared_link']: '',
                ['download_url']: '',
                ['jwt_private_key']: '',
                ['jwt_private_key_passphrase']: '',
                ['password']: '',
            };
        }
        /**
           * @param {{
              readonly [key: string]: string;
          }} headers
           * @returns {{
              readonly [key: string]: string;
          }}
           */
        sanitizeHeaders(headers) {
            return sanitizeMap(headers, this.keysToSanitize);
        }
        /**
         * @param {SerializedData} body
         * @returns {SerializedData}
         */
        sanitizeBody(body) {
            return sanitizeSerializedData(body, this.keysToSanitize);
        }
    }

    class BoxSdkError extends GeneratedCodeError {
        constructor(fields) {
            super(fields);
            this.name = 'BoxSdkError';
            Object.setPrototypeOf(this, BoxSdkError.prototype);
        }
    }
    class BoxApiError extends BoxSdkError {
        constructor(fields) {
            super(fields);
            this.dataSanitizer = new DataSanitizer({});
            this.name = 'BoxApiError';
            if (fields.dataSanitizer) {
                this.dataSanitizer = fields.dataSanitizer;
            }
            Object.setPrototypeOf(this, BoxApiError.prototype);
        }
        [utilLib.inspect.custom]() {
            return this.toString();
        }
        toString() {
            return JSON.stringify(this.toJSON(), null, 2);
        }
        toJSON() {
            return {
                name: this.name,
                message: this.message,
                timestamp: this.timestamp,
                error: this.error,
                requestInfo: {
                    method: this.requestInfo.method,
                    url: this.requestInfo.url,
                    queryParams: this.requestInfo.queryParams,
                    headers: this.dataSanitizer.sanitizeHeaders(this.requestInfo.headers),
                    body: this.requestInfo.body,
                },
                responseInfo: {
                    statusCode: this.responseInfo.statusCode,
                    headers: this.dataSanitizer.sanitizeHeaders(this.responseInfo.headers),
                    body: this.dataSanitizer.sanitizeBody(this.responseInfo.body),
                    code: this.responseInfo.code,
                    contextInfo: this.responseInfo.contextInfo,
                    requestId: this.responseInfo.requestId,
                    helpUrl: this.responseInfo.helpUrl,
                },
            };
        }
    }

    class BaseUrls {
        constructor(fields) {
            this.baseUrl = 'https://api.box.com';
            this.uploadUrl = 'https://upload.box.com/api';
            this.oauth2Url = 'https://account.box.com/api/oauth2';
            if (fields.baseUrl !== undefined) {
                this.baseUrl = fields.baseUrl;
            }
            if (fields.uploadUrl !== undefined) {
                this.uploadUrl = fields.uploadUrl;
            }
            if (fields.oauth2Url !== undefined) {
                this.oauth2Url = fields.oauth2Url;
            }
            if (fields.rawData !== undefined) {
                this.rawData = fields.rawData;
            }
        }
    }

    var browser = {exports: {}};

    (function (module, exports) {

    	// ref: https://github.com/tc39/proposal-global
    	var getGlobal = function () {
    		// the only reliable means to get the global object is
    		// `Function('return this')()`
    		// However, this causes CSP violations in Chrome apps.
    		if (typeof self !== 'undefined') { return self; }
    		if (typeof window !== 'undefined') { return window; }
    		if (typeof commonjsGlobal !== 'undefined') { return commonjsGlobal; }
    		throw new Error('unable to locate global object');
    	};

    	var globalObject = getGlobal();

    	module.exports = exports = globalObject.fetch;

    	// Needed for TypeScript and Webpack.
    	if (globalObject.fetch) {
    		exports.default = globalObject.fetch.bind(globalObject);
    	}

    	exports.Headers = globalObject.Headers;
    	exports.Request = globalObject.Request;
    	exports.Response = globalObject.Response; 
    } (browser, browser.exports));

    var browserExports = browser.exports;
    var nodeFetch = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

    const sdkVersion = '1.17.0';

    class BoxRetryStrategy {
        constructor(fields) {
            this.maxAttempts = 5;
            this.retryRandomizationFactor = 0.5;
            this.retryBaseInterval = 1;
            this.maxRetriesOnException = 2;
            if (fields.maxAttempts !== undefined) {
                this.maxAttempts = fields.maxAttempts;
            }
            if (fields.retryRandomizationFactor !== undefined) {
                this.retryRandomizationFactor = fields.retryRandomizationFactor;
            }
            if (fields.retryBaseInterval !== undefined) {
                this.retryBaseInterval = fields.retryBaseInterval;
            }
            if (fields.maxRetriesOnException !== undefined) {
                this.maxRetriesOnException = fields.maxRetriesOnException;
            }
        }
        /**
         * @param {FetchOptions} fetchOptions
         * @param {FetchResponse} fetchResponse
         * @param {number} attemptNumber
         * @returns {Promise<boolean>}
         */
        shouldRetry(fetchOptions, fetchResponse, attemptNumber) {
            return __awaiter$1(this, void 0, void 0, function* () {
                if (fetchResponse.status == 0) {
                    return attemptNumber <= this.maxRetriesOnException;
                }
                const isSuccessful = fetchResponse.status >= 200 && fetchResponse.status < 400;
                const retryAfterHeader = fetchResponse.headers['Retry-After'];
                const isAcceptedWithRetryAfter = fetchResponse.status == 202 && !(retryAfterHeader == void 0);
                if (attemptNumber >= this.maxAttempts) {
                    return false;
                }
                if (isAcceptedWithRetryAfter) {
                    return true;
                }
                if (fetchResponse.status >= 500) {
                    return true;
                }
                if (fetchResponse.status == 429) {
                    return true;
                }
                if (fetchResponse.status == 401 && !(fetchOptions.auth == void 0)) {
                    yield fetchOptions.auth.refreshToken(fetchOptions.networkSession);
                    return true;
                }
                if (isSuccessful) {
                    return false;
                }
                return false;
            });
        }
        /**
         * @param {FetchOptions} fetchOptions
         * @param {FetchResponse} fetchResponse
         * @param {number} attemptNumber
         * @returns {number}
         */
        retryAfter(fetchOptions, fetchResponse, attemptNumber) {
            const retryAfterHeader = fetchResponse.headers['Retry-After'];
            if (!(retryAfterHeader == void 0)) {
                return parseFloat(retryAfterHeader);
            }
            const randomization = random(1 - this.retryRandomizationFactor, 1 + this.retryRandomizationFactor);
            const exponential = Math.pow(2, attemptNumber);
            return exponential * this.retryBaseInterval * randomization;
        }
    }

    const userAgentHeader = `Box JavaScript generated SDK v${sdkVersion} (${isBrowser() ? navigator.userAgent : `Node ${process.version}`})`;
    const xBoxUaHeader = constructBoxUAHeader();
    const shouldIncludeBoxUaHeader = (options) => {
        return !(isBrowser() &&
            (options.responseFormat === 'binary' ||
                options.responseFormat === 'no_content'));
    };
    function createRequestInit(options) {
        return __awaiter$1(this, void 0, void 0, function* () {
            var _a, _b;
            const { method = 'GET', headers = {}, contentType: contentTypeInput = 'application/json', data, fileStream, } = options;
            const { contentHeaders = {}, body } = yield (() => __awaiter$1(this, void 0, void 0, function* () {
                var _a, _b;
                const contentHeaders = {};
                if (options.multipartData) {
                    const FormDataClass = isBrowser() ? window.FormData : FormData;
                    const formData = new FormDataClass();
                    for (const item of options.multipartData) {
                        if (item.fileStream) {
                            const buffer = yield readByteStream(item.fileStream);
                            const blob = isBrowser()
                                ? new Blob([new Uint8Array(buffer)])
                                : buffer;
                            contentHeaders['content-md5'] = yield calculateMD5Hash(buffer);
                            formData.append(item.partName, blob, {
                                filename: (_a = item.fileName) !== null && _a !== void 0 ? _a : 'file',
                                contentType: (_b = item.contentType) !== null && _b !== void 0 ? _b : 'application/octet-stream',
                            });
                        }
                        else if (item.data) {
                            formData.append(item.partName, sdToJson(item.data));
                        }
                        else {
                            throw new BoxSdkError({
                                message: 'Multipart item must have either body or fileStream',
                            });
                        }
                    }
                    return {
                        contentHeaders: Object.assign(Object.assign({}, (!isBrowser() && {
                            'Content-Type': `multipart/form-data; boundary=${formData.getBoundary()}`,
                        })), contentHeaders),
                        body: formData,
                    };
                }
                contentHeaders['Content-Type'] = contentTypeInput;
                switch (contentTypeInput) {
                    case 'application/json':
                    case 'application/json-patch+json':
                        return { contentHeaders, body: sdToJson(data) };
                    case 'application/x-www-form-urlencoded':
                        return { contentHeaders, body: sdToUrlParams(data) };
                    case 'application/octet-stream':
                        if (!fileStream) {
                            throw new BoxSdkError({
                                message: 'fileStream required for application/octet-stream content type',
                            });
                        }
                        return {
                            contentHeaders,
                            body: isBrowser()
                                ? yield readByteStream(fileStream)
                                : fileStream,
                        };
                    default:
                        throw new BoxSdkError({
                            message: `Unsupported content type : ${contentTypeInput}`,
                        });
                }
            }))();
            return Object.assign({ method, headers: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (method != 'GET' && contentHeaders)), headers), (options.auth && {
                    Authorization: yield options.auth.retrieveAuthorizationHeader(options.networkSession),
                })), (shouldIncludeBoxUaHeader(options) && {
                    'User-Agent': userAgentHeader,
                    'X-Box-UA': xBoxUaHeader,
                })), (_a = options.networkSession) === null || _a === void 0 ? void 0 : _a.additionalHeaders), body: body, signal: options.cancellationToken, agent: (_b = options.networkSession) === null || _b === void 0 ? void 0 : _b.agent }, (fileStream && isBrowser() && { duplex: 'half' }));
        });
    }
    class BoxNetworkClient {
        constructor(fields) {
            Object.assign(this, fields);
        }
        fetch(options) {
            return __awaiter$1(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                const attemptNumber = (_a = options.attemptNumber) !== null && _a !== void 0 ? _a : 1;
                let numberOfRetriesOnException = (_b = options.numberOfRetriesOnException) !== null && _b !== void 0 ? _b : 0;
                const interceptors = (_d = (_c = options.networkSession) === null || _c === void 0 ? void 0 : _c.interceptors) !== null && _d !== void 0 ? _d : [];
                const retryStrategy = (_f = (_e = options.networkSession) === null || _e === void 0 ? void 0 : _e.retryStrategy) !== null && _f !== void 0 ? _f : new BoxRetryStrategy({});
                const dataSanitizer = (_h = (_g = options.networkSession) === null || _g === void 0 ? void 0 : _g.dataSanitizer) !== null && _h !== void 0 ? _h : new DataSanitizer({});
                const fetchOptions = interceptors.length
                    ? interceptors.reduce((modifiedOptions, interceptor) => interceptor.beforeRequest(modifiedOptions), options)
                    : options;
                const fileStreamBuffer = fetchOptions.fileStream
                    ? yield readByteStream(fetchOptions.fileStream)
                    : void 0;
                const multipartBuffer = fetchOptions.multipartData
                    ? yield multipartStreamToBuffer(fetchOptions.multipartData)
                    : void 0;
                let isExceptionCase = false;
                let fetchResponse;
                let responseBytesBuffer;
                const { params = {} } = fetchOptions;
                const requestInit = yield createRequestInit(Object.assign(Object.assign({}, fetchOptions), { fileStream: fileStreamBuffer
                        ? generateByteStreamFromBuffer(fileStreamBuffer)
                        : void 0, multipartData: multipartBuffer
                        ? multipartBufferToStream(multipartBuffer)
                        : void 0 }));
                try {
                    const response = yield nodeFetch(''.concat(fetchOptions.url, Object.keys(params).length === 0 || fetchOptions.url.endsWith('?')
                        ? ''
                        : '?', new URLSearchParams(params).toString()), Object.assign(Object.assign({}, requestInit), { redirect: isBrowser() ? 'follow' : 'manual' }));
                    const contentType = (_j = response.headers.get('content-type')) !== null && _j !== void 0 ? _j : '';
                    const ignoreResponseBody = fetchOptions.followRedirects === false;
                    let data;
                    let content = generateByteStreamFromBuffer(new Uint8Array().buffer);
                    if (!ignoreResponseBody) {
                        if (options.responseFormat === 'binary') {
                            content = response.body;
                            responseBytesBuffer = new Uint8Array();
                        }
                        else if (options.responseFormat === 'json') {
                            responseBytesBuffer = yield response.arrayBuffer();
                            const text = new TextDecoder().decode(responseBytesBuffer);
                            if (contentType.includes('application/json')) {
                                data = jsonToSerializedData(text);
                            }
                            content = generateByteStreamFromBuffer(responseBytesBuffer);
                        }
                    }
                    fetchResponse = {
                        url: response.url,
                        status: response.status,
                        data,
                        content,
                        headers: Object.fromEntries(Array.from(response.headers.entries())),
                    };
                    if (interceptors.length) {
                        fetchResponse = interceptors.reduce((modifiedResponse, interceptor) => interceptor.afterRequest(modifiedResponse), fetchResponse);
                    }
                }
                catch (error) {
                    isExceptionCase = true;
                    numberOfRetriesOnException++;
                    fetchResponse = {
                        status: 0,
                        headers: {},
                    };
                }
                const attemptForRetry = isExceptionCase
                    ? numberOfRetriesOnException
                    : attemptNumber;
                const shouldRetry = yield retryStrategy.shouldRetry(fetchOptions, fetchResponse, attemptForRetry);
                if (shouldRetry) {
                    const retryTimeout = retryStrategy.retryAfter(fetchOptions, fetchResponse, attemptForRetry);
                    yield new Promise((resolve) => setTimeout(resolve, retryTimeout));
                    return this.fetch(Object.assign(Object.assign({}, options), { attemptNumber: attemptNumber + 1, numberOfRetriesOnException: numberOfRetriesOnException, fileStream: fileStreamBuffer
                            ? generateByteStreamFromBuffer(fileStreamBuffer)
                            : void 0, multipartData: multipartBuffer
                            ? multipartBufferToStream(multipartBuffer)
                            : void 0 }));
                }
                if (fetchResponse.status >= 300 &&
                    fetchResponse.status < 400 &&
                    fetchOptions.followRedirects !== false) {
                    if (!fetchResponse.headers['location']) {
                        throw new BoxSdkError({
                            message: `Unable to follow redirect for ${fetchOptions.url}`,
                        });
                    }
                    const sameOrigin = new URL(fetchResponse.headers['location']).origin ===
                        new URL(fetchOptions.url).origin;
                    return this.fetch(Object.assign(Object.assign({}, options), { params: undefined, auth: sameOrigin ? fetchOptions.auth : undefined, url: fetchResponse.headers['location'] }));
                }
                if (fetchResponse.status >= 200 && fetchResponse.status < 400) {
                    return fetchResponse;
                }
                const [code, contextInfo, requestId, helpUrl, message] = sdIsMap(fetchResponse.data)
                    ? [
                        sdToJson(fetchResponse.data['code']),
                        sdIsMap(fetchResponse.data['context_info'])
                            ? fetchResponse.data['context_info']
                            : undefined,
                        sdToJson(fetchResponse.data['request_id']),
                        sdToJson(fetchResponse.data['help_url']),
                        sdToJson(fetchResponse.data['message']),
                    ]
                    : [];
                throw new BoxApiError({
                    message: `${fetchResponse.status} ${message}; Request ID: ${requestId}`,
                    timestamp: `${Date.now()}`,
                    requestInfo: {
                        method: requestInit.method,
                        url: fetchOptions.url,
                        queryParams: params,
                        headers: (_k = requestInit.headers) !== null && _k !== void 0 ? _k : {},
                        body: typeof requestInit.body === 'string' ? requestInit.body : undefined,
                    },
                    responseInfo: {
                        statusCode: fetchResponse.status,
                        headers: fetchResponse.headers,
                        body: fetchResponse.data,
                        rawBody: new TextDecoder().decode(responseBytesBuffer),
                        code: code,
                        contextInfo: contextInfo,
                        requestId: requestId,
                        helpUrl: helpUrl,
                    },
                    dataSanitizer: dataSanitizer,
                });
            });
        }
    }
    function constructBoxUAHeader() {
        const analyticsIdentifiers = {
            agent: `box-javascript-generated-sdk/${sdkVersion}`,
            env: isBrowser()
                ? navigator.userAgent
                : `Node/${process.version.replace('v', '')}`,
        };
        return Object.keys(analyticsIdentifiers)
            .map((k) => `${k}=${analyticsIdentifiers[k]}`)
            .join('; ');
    }

    class NetworkSession {
        constructor(fields) {
            this.additionalHeaders = {};
            this.baseUrls = new BaseUrls({});
            this.interceptors = [];
            this.agent = createAgent();
            this.networkClient = new BoxNetworkClient({});
            this.retryStrategy = new BoxRetryStrategy({});
            this.dataSanitizer = new DataSanitizer({});
            if (fields.additionalHeaders !== undefined) {
                this.additionalHeaders = fields.additionalHeaders;
            }
            if (fields.baseUrls !== undefined) {
                this.baseUrls = fields.baseUrls;
            }
            if (fields.interceptors !== undefined) {
                this.interceptors = fields.interceptors;
            }
            if (fields.agent !== undefined) {
                this.agent = fields.agent;
            }
            if (fields.agentOptions !== undefined) {
                this.agentOptions = fields.agentOptions;
            }
            if (fields.proxyConfig !== undefined) {
                this.proxyConfig = fields.proxyConfig;
            }
            if (fields.networkClient !== undefined) {
                this.networkClient = fields.networkClient;
            }
            if (fields.retryStrategy !== undefined) {
                this.retryStrategy = fields.retryStrategy;
            }
            if (fields.dataSanitizer !== undefined) {
                this.dataSanitizer = fields.dataSanitizer;
            }
        }
        /**
           * Generate a fresh network session by duplicating the existing configuration and network parameters, while also including additional headers to be attached to every API call.
           * @param {{
              readonly [key: string]: string;
          }} additionalHeaders Headers, which are appended to each API request
           * @returns {NetworkSession}
           */
        withAdditionalHeaders(additionalHeaders = {}) {
            return new NetworkSession({
                additionalHeaders: Object.assign(Object.assign({}, this.additionalHeaders), additionalHeaders),
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: this.agent,
                agentOptions: this.agentOptions,
                proxyConfig: this.proxyConfig,
                networkClient: this.networkClient,
                retryStrategy: this.retryStrategy,
                dataSanitizer: this.dataSanitizer,
            });
        }
        /**
         * Generate a fresh network session by duplicating the existing configuration and network parameters, while also including custom base urls to be used for every API call.
         * @param {BaseUrls} baseUrls Custom base urls
         * @returns {NetworkSession}
         */
        withCustomBaseUrls(baseUrls) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: baseUrls,
                interceptors: this.interceptors,
                agent: this.agent,
                agentOptions: this.agentOptions,
                proxyConfig: this.proxyConfig,
                networkClient: this.networkClient,
                retryStrategy: this.retryStrategy,
                dataSanitizer: this.dataSanitizer,
            });
        }
        /**
         * Generate a fresh network session by duplicating the existing configuration and network parameters, while also including custom agent options to be used for every API call.
         * @param {AgentOptions} agentOptions Custom agent options
         * @returns {NetworkSession}
         */
        withCustomAgentOptions(agentOptions) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: createAgent(agentOptions, this.proxyConfig),
                agentOptions: this.agentOptions,
                proxyConfig: this.proxyConfig,
                networkClient: this.networkClient,
                retryStrategy: this.retryStrategy,
                dataSanitizer: this.dataSanitizer,
            });
        }
        /**
         * Generate a fresh network session by duplicating the existing configuration and network parameters, while also additional including custom interceptors.
         * @param {readonly Interceptor[]} interceptors Custom base urls
         * @returns {NetworkSession}
         */
        withInterceptors(interceptors) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors.concat(interceptors),
                agent: this.agent,
                agentOptions: this.agentOptions,
                proxyConfig: this.proxyConfig,
                networkClient: this.networkClient,
                retryStrategy: this.retryStrategy,
                dataSanitizer: this.dataSanitizer,
            });
        }
        /**
         * Generate a fresh network session by duplicating the existing configuration and network parameters, while also including a custom proxy configuration.
         * @param {ProxyConfig} proxyConfig
         * @returns {NetworkSession}
         */
        withProxy(proxyConfig) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: createAgent(this.agentOptions),
                agentOptions: this.agentOptions,
                proxyConfig: proxyConfig,
                networkClient: this.networkClient,
                retryStrategy: this.retryStrategy,
                dataSanitizer: this.dataSanitizer,
            });
        }
        /**
         * Generate a fresh network session by duplicating the existing configuration and network parameters, while also including a custom network client.
         * @param {NetworkClient} networkClient
         * @returns {NetworkSession}
         */
        withNetworkClient(networkClient) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: this.agent,
                agentOptions: this.agentOptions,
                proxyConfig: this.proxyConfig,
                networkClient: networkClient,
                retryStrategy: this.retryStrategy,
                dataSanitizer: this.dataSanitizer,
            });
        }
        /**
         * Generate a fresh network session by duplicating the existing configuration and network parameters, while also applying retry strategy
         * @param {RetryStrategy} retryStrategy
         * @returns {NetworkSession}
         */
        withRetryStrategy(retryStrategy) {
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: this.agent,
                agentOptions: this.agentOptions,
                proxyConfig: this.proxyConfig,
                networkClient: this.networkClient,
                retryStrategy: retryStrategy,
                dataSanitizer: this.dataSanitizer,
            });
        }
        /**
         * Generate a fresh network session by duplicating the existing configuration and network parameters, while also applying data sanitizer
         * @param {DataSanitizerInput} dataSanitizerInput
         * @returns {NetworkSession}
         */
        withDataSanitizer(dataSanitizerInput) {
            const dataSanitizer = new DataSanitizer({});
            return new NetworkSession({
                additionalHeaders: this.additionalHeaders,
                baseUrls: this.baseUrls,
                interceptors: this.interceptors,
                agent: this.agent,
                agentOptions: this.agentOptions,
                proxyConfig: this.proxyConfig,
                networkClient: this.networkClient,
                retryStrategy: this.retryStrategy,
                dataSanitizer: dataSanitizer,
            });
        }
    }

    class InMemoryTokenStorage {
        constructor(fields) {
            this.token = void 0;
            if (fields.token !== undefined) {
                this.token = fields.token;
            }
        }
        /**
         * @param {AccessToken} token
         * @returns {Promise<undefined>}
         */
        store(token) {
            return __awaiter$1(this, void 0, void 0, function* () {
                this.token = token;
                return void 0;
            });
        }
        /**
         * @returns {Promise<undefined | AccessToken>}
         */
        get() {
            return __awaiter$1(this, void 0, void 0, function* () {
                return this.token;
            });
        }
        /**
         * @returns {Promise<undefined>}
         */
        clear() {
            return __awaiter$1(this, void 0, void 0, function* () {
                this.token = void 0;
                return void 0;
            });
        }
    }

    function serializeFileBaseTypeField(val) {
        return val;
    }
    function deserializeFileBaseTypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileBaseTypeField" });
    }
    function serializeFileBase(val) {
        return {
            ['id']: val.id,
            ['etag']: val.etag,
            ['type']: serializeFileBaseTypeField(val.type),
        };
    }
    function deserializeFileBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileBase"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileBase"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileBase"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileBase" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return { id: id, etag: etag, type: type };
    }

    function deserializeFileVersionBaseTypeField(val) {
        if (val == 'file_version') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionBaseTypeField",
        });
    }

    function deserializeFileVersionMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileVersionMini"' });
        }
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileVersionMini"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileVersionMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileVersionMini" to be defined',
            });
        }
        const type = deserializeFileVersionBaseTypeField(val.type);
        return { sha1: sha1, id: id, type: type };
    }

    function deserializeFileMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileMini"' });
        }
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FileMini"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileMini"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileMini"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileMini"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileMini" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return {
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function serializeFolderBaseTypeField(val) {
        return val;
    }
    function deserializeFolderBaseTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FolderBaseTypeField" });
    }
    function serializeFolderBase(val) {
        return {
            ['id']: val.id,
            ['etag']: val.etag,
            ['type']: serializeFolderBaseTypeField(val.type),
        };
    }
    function deserializeFolderBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderBase"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FolderBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderBase"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FolderBase"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FolderBase" to be defined',
            });
        }
        const type = deserializeFolderBaseTypeField(val.type);
        return { id: id, etag: etag, type: type };
    }

    function serializeFolderMini(val) {
        const base = serializeFolderBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderMini"' });
        }
        return Object.assign(Object.assign({}, base), { ['sequence_id']: val.sequenceId, ['name']: val.name });
    }
    function deserializeFolderMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderMini"' });
        }
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FolderMini"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FolderMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FolderMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderMini"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FolderMini"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FolderMini" to be defined',
            });
        }
        const type = deserializeFolderBaseTypeField(val.type);
        return {
            sequenceId: sequenceId,
            name: name,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function deserializeFileMiniOrFolderMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileMiniOrFolderMini"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileMini(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderMini(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize FileMiniOrFolderMini" });
    }

    function deserializeFileOrFolderScopeScopeField(val) {
        if (val == 'annotation_edit') {
            return val;
        }
        if (val == 'annotation_view_all') {
            return val;
        }
        if (val == 'annotation_view_self') {
            return val;
        }
        if (val == 'base_explorer') {
            return val;
        }
        if (val == 'base_picker') {
            return val;
        }
        if (val == 'base_preview') {
            return val;
        }
        if (val == 'base_upload') {
            return val;
        }
        if (val == 'item_delete') {
            return val;
        }
        if (val == 'item_download') {
            return val;
        }
        if (val == 'item_preview') {
            return val;
        }
        if (val == 'item_rename') {
            return val;
        }
        if (val == 'item_share') {
            return val;
        }
        if (val == 'item_upload') {
            return val;
        }
        if (val == 'item_read') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileOrFolderScopeScopeField",
        });
    }
    function deserializeFileOrFolderScope(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileOrFolderScope"',
            });
        }
        const scope = val.scope == void 0
            ? void 0
            : deserializeFileOrFolderScopeScopeField(val.scope);
        const object = val.object == void 0 ? void 0 : deserializeFileMiniOrFolderMini(val.object);
        return { scope: scope, object: object };
    }

    function deserializeAccessTokenTokenTypeField(val) {
        if (val == 'bearer') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AccessTokenTokenTypeField",
        });
    }
    function deserializeAccessTokenIssuedTokenTypeField(val) {
        if (val == 'urn:ietf:params:oauth:token-type:access_token') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AccessTokenIssuedTokenTypeField",
        });
    }
    function deserializeAccessToken(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AccessToken"' });
        }
        if (!(val.access_token == void 0) && !sdIsString(val.access_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_token" of type "AccessToken"',
            });
        }
        const accessToken = val.access_token == void 0 ? void 0 : val.access_token;
        if (!(val.expires_in == void 0) && !sdIsNumber(val.expires_in)) {
            throw new BoxSdkError({
                message: 'Expecting number for "expires_in" of type "AccessToken"',
            });
        }
        const expiresIn = val.expires_in == void 0 ? void 0 : val.expires_in;
        const tokenType = val.token_type == void 0
            ? void 0
            : deserializeAccessTokenTokenTypeField(val.token_type);
        if (!(val.restricted_to == void 0) && !sdIsList(val.restricted_to)) {
            throw new BoxSdkError({
                message: 'Expecting array for "restricted_to" of type "AccessToken"',
            });
        }
        const restrictedTo = val.restricted_to == void 0
            ? void 0
            : sdIsList(val.restricted_to)
                ? val.restricted_to.map(function (itm) {
                    return deserializeFileOrFolderScope(itm);
                })
                : [];
        if (!(val.refresh_token == void 0) && !sdIsString(val.refresh_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "refresh_token" of type "AccessToken"',
            });
        }
        const refreshToken = val.refresh_token == void 0 ? void 0 : val.refresh_token;
        const issuedTokenType = val.issued_token_type == void 0
            ? void 0
            : deserializeAccessTokenIssuedTokenTypeField(val.issued_token_type);
        return {
            accessToken: accessToken,
            expiresIn: expiresIn,
            tokenType: tokenType,
            restrictedTo: restrictedTo,
            refreshToken: refreshToken,
            issuedTokenType: issuedTokenType,
        };
    }

    function serializePostOAuth2TokenGrantTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenSubjectTokenTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenActorTokenTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenBoxSubjectTypeField(val) {
        return val;
    }
    function serializePostOAuth2Token(val) {
        return {
            ['grant_type']: serializePostOAuth2TokenGrantTypeField(val.grantType),
            ['client_id']: val.clientId,
            ['client_secret']: val.clientSecret,
            ['code']: val.code,
            ['refresh_token']: val.refreshToken,
            ['assertion']: val.assertion,
            ['subject_token']: val.subjectToken,
            ['subject_token_type']: val.subjectTokenType == void 0
                ? val.subjectTokenType
                : serializePostOAuth2TokenSubjectTokenTypeField(val.subjectTokenType),
            ['actor_token']: val.actorToken,
            ['actor_token_type']: val.actorTokenType == void 0
                ? val.actorTokenType
                : serializePostOAuth2TokenActorTokenTypeField(val.actorTokenType),
            ['scope']: val.scope,
            ['resource']: val.resource,
            ['box_subject_type']: val.boxSubjectType == void 0
                ? val.boxSubjectType
                : serializePostOAuth2TokenBoxSubjectTypeField(val.boxSubjectType),
            ['box_subject_id']: val.boxSubjectId,
            ['box_shared_link']: val.boxSharedLink,
        };
    }

    class PostOAuth2TokenRefreshAccessToken {
        constructor(fields) {
            /**
             * The type of request being made, in this case a refresh request. */
            this.grantType = 'refresh_token';
            if (fields.grantType !== undefined) {
                this.grantType = fields.grantType;
            }
            if (fields.clientId !== undefined) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret !== undefined) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.refreshToken !== undefined) {
                this.refreshToken = fields.refreshToken;
            }
            if (fields.rawData !== undefined) {
                this.rawData = fields.rawData;
            }
        }
    }
    function serializePostOAuth2TokenRefreshAccessTokenGrantTypeField(val) {
        return val;
    }
    function serializePostOAuth2TokenRefreshAccessToken(val) {
        return {
            ['grant_type']: serializePostOAuth2TokenRefreshAccessTokenGrantTypeField(val.grantType),
            ['client_id']: val.clientId,
            ['client_secret']: val.clientSecret,
            ['refresh_token']: val.refreshToken,
        };
    }

    function serializePostOAuth2Revoke(val) {
        return {
            ['client_id']: val.clientId,
            ['client_secret']: val.clientSecret,
            ['token']: val.token,
        };
    }

    class FetchOptions {
        constructor(fields) {
            /**
             * Content type of the request body */
            this.contentType = 'application/json';
            /**
             * Expected response format */
            this.responseFormat = 'json';
            /**
             * A boolean value indicate if the request should follow redirects. Defaults to True. Not supported in Browser environment. */
            this.followRedirects = true;
            if (fields.url !== undefined) {
                this.url = fields.url;
            }
            if (fields.method !== undefined) {
                this.method = fields.method;
            }
            if (fields.params !== undefined) {
                this.params = fields.params;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.data !== undefined) {
                this.data = fields.data;
            }
            if (fields.fileStream !== undefined) {
                this.fileStream = fields.fileStream;
            }
            if (fields.multipartData !== undefined) {
                this.multipartData = fields.multipartData;
            }
            if (fields.contentType !== undefined) {
                this.contentType = fields.contentType;
            }
            if (fields.responseFormat !== undefined) {
                this.responseFormat = fields.responseFormat;
            }
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
            if (fields.followRedirects !== undefined) {
                this.followRedirects = fields.followRedirects;
            }
        }
    }

    class AuthorizeUserOptionals {
        constructor(fields) {
            this.headers = new AuthorizeUserHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RequestAccessTokenOptionals {
        constructor(fields) {
            this.headers = new RequestAccessTokenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RefreshAccessTokenOptionals {
        constructor(fields) {
            this.headers = new RefreshAccessTokenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RevokeAccessTokenOptionals {
        constructor(fields) {
            this.headers = new RevokeAccessTokenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AuthorizeUserHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RequestAccessTokenHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RefreshAccessTokenHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RevokeAccessTokenHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AuthorizationManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Authorize a user by sending them through the [Box](https://box.com)
         * website and request their permission to act on their behalf.
         *
         * This is the first step when authenticating a user using
         * OAuth 2.0. To request a user's authorization to use the Box APIs
         * on their behalf you will need to send a user to the URL with this
         * format.
         * @param {AuthorizeUserQueryParams} queryParams Query parameters of authorizeUser method
         * @param {AuthorizeUserOptionalsInput} optionalsInput
         * @returns {Promise<undefined>}
         */
        authorizeUser(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new AuthorizeUserOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['response_type']: toString(queryParams.responseType),
                    ['client_id']: toString(queryParams.clientId),
                    ['redirect_uri']: toString(queryParams.redirectUri),
                    ['state']: toString(queryParams.state),
                    ['scope']: toString(queryParams.scope),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.oauth2Url, '/authorize'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
         * Request an Access Token using either a client-side obtained OAuth 2.0
         * authorization code or a server-side JWT assertion.
         *
         * An Access Token is a string that enables Box to verify that a
         * request belongs to an authorized session. In the normal order of
         * operations you will begin by requesting authentication from the
         * [authorize](#get-authorize) endpoint and Box will send you an
         * authorization code.
         *
         * You will then send this code to this endpoint to exchange it for
         * an Access Token. The returned Access Token can then be used to to make
         * Box API calls.
         * @param {PostOAuth2Token} requestBody Request body of requestAccessToken method
         * @param {RequestAccessTokenOptionalsInput} optionalsInput
         * @returns {Promise<AccessToken>}
         */
        requestAccessToken(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new RequestAccessTokenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/oauth2/token'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializePostOAuth2Token(requestBody),
                    contentType: 'application/x-www-form-urlencoded',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAccessToken(response.data)), { rawData: response.data });
            });
        }
        /**
         * Refresh an Access Token using its client ID, secret, and refresh token.
         * @param {PostOAuth2TokenRefreshAccessTokenInput} requestBodyInput Request body of refreshAccessToken method
         * @param {RefreshAccessTokenOptionalsInput} optionalsInput
         * @returns {Promise<AccessToken>}
         */
        refreshAccessToken(requestBodyInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBodyInput, optionalsInput = {}) {
                const requestBody = new PostOAuth2TokenRefreshAccessToken({
                    grantType: requestBodyInput.grantType,
                    clientId: requestBodyInput.clientId,
                    clientSecret: requestBodyInput.clientSecret,
                    refreshToken: requestBodyInput.refreshToken,
                });
                const optionals = new RefreshAccessTokenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/oauth2/token#refresh'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializePostOAuth2TokenRefreshAccessToken(requestBody),
                    contentType: 'application/x-www-form-urlencoded',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAccessToken(response.data)), { rawData: response.data });
            });
        }
        /**
         * Revoke an active Access Token, effectively logging a user out
         * that has been previously authenticated.
         * @param {PostOAuth2Revoke} requestBody Request body of revokeAccessToken method
         * @param {RevokeAccessTokenOptionalsInput} optionalsInput
         * @returns {Promise<undefined>}
         */
        revokeAccessToken(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new RevokeAccessTokenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/oauth2/revoke'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializePostOAuth2Revoke(requestBody),
                    contentType: 'application/x-www-form-urlencoded',
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }

    class CcgConfig {
        constructor(fields) {
            /**
             * Object responsible for storing token. If no custom implementation provided,the token will be stored in memory. */
            this.tokenStorage = new InMemoryTokenStorage({});
            if (fields.clientId !== undefined) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret !== undefined) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.enterpriseId !== undefined) {
                this.enterpriseId = fields.enterpriseId;
            }
            if (fields.userId !== undefined) {
                this.userId = fields.userId;
            }
            if (fields.tokenStorage !== undefined) {
                this.tokenStorage = fields.tokenStorage;
            }
        }
    }
    class BoxCcgAuth {
        constructor(fields) {
            if (fields.config !== undefined) {
                this.config = fields.config;
            }
            this.tokenStorage = this.config.tokenStorage;
            this.subjectId = !(this.config.userId == void 0)
                ? this.config.userId
                : this.config.enterpriseId;
            this.subjectType = !(this.config.userId == void 0)
                ? 'user'
                : 'enterprise';
        }
        /**
         * Get a new access token using CCG auth
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        refreshToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'client_credentials',
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    boxSubjectType: this.subjectType,
                    boxSubjectId: this.subjectId,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        /**
         * Return a current token or get a new one when not available.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        retrieveToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    const newToken = yield this.refreshToken(networkSession);
                    return newToken;
                }
                return oldToken;
            });
        }
        /**
         * @param {NetworkSession} networkSession
         * @returns {Promise<string>}
         */
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        /**
         * Create a new BoxCCGAuth instance that uses the provided user ID as the subject ID.
         * May be one of this application's created App User. Depending on the configured User Access Level, may also be any other App User or Managed User in the enterprise.
         * <https://developer.box.com/en/guides/applications/>
         * <https://developer.box.com/en/guides/authentication/select/>
         * @param {string} userId The id of the user to authenticate
         * @param {TokenStorage} tokenStorage Object responsible for storing token in newly created BoxCCGAuth. If no custom implementation provided, the token will be stored in memory.
         * @returns {BoxCcgAuth}
         */
        withUserSubject(userId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new CcgConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: this.config.enterpriseId,
                userId: userId,
                tokenStorage: tokenStorage,
            });
            return new BoxCcgAuth({ config: newConfig });
        }
        /**
         * Create a new BoxCCGAuth instance that uses the provided enterprise ID as the subject ID.
         * @param {string} enterpriseId The id of the enterprise to authenticate
         * @param {TokenStorage} tokenStorage Object responsible for storing token in newly created BoxCCGAuth. If no custom implementation provided, the token will be stored in memory.
         * @returns {BoxCcgAuth}
         */
        withEnterpriseSubject(enterpriseId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new CcgConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: enterpriseId,
                userId: void 0,
                tokenStorage: tokenStorage,
            });
            return new BoxCcgAuth({ config: newConfig });
        }
        /**
         * Downscope access token to the provided scopes. Returning a new access token with the provided scopes, with the original access token unchanged.
         * @param {readonly string[]} scopes The scope(s) to apply to the resulting token.
         * @param {string} resource The file or folder to get a downscoped token for. If None and shared_link None, the resulting token will not be scoped down to just a single item. The resource should be a full URL to an item, e.g. https://api.box.com/2.0/files/123456.
         * @param {string} sharedLink The shared link to get a downscoped token for. If None and item None, the resulting token will not be scoped down to just a single item.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                if (token == void 0) {
                    throw new BoxSdkError({
                        message: 'No access token is available. Make an API call to retrieve a token before calling this method.',
                    });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    scope: scopes.join(' '),
                    resource: resource,
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
        /**
         * Revoke the current access token and remove it from token storage.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<undefined>}
         */
        revokeToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    token: oldToken.accessToken,
                });
                yield this.tokenStorage.clear();
                return void 0;
            });
        }
    }

    class BoxDeveloperTokenAuth {
        constructor(fields) {
            /**
             * Configuration object of DeveloperTokenAuth. */
            this.config = {};
            if (fields.token !== undefined) {
                this.token = fields.token;
            }
            if (fields.config !== undefined) {
                this.config = fields.config;
            }
            this.tokenStorage = new InMemoryTokenStorage({
                token: { accessToken: this.token },
            });
        }
        /**
         * Retrieves stored developer token
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        retrieveToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    throw new BoxSdkError({ message: 'No access token is available.' });
                }
                return token;
            });
        }
        /**
         * Developer token cannot be refreshed
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        refreshToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                throw new BoxSdkError({
                    message: 'Developer token has expired. Please provide a new one.',
                });
            });
        }
        /**
         * @param {NetworkSession} networkSession
         * @returns {Promise<string>}
         */
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        /**
         * Revoke an active Access Token, effectively logging a user out that has been previously authenticated.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<undefined>}
         */
        revokeToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    token: token.accessToken,
                });
                yield this.tokenStorage.clear();
                return void 0;
            });
        }
        /**
         * Downscope access token to the provided scopes. Returning a new access token with the provided scopes, with the original access token unchanged.
         * @param {readonly string[]} scopes The scope(s) to apply to the resulting token.
         * @param {string} resource The file or folder to get a downscoped token for. If None and shared_link None, the resulting token will not be scoped down to just a single item. The resource should be a full URL to an item, e.g. https://api.box.com/2.0/files/123456.
         * @param {string} sharedLink The shared link to get a downscoped token for. If None and item None, the resulting token will not be scoped down to just a single item.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                if (token == void 0 || token.accessToken == void 0) {
                    throw new BoxSdkError({ message: 'No access token is available.' });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    scope: scopes.join(' '),
                    resource: resource,
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
    }

    class JwtConfig {
        constructor(fields) {
            this.algorithm = 'RS256';
            this.tokenStorage = new InMemoryTokenStorage({});
            this.privateKeyDecryptor = new DefaultPrivateKeyDecryptor({});
            if (fields.clientId !== undefined) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret !== undefined) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.jwtKeyId !== undefined) {
                this.jwtKeyId = fields.jwtKeyId;
            }
            if (fields.privateKey !== undefined) {
                this.privateKey = fields.privateKey;
            }
            if (fields.privateKeyPassphrase !== undefined) {
                this.privateKeyPassphrase = fields.privateKeyPassphrase;
            }
            if (fields.enterpriseId !== undefined) {
                this.enterpriseId = fields.enterpriseId;
            }
            if (fields.userId !== undefined) {
                this.userId = fields.userId;
            }
            if (fields.algorithm !== undefined) {
                this.algorithm = fields.algorithm;
            }
            if (fields.tokenStorage !== undefined) {
                this.tokenStorage = fields.tokenStorage;
            }
            if (fields.privateKeyDecryptor !== undefined) {
                this.privateKeyDecryptor = fields.privateKeyDecryptor;
            }
        }
        /**
         * Create an auth instance as defined by a string content of JSON file downloaded from the Box Developer Console.
         * See https://developer.box.com/en/guides/authentication/jwt/ for more information.
         * @param {string} configJsonString String content of JSON file containing the configuration.
         * @param {TokenStorage} tokenStorage Object responsible for storing token. If no custom implementation provided, the token will be stored in memory
         * @param {PrivateKeyDecryptor} privateKeyDecryptor Object responsible for decrypting private key for jwt auth. If no custom implementation provided, the DefaultPrivateKeyDecryptor will be used.
         * @returns {JwtConfig}
         */
        static fromConfigJsonString(configJsonString, tokenStorage, privateKeyDecryptor) {
            const configJson = Object.assign(Object.assign({}, deserializeJwtConfigFile(jsonToSerializedData(configJsonString))), { rawData: jsonToSerializedData(configJsonString) });
            const tokenStorageToUse = tokenStorage == void 0 ? new InMemoryTokenStorage({}) : tokenStorage;
            const privateKeyDecryptorToUse = privateKeyDecryptor == void 0
                ? new DefaultPrivateKeyDecryptor({})
                : privateKeyDecryptor;
            const newConfig = new JwtConfig({
                clientId: configJson.boxAppSettings.clientId,
                clientSecret: configJson.boxAppSettings.clientSecret,
                enterpriseId: configJson.enterpriseId,
                userId: configJson.userId,
                jwtKeyId: configJson.boxAppSettings.appAuth.publicKeyId,
                privateKey: configJson.boxAppSettings.appAuth.privateKey,
                privateKeyPassphrase: configJson.boxAppSettings.appAuth.passphrase,
                tokenStorage: tokenStorageToUse,
                privateKeyDecryptor: privateKeyDecryptorToUse,
            });
            return newConfig;
        }
        /**
         * Create an auth instance as defined by a JSON file downloaded from the Box Developer Console.
         * See https://developer.box.com/en/guides/authentication/jwt/ for more information.
         * @param {string} configFilePath Path to the JSON file containing the configuration.
         * @param {TokenStorage} tokenStorage Object responsible for storing token. If no custom implementation provided, the token will be stored in memory.
         * @param {PrivateKeyDecryptor} privateKeyDecryptor Object responsible for decrypting private key for jwt auth. If no custom implementation provided, the DefaultPrivateKeyDecryptor will be used.
         * @returns {JwtConfig}
         */
        static fromConfigFile(configFilePath, tokenStorage, privateKeyDecryptor) {
            const configJsonString = readTextFromFile();
            return JwtConfig.fromConfigJsonString(configJsonString, tokenStorage, privateKeyDecryptor);
        }
    }
    class BoxJwtAuth {
        constructor(fields) {
            if (fields.config !== undefined) {
                this.config = fields.config;
            }
            this.tokenStorage = this.config.tokenStorage;
            this.subjectId = !(this.config.enterpriseId == void 0)
                ? this.config.enterpriseId
                : this.config.userId;
            this.subjectType = !(this.config.enterpriseId == void 0)
                ? 'enterprise'
                : 'user';
        }
        /**
         * Get new access token using JWT auth.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        refreshToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                if (isBrowser()) {
                    throw new BoxSdkError({
                        message: 'JWT auth is not supported in browser environment.',
                    });
                }
                !(this.config.algorithm == void 0)
                    ? this.config.algorithm
                    : 'RS256';
                ({
                    ['box_sub_type']: this.subjectType,
                });
                ({
                    subject: this.subjectId,
                    issuer: this.config.clientId,
                    jwtid: getUuid(),
                    keyid: this.config.jwtKeyId,
                    privateKeyDecryptor: this.config.privateKeyDecryptor,
                });
                ({
                    key: this.config.privateKey,
                    passphrase: this.config.privateKeyPassphrase,
                });
                const assertion = yield createJwtAssertion();
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                    assertion: assertion,
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        /**
         * Get the current access token. If the current access token is expired or not found, this method will attempt to refresh the token.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        retrieveToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    const newToken = yield this.refreshToken(networkSession);
                    return newToken;
                }
                return oldToken;
            });
        }
        /**
         * @param {NetworkSession} networkSession
         * @returns {Promise<string>}
         */
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        /**
         * Create a new BoxJWTAuth instance that uses the provided user ID as the subject of the JWT assertion.
         * May be one of this application's created App User. Depending on the configured User Access Level, may also be any other App User or Managed User in the enterprise.
         * <https://developer.box.com/en/guides/applications/>
         * <https://developer.box.com/en/guides/authentication/select/>
         * @param {string} userId The id of the user to authenticate
         * @param {TokenStorage} tokenStorage Object responsible for storing token in newly created BoxJWTAuth. If no custom implementation provided, the token will be stored in memory.
         * @returns {BoxJwtAuth}
         */
        withUserSubject(userId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new JwtConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: void 0,
                userId: userId,
                jwtKeyId: this.config.jwtKeyId,
                privateKey: this.config.privateKey,
                privateKeyPassphrase: this.config.privateKeyPassphrase,
                tokenStorage: tokenStorage,
            });
            const newAuth = new BoxJwtAuth({ config: newConfig });
            return newAuth;
        }
        /**
         * Create a new BoxJWTAuth instance that uses the provided enterprise ID as the subject of the JWT assertion.
         * @param {string} enterpriseId The id of the enterprise to authenticate
         * @param {TokenStorage} tokenStorage Object responsible for storing token in newly created BoxJWTAuth. If no custom implementation provided, the token will be stored in memory.
         * @returns {BoxJwtAuth}
         */
        withEnterpriseSubject(enterpriseId, tokenStorage = new InMemoryTokenStorage({})) {
            const newConfig = new JwtConfig({
                clientId: this.config.clientId,
                clientSecret: this.config.clientSecret,
                enterpriseId: enterpriseId,
                userId: void 0,
                jwtKeyId: this.config.jwtKeyId,
                privateKey: this.config.privateKey,
                privateKeyPassphrase: this.config.privateKeyPassphrase,
                tokenStorage: tokenStorage,
            });
            const newAuth = new BoxJwtAuth({ config: newConfig });
            return newAuth;
        }
        /**
         * Downscope access token to the provided scopes. Returning a new access token with the provided scopes, with the original access token unchanged.
         * @param {readonly string[]} scopes The scope(s) to apply to the resulting token.
         * @param {string} resource The file or folder to get a downscoped token for. If None and shared_link None, the resulting token will not be scoped down to just a single item. The resource should be a full URL to an item, e.g. https://api.box.com/2.0/files/123456.
         * @param {string} sharedLink The shared link to get a downscoped token for. If None and item None, the resulting token will not be scoped down to just a single item.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                if (token == void 0) {
                    throw new BoxSdkError({
                        message: 'No access token is available. Make an API call to retrieve a token before calling this method.',
                    });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    resource: resource,
                    scope: scopes.join(' '),
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
        /**
         * Revoke the current access token and remove it from token storage.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<undefined>}
         */
        revokeToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                if (oldToken == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    token: oldToken.accessToken,
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                });
                yield this.tokenStorage.clear();
                return void 0;
            });
        }
    }
    function deserializeJwtConfigAppSettingsAppAuth(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "JwtConfigAppSettingsAppAuth"',
            });
        }
        if (val.publicKeyID == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "publicKeyID" of type "JwtConfigAppSettingsAppAuth" to be defined',
            });
        }
        if (!sdIsString(val.publicKeyID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "publicKeyID" of type "JwtConfigAppSettingsAppAuth"',
            });
        }
        const publicKeyId = val.publicKeyID;
        if (val.privateKey == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "privateKey" of type "JwtConfigAppSettingsAppAuth" to be defined',
            });
        }
        if (!sdIsString(val.privateKey)) {
            throw new BoxSdkError({
                message: 'Expecting string for "privateKey" of type "JwtConfigAppSettingsAppAuth"',
            });
        }
        const privateKey = val.privateKey;
        if (val.passphrase == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "passphrase" of type "JwtConfigAppSettingsAppAuth" to be defined',
            });
        }
        if (!sdIsString(val.passphrase)) {
            throw new BoxSdkError({
                message: 'Expecting string for "passphrase" of type "JwtConfigAppSettingsAppAuth"',
            });
        }
        const passphrase = val.passphrase;
        return {
            publicKeyId: publicKeyId,
            privateKey: privateKey,
            passphrase: passphrase,
        };
    }
    function deserializeJwtConfigAppSettings(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "JwtConfigAppSettings"',
            });
        }
        if (val.clientID == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "clientID" of type "JwtConfigAppSettings" to be defined',
            });
        }
        if (!sdIsString(val.clientID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "clientID" of type "JwtConfigAppSettings"',
            });
        }
        const clientId = val.clientID;
        if (val.clientSecret == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "clientSecret" of type "JwtConfigAppSettings" to be defined',
            });
        }
        if (!sdIsString(val.clientSecret)) {
            throw new BoxSdkError({
                message: 'Expecting string for "clientSecret" of type "JwtConfigAppSettings"',
            });
        }
        const clientSecret = val.clientSecret;
        if (val.appAuth == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "appAuth" of type "JwtConfigAppSettings" to be defined',
            });
        }
        const appAuth = deserializeJwtConfigAppSettingsAppAuth(val.appAuth);
        return {
            clientId: clientId,
            clientSecret: clientSecret,
            appAuth: appAuth,
        };
    }
    function deserializeJwtConfigFile(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "JwtConfigFile"' });
        }
        if (!(val.enterpriseID == void 0) && !sdIsString(val.enterpriseID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "enterpriseID" of type "JwtConfigFile"',
            });
        }
        const enterpriseId = val.enterpriseID == void 0 ? void 0 : val.enterpriseID;
        if (!(val.userID == void 0) && !sdIsString(val.userID)) {
            throw new BoxSdkError({
                message: 'Expecting string for "userID" of type "JwtConfigFile"',
            });
        }
        const userId = val.userID == void 0 ? void 0 : val.userID;
        if (val.boxAppSettings == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "boxAppSettings" of type "JwtConfigFile" to be defined',
            });
        }
        const boxAppSettings = deserializeJwtConfigAppSettings(val.boxAppSettings);
        return {
            enterpriseId: enterpriseId,
            userId: userId,
            boxAppSettings: boxAppSettings,
        };
    }

    class OAuthConfig {
        constructor(fields) {
            this.tokenStorage = new InMemoryTokenStorage({});
            if (fields.clientId !== undefined) {
                this.clientId = fields.clientId;
            }
            if (fields.clientSecret !== undefined) {
                this.clientSecret = fields.clientSecret;
            }
            if (fields.tokenStorage !== undefined) {
                this.tokenStorage = fields.tokenStorage;
            }
        }
    }
    class BoxOAuth {
        constructor(fields) {
            if (fields.config !== undefined) {
                this.config = fields.config;
            }
            this.tokenStorage = this.config.tokenStorage;
        }
        /**
         * Get the authorization URL for the app user.
         * @param {GetAuthorizeUrlOptions} options
         * @returns {string}
         */
        getAuthorizeUrl(options = {}) {
            const paramsMap = prepareParams({
                ['client_id']: !(options.clientId == void 0)
                    ? options.clientId
                    : this.config.clientId,
                ['response_type']: !(options.responseType == void 0)
                    ? options.responseType
                    : 'code',
                ['redirect_uri']: options.redirectUri,
                ['state']: options.state,
                ['scope']: options.scope,
            });
            return ''.concat('https://account.box.com/api/oauth2/authorize?', sdToUrlParams(JSON.stringify(paramsMap)));
        }
        /**
         * Acquires token info using an authorization code.
         * @param {string} authorizationCode The authorization code to use to get tokens.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        getTokensAuthorizationCodeGrant(authorizationCode, networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'authorization_code',
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    code: authorizationCode,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        /**
         * Get the current access token. If the current access token is expired or not found, this method will attempt to refresh the token.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        retrieveToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    throw new BoxSdkError({
                        message: 'Access and refresh tokens not available. Authenticate before making any API call first.',
                    });
                }
                return token;
            });
        }
        /**
         * Get a new access token for the platform app user.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        refreshToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const oldToken = yield this.tokenStorage.get();
                const tokenUsedForRefresh = !(oldToken == void 0)
                    ? oldToken.refreshToken
                    : void 0;
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const token = yield authManager.requestAccessToken({
                    grantType: 'refresh_token',
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    refreshToken: tokenUsedForRefresh,
                });
                yield this.tokenStorage.store(token);
                return token;
            });
        }
        /**
         * @param {NetworkSession} networkSession
         * @returns {Promise<string>}
         */
        retrieveAuthorizationHeader(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                return ''.concat('Bearer ', token.accessToken);
            });
        }
        /**
         * Revoke an active Access Token, effectively logging a user out that has been previously authenticated.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<undefined>}
         */
        revokeToken(networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.tokenStorage.get();
                if (token == void 0) {
                    return void 0;
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                yield authManager.revokeAccessToken({
                    clientId: this.config.clientId,
                    clientSecret: this.config.clientSecret,
                    token: token.accessToken,
                });
                return void 0;
            });
        }
        /**
         * Downscope access token to the provided scopes. Returning a new access token with the provided scopes, with the original access token unchanged.
         * @param {readonly string[]} scopes The scope(s) to apply to the resulting token.
         * @param {string} resource The file or folder to get a downscoped token for. If None and shared_link None, the resulting token will not be scoped down to just a single item. The resource should be a full URL to an item, e.g. https://api.box.com/2.0/files/123456.
         * @param {string} sharedLink The shared link to get a downscoped token for. If None and item None, the resulting token will not be scoped down to just a single item.
         * @param {NetworkSession} networkSession An object to keep network session state
         * @returns {Promise<AccessToken>}
         */
        downscopeToken(scopes, resource, sharedLink, networkSession) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const token = yield this.retrieveToken(networkSession);
                if (token == void 0 || token.accessToken == void 0) {
                    throw new BoxSdkError({ message: 'No access token is available.' });
                }
                const authManager = new AuthorizationManager({
                    networkSession: !(networkSession == void 0)
                        ? networkSession
                        : new NetworkSession({}),
                });
                const downscopedToken = yield authManager.requestAccessToken({
                    grantType: 'urn:ietf:params:oauth:grant-type:token-exchange',
                    subjectToken: token.accessToken,
                    subjectTokenType: 'urn:ietf:params:oauth:token-type:access_token',
                    scope: scopes.join(' '),
                    resource: resource,
                    boxSharedLink: sharedLink,
                });
                return downscopedToken;
            });
        }
    }

    function serializeUserBaseTypeField(val) {
        return val;
    }
    function deserializeUserBaseTypeField(val) {
        if (val == 'user') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize UserBaseTypeField" });
    }
    function serializeUserBase(val) {
        return { ['id']: val.id, ['type']: serializeUserBaseTypeField(val.type) };
    }
    function deserializeUserBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserBase"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserBase"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserBase" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function serializeUserMini(val) {
        const base = serializeUserBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserMini"' });
        }
        return Object.assign(Object.assign({}, base), { ['name']: val.name, ['login']: val.login });
    }
    function deserializeUserMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserMini"' });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserMini"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserMini" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return { name: name, login: login, id: id, type: type };
    }

    function deserializeFilePathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FilePathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "FilePathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "FilePathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "FilePathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FilePathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeFileSharedLinkAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileSharedLinkAccessField",
        });
    }
    function deserializeFileSharedLinkEffectiveAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileSharedLinkEffectiveAccessField",
        });
    }
    function deserializeFileSharedLinkEffectivePermissionField(val) {
        if (val == 'can_edit') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'no_access') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileSharedLinkEffectivePermissionField",
        });
    }
    function deserializeFileSharedLinkPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileSharedLinkPermissionsField"',
            });
        }
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FileSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FileSharedLinkPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_preview == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_preview" of type "FileSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "FileSharedLinkPermissionsField"',
            });
        }
        const canPreview = val.can_preview;
        if (val.can_edit == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_edit" of type "FileSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_edit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_edit" of type "FileSharedLinkPermissionsField"',
            });
        }
        const canEdit = val.can_edit;
        return {
            canDownload: canDownload,
            canPreview: canPreview,
            canEdit: canEdit,
        };
    }
    function deserializeFileSharedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileSharedLinkField"',
            });
        }
        if (val.url == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "url" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileSharedLinkField"',
            });
        }
        const url = val.url;
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "FileSharedLinkField"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.vanity_url == void 0) && !sdIsString(val.vanity_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_url" of type "FileSharedLinkField"',
            });
        }
        const vanityUrl = val.vanity_url == void 0 ? void 0 : val.vanity_url;
        if (!(val.vanity_name == void 0) && !sdIsString(val.vanity_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_name" of type "FileSharedLinkField"',
            });
        }
        const vanityName = val.vanity_name == void 0 ? void 0 : val.vanity_name;
        const access = val.access == void 0
            ? void 0
            : deserializeFileSharedLinkAccessField(val.access);
        if (val.effective_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_access" of type "FileSharedLinkField" to be defined',
            });
        }
        const effectiveAccess = deserializeFileSharedLinkEffectiveAccessField(val.effective_access);
        if (val.effective_permission == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_permission" of type "FileSharedLinkField" to be defined',
            });
        }
        const effectivePermission = deserializeFileSharedLinkEffectivePermissionField(val.effective_permission);
        if (!(val.unshared_at == void 0) && !sdIsString(val.unshared_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "unshared_at" of type "FileSharedLinkField"',
            });
        }
        const unsharedAt = val.unshared_at == void 0 ? void 0 : dateTimeFromString(val.unshared_at);
        if (val.is_password_enabled == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "is_password_enabled" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsBoolean(val.is_password_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_password_enabled" of type "FileSharedLinkField"',
            });
        }
        const isPasswordEnabled = val.is_password_enabled;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFileSharedLinkPermissionsField(val.permissions);
        if (val.download_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "download_count" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.download_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "download_count" of type "FileSharedLinkField"',
            });
        }
        const downloadCount = val.download_count;
        if (val.preview_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "preview_count" of type "FileSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.preview_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "preview_count" of type "FileSharedLinkField"',
            });
        }
        const previewCount = val.preview_count;
        return {
            url: url,
            downloadUrl: downloadUrl,
            vanityUrl: vanityUrl,
            vanityName: vanityName,
            access: access,
            effectiveAccess: effectiveAccess,
            effectivePermission: effectivePermission,
            unsharedAt: unsharedAt,
            isPasswordEnabled: isPasswordEnabled,
            permissions: permissions,
            downloadCount: downloadCount,
            previewCount: previewCount,
        };
    }
    function deserializeFileItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileItemStatusField" });
    }
    function deserializeFile(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "File"' });
        }
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "File"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "File"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFilePathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "File"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "File"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "File"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "File"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "File"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "File"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFileSharedLinkField(val.shared_link);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFileItemStatusField(val.item_status);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "File"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "File"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "File"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "File" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "File"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "File"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "File" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return {
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function deserializeMetadataBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "MetadataBase"' });
        }
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "MetadataBase"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        if (!(val.$template == void 0) && !sdIsString(val.$template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$template" of type "MetadataBase"',
            });
        }
        const template = val.$template == void 0 ? void 0 : val.$template;
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "MetadataBase"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "MetadataBase"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        return {
            parent: parent,
            template: template,
            scope: scope,
            version: version,
        };
    }

    function deserializeMetadata(val) {
        return deserializeMetadataBase(val);
    }

    function deserializeMetadataFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "MetadataFull"' });
        }
        if (!(val.$canEdit == void 0) && !sdIsBoolean(val.$canEdit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "$canEdit" of type "MetadataFull"',
            });
        }
        const canEdit = val.$canEdit == void 0 ? void 0 : val.$canEdit;
        if (!(val.$id == void 0) && !sdIsString(val.$id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$id" of type "MetadataFull"',
            });
        }
        const id = val.$id == void 0 ? void 0 : val.$id;
        if (!(val.$type == void 0) && !sdIsString(val.$type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$type" of type "MetadataFull"',
            });
        }
        const type = val.$type == void 0 ? void 0 : val.$type;
        if (!(val.$typeVersion == void 0) && !sdIsNumber(val.$typeVersion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$typeVersion" of type "MetadataFull"',
            });
        }
        const typeVersion = val.$typeVersion == void 0 ? void 0 : val.$typeVersion;
        if (!(val == void 0) && !sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting object for "extraData" of type "MetadataFull"',
            });
        }
        const extraData = val == void 0
            ? void 0
            : sdIsMap(val)
                ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                    k,
                    (function (v) {
                        return v;
                    })(v),
                ]))
                : {};
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "MetadataFull"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        if (!(val.$template == void 0) && !sdIsString(val.$template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$template" of type "MetadataFull"',
            });
        }
        const template = val.$template == void 0 ? void 0 : val.$template;
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "MetadataFull"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "MetadataFull"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        return {
            canEdit: canEdit,
            id: id,
            type: type,
            typeVersion: typeVersion,
            extraData: extraData,
            parent: parent,
            template: template,
            scope: scope,
            version: version,
        };
    }

    function deserializeFileFullPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullPermissionsField"',
            });
        }
        if (val.can_delete == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_delete" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_delete)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_delete" of type "FileFullPermissionsField"',
            });
        }
        const canDelete = val.can_delete;
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FileFullPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_invite_collaborator == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_invite_collaborator" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_invite_collaborator)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_invite_collaborator" of type "FileFullPermissionsField"',
            });
        }
        const canInviteCollaborator = val.can_invite_collaborator;
        if (val.can_rename == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_rename" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_rename)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_rename" of type "FileFullPermissionsField"',
            });
        }
        const canRename = val.can_rename;
        if (val.can_set_share_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_set_share_access" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_set_share_access)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_set_share_access" of type "FileFullPermissionsField"',
            });
        }
        const canSetShareAccess = val.can_set_share_access;
        if (val.can_share == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_share" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_share)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_share" of type "FileFullPermissionsField"',
            });
        }
        const canShare = val.can_share;
        if (val.can_annotate == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_annotate" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_annotate)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_annotate" of type "FileFullPermissionsField"',
            });
        }
        const canAnnotate = val.can_annotate;
        if (val.can_comment == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_comment" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_comment)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_comment" of type "FileFullPermissionsField"',
            });
        }
        const canComment = val.can_comment;
        if (val.can_preview == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_preview" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "FileFullPermissionsField"',
            });
        }
        const canPreview = val.can_preview;
        if (val.can_upload == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_upload" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_upload)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_upload" of type "FileFullPermissionsField"',
            });
        }
        const canUpload = val.can_upload;
        if (val.can_view_annotations_all == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_view_annotations_all" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_view_annotations_all)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_view_annotations_all" of type "FileFullPermissionsField"',
            });
        }
        const canViewAnnotationsAll = val.can_view_annotations_all;
        if (val.can_view_annotations_self == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_view_annotations_self" of type "FileFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_view_annotations_self)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_view_annotations_self" of type "FileFullPermissionsField"',
            });
        }
        const canViewAnnotationsSelf = val.can_view_annotations_self;
        return {
            canDelete: canDelete,
            canDownload: canDownload,
            canInviteCollaborator: canInviteCollaborator,
            canRename: canRename,
            canSetShareAccess: canSetShareAccess,
            canShare: canShare,
            canAnnotate: canAnnotate,
            canComment: canComment,
            canPreview: canPreview,
            canUpload: canUpload,
            canViewAnnotationsAll: canViewAnnotationsAll,
            canViewAnnotationsSelf: canViewAnnotationsSelf,
        };
    }
    function deserializeFileFullLockTypeField(val) {
        if (val == 'lock') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileFullLockTypeField" });
    }
    function deserializeFileFullLockAppTypeField(val) {
        if (val == 'gsuite') {
            return val;
        }
        if (val == 'office_wopi') {
            return val;
        }
        if (val == 'office_wopiplus') {
            return val;
        }
        if (val == 'other') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullLockAppTypeField",
        });
    }
    function deserializeFileFullLockField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullLockField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileFullLockField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeFileFullLockTypeField(val.type);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileFullLockField"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.expired_at == void 0) && !sdIsString(val.expired_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expired_at" of type "FileFullLockField"',
            });
        }
        const expiredAt = val.expired_at == void 0 ? void 0 : dateTimeFromString(val.expired_at);
        if (!(val.is_download_prevented == void 0) &&
            !sdIsBoolean(val.is_download_prevented)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_download_prevented" of type "FileFullLockField"',
            });
        }
        const isDownloadPrevented = val.is_download_prevented == void 0 ? void 0 : val.is_download_prevented;
        const appType = val.app_type == void 0
            ? void 0
            : deserializeFileFullLockAppTypeField(val.app_type);
        return {
            id: id,
            type: type,
            createdBy: createdBy,
            createdAt: createdAt,
            expiredAt: expiredAt,
            isDownloadPrevented: isDownloadPrevented,
            appType: appType,
        };
    }
    function deserializeFileFullExpiringEmbedLinkTokenTypeField(val) {
        if (val == 'bearer') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullExpiringEmbedLinkTokenTypeField",
        });
    }
    function deserializeFileFullExpiringEmbedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullExpiringEmbedLinkField"',
            });
        }
        if (!(val.access_token == void 0) && !sdIsString(val.access_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_token" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const accessToken = val.access_token == void 0 ? void 0 : val.access_token;
        if (!(val.expires_in == void 0) && !sdIsNumber(val.expires_in)) {
            throw new BoxSdkError({
                message: 'Expecting number for "expires_in" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const expiresIn = val.expires_in == void 0 ? void 0 : val.expires_in;
        const tokenType = val.token_type == void 0
            ? void 0
            : deserializeFileFullExpiringEmbedLinkTokenTypeField(val.token_type);
        if (!(val.restricted_to == void 0) && !sdIsList(val.restricted_to)) {
            throw new BoxSdkError({
                message: 'Expecting array for "restricted_to" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const restrictedTo = val.restricted_to == void 0
            ? void 0
            : sdIsList(val.restricted_to)
                ? val.restricted_to.map(function (itm) {
                    return deserializeFileOrFolderScope(itm);
                })
                : [];
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileFullExpiringEmbedLinkField"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        return {
            accessToken: accessToken,
            expiresIn: expiresIn,
            tokenType: tokenType,
            restrictedTo: restrictedTo,
            url: url,
        };
    }
    function deserializeFileFullWatermarkInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullWatermarkInfoField"',
            });
        }
        if (!(val.is_watermarked == void 0) && !sdIsBoolean(val.is_watermarked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_watermarked" of type "FileFullWatermarkInfoField"',
            });
        }
        const isWatermarked = val.is_watermarked == void 0 ? void 0 : val.is_watermarked;
        return { isWatermarked: isWatermarked };
    }
    function deserializeFileFullAllowedInviteeRolesField(val) {
        if (val == 'editor') {
            return val;
        }
        if (val == 'viewer') {
            return val;
        }
        if (val == 'previewer') {
            return val;
        }
        if (val == 'uploader') {
            return val;
        }
        if (val == 'previewer uploader') {
            return val;
        }
        if (val == 'viewer uploader') {
            return val;
        }
        if (val == 'co-owner') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullAllowedInviteeRolesField",
        });
    }
    function deserializeFileFullMetadataField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullMetadataField"',
            });
        }
        if (!(val == void 0) && !sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting object for "extraData" of type "FileFullMetadataField"',
            });
        }
        const extraData = val == void 0
            ? void 0
            : sdIsMap(val)
                ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                    k,
                    (function (v) {
                        return sdIsMap(v)
                            ? Object.fromEntries(Object.entries(v).map(([k, v]) => [
                                k,
                                deserializeMetadataFull(v),
                            ]))
                            : {};
                    })(v),
                ]))
                : {};
        return { extraData: extraData };
    }
    function deserializeFileFullRepresentationsEntriesContentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesContentField"',
            });
        }
        if (!(val.url_template == void 0) && !sdIsString(val.url_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url_template" of type "FileFullRepresentationsEntriesContentField"',
            });
        }
        const urlTemplate = val.url_template == void 0 ? void 0 : val.url_template;
        return {
            urlTemplate: urlTemplate,
        };
    }
    function deserializeFileFullRepresentationsEntriesInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesInfoField"',
            });
        }
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileFullRepresentationsEntriesInfoField"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        return { url: url };
    }
    function deserializeFileFullRepresentationsEntriesPropertiesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        if (!(val.dimensions == void 0) && !sdIsString(val.dimensions)) {
            throw new BoxSdkError({
                message: 'Expecting string for "dimensions" of type "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        const dimensions = val.dimensions == void 0 ? void 0 : val.dimensions;
        if (!(val.paged == void 0) && !sdIsString(val.paged)) {
            throw new BoxSdkError({
                message: 'Expecting string for "paged" of type "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        const paged = val.paged == void 0 ? void 0 : val.paged;
        if (!(val.thumb == void 0) && !sdIsString(val.thumb)) {
            throw new BoxSdkError({
                message: 'Expecting string for "thumb" of type "FileFullRepresentationsEntriesPropertiesField"',
            });
        }
        const thumb = val.thumb == void 0 ? void 0 : val.thumb;
        return {
            dimensions: dimensions,
            paged: paged,
            thumb: thumb,
        };
    }
    function deserializeFileFullRepresentationsEntriesStatusStateField(val) {
        if (val == 'success') {
            return val;
        }
        if (val == 'viewable') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (val == 'none') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullRepresentationsEntriesStatusStateField",
        });
    }
    function deserializeFileFullRepresentationsEntriesStatusField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesStatusField"',
            });
        }
        const state = val.state == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesStatusStateField(val.state);
        return { state: state };
    }
    function deserializeFileFullRepresentationsEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsEntriesField"',
            });
        }
        const content = val.content == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesContentField(val.content);
        const info = val.info == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesInfoField(val.info);
        const properties = val.properties == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesPropertiesField(val.properties);
        if (!(val.representation == void 0) && !sdIsString(val.representation)) {
            throw new BoxSdkError({
                message: 'Expecting string for "representation" of type "FileFullRepresentationsEntriesField"',
            });
        }
        const representation = val.representation == void 0 ? void 0 : val.representation;
        const status = val.status == void 0
            ? void 0
            : deserializeFileFullRepresentationsEntriesStatusField(val.status);
        return {
            content: content,
            info: info,
            properties: properties,
            representation: representation,
            status: status,
        };
    }
    function deserializeFileFullRepresentationsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullRepresentationsField"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileFullRepresentationsField"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullRepresentationsEntriesField(itm);
                })
                : [];
        return { entries: entries };
    }
    function deserializeFileFullClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullClassificationField"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileFullClassificationField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.definition == void 0) && !sdIsString(val.definition)) {
            throw new BoxSdkError({
                message: 'Expecting string for "definition" of type "FileFullClassificationField"',
            });
        }
        const definition = val.definition == void 0 ? void 0 : val.definition;
        if (!(val.color == void 0) && !sdIsString(val.color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "color" of type "FileFullClassificationField"',
            });
        }
        const color = val.color == void 0 ? void 0 : val.color;
        return {
            name: name,
            definition: definition,
            color: color,
        };
    }
    function deserializeFileFullSharedLinkPermissionOptionsField(val) {
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_edit') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullSharedLinkPermissionOptionsField",
        });
    }
    function deserializeFileFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileFull"' });
        }
        if (!(val.version_number == void 0) && !sdIsString(val.version_number)) {
            throw new BoxSdkError({
                message: 'Expecting string for "version_number" of type "FileFull"',
            });
        }
        const versionNumber = val.version_number == void 0 ? void 0 : val.version_number;
        if (!(val.comment_count == void 0) && !sdIsNumber(val.comment_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "comment_count" of type "FileFull"',
            });
        }
        const commentCount = val.comment_count == void 0 ? void 0 : val.comment_count;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFileFullPermissionsField(val.permissions);
        if (!(val.tags == void 0) && !sdIsList(val.tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "tags" of type "FileFull"',
            });
        }
        const tags = val.tags == void 0
            ? void 0
            : sdIsList(val.tags)
                ? val.tags.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "FileFull"',
                        });
                    }
                    return itm;
                })
                : [];
        const lock = val.lock == void 0 ? void 0 : deserializeFileFullLockField(val.lock);
        if (!(val.extension == void 0) && !sdIsString(val.extension)) {
            throw new BoxSdkError({
                message: 'Expecting string for "extension" of type "FileFull"',
            });
        }
        const extension = val.extension == void 0 ? void 0 : val.extension;
        if (!(val.is_package == void 0) && !sdIsBoolean(val.is_package)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_package" of type "FileFull"',
            });
        }
        const isPackage = val.is_package == void 0 ? void 0 : val.is_package;
        const expiringEmbedLink = val.expiring_embed_link == void 0
            ? void 0
            : deserializeFileFullExpiringEmbedLinkField(val.expiring_embed_link);
        const watermarkInfo = val.watermark_info == void 0
            ? void 0
            : deserializeFileFullWatermarkInfoField(val.watermark_info);
        if (!(val.is_accessible_via_shared_link == void 0) &&
            !sdIsBoolean(val.is_accessible_via_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accessible_via_shared_link" of type "FileFull"',
            });
        }
        const isAccessibleViaSharedLink = val.is_accessible_via_shared_link == void 0
            ? void 0
            : val.is_accessible_via_shared_link;
        if (!(val.allowed_invitee_roles == void 0) &&
            !sdIsList(val.allowed_invitee_roles)) {
            throw new BoxSdkError({
                message: 'Expecting array for "allowed_invitee_roles" of type "FileFull"',
            });
        }
        const allowedInviteeRoles = val.allowed_invitee_roles == void 0
            ? void 0
            : sdIsList(val.allowed_invitee_roles)
                ? val.allowed_invitee_roles.map(function (itm) {
                    return deserializeFileFullAllowedInviteeRolesField(itm);
                })
                : [];
        if (!(val.is_externally_owned == void 0) &&
            !sdIsBoolean(val.is_externally_owned)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_externally_owned" of type "FileFull"',
            });
        }
        const isExternallyOwned = val.is_externally_owned == void 0 ? void 0 : val.is_externally_owned;
        if (!(val.has_collaborations == void 0) &&
            !sdIsBoolean(val.has_collaborations)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "has_collaborations" of type "FileFull"',
            });
        }
        const hasCollaborations = val.has_collaborations == void 0 ? void 0 : val.has_collaborations;
        const metadata = val.metadata == void 0
            ? void 0
            : deserializeFileFullMetadataField(val.metadata);
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "FileFull"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        const representations = val.representations == void 0
            ? void 0
            : deserializeFileFullRepresentationsField(val.representations);
        const classification = val.classification == void 0
            ? void 0
            : deserializeFileFullClassificationField(val.classification);
        if (!(val.uploader_display_name == void 0) &&
            !sdIsString(val.uploader_display_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "uploader_display_name" of type "FileFull"',
            });
        }
        const uploaderDisplayName = val.uploader_display_name == void 0 ? void 0 : val.uploader_display_name;
        if (!(val.disposition_at == void 0) && !sdIsString(val.disposition_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "disposition_at" of type "FileFull"',
            });
        }
        const dispositionAt = val.disposition_at == void 0
            ? void 0
            : dateTimeFromString(val.disposition_at);
        if (!(val.shared_link_permission_options == void 0) &&
            !sdIsList(val.shared_link_permission_options)) {
            throw new BoxSdkError({
                message: 'Expecting array for "shared_link_permission_options" of type "FileFull"',
            });
        }
        const sharedLinkPermissionOptions = val.shared_link_permission_options == void 0
            ? void 0
            : sdIsList(val.shared_link_permission_options)
                ? val.shared_link_permission_options.map(function (itm) {
                    return deserializeFileFullSharedLinkPermissionOptionsField(itm);
                })
                : [];
        if (!(val.is_associated_with_app_item == void 0) &&
            !sdIsBoolean(val.is_associated_with_app_item)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_associated_with_app_item" of type "FileFull"',
            });
        }
        const isAssociatedWithAppItem = val.is_associated_with_app_item == void 0
            ? void 0
            : val.is_associated_with_app_item;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "FileFull"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "FileFull"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFilePathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "FileFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "FileFull"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "FileFull"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "FileFull"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "FileFull"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFileSharedLinkField(val.shared_link);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFileItemStatusField(val.item_status);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FileFull"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileFull"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileFull"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileFull"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileFull" to be defined',
            });
        }
        const type = deserializeFileBaseTypeField(val.type);
        return {
            versionNumber: versionNumber,
            commentCount: commentCount,
            permissions: permissions,
            tags: tags,
            lock: lock,
            extension: extension,
            isPackage: isPackage,
            expiringEmbedLink: expiringEmbedLink,
            watermarkInfo: watermarkInfo,
            isAccessibleViaSharedLink: isAccessibleViaSharedLink,
            allowedInviteeRoles: allowedInviteeRoles,
            isExternallyOwned: isExternallyOwned,
            hasCollaborations: hasCollaborations,
            metadata: metadata,
            expiresAt: expiresAt,
            representations: representations,
            classification: classification,
            uploaderDisplayName: uploaderDisplayName,
            dispositionAt: dispositionAt,
            sharedLinkPermissionOptions: sharedLinkPermissionOptions,
            isAssociatedWithAppItem: isAssociatedWithAppItem,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            id: id,
            etag: etag,
            type: type,
        };
    }

    class GetFileByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CopyFileOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CopyFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileThumbnailUrlOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileThumbnailUrlHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileThumbnailByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileThumbnailByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifNoneMatch !== undefined) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.xRepHints !== undefined) {
                this.xRepHints = fields.xRepHints;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CopyFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileThumbnailUrlHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileThumbnailByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FilesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves the details about a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileFull>}
           */
        getFileById(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                    ['x-rep-hints']: toString(headers.xRepHints),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a file. This can be used to rename or move a file,
           * create a shared link, or lock a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {UpdateFileByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileFull>}
           */
        updateFileById(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new UpdateFileByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateFileByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a file, either permanently or by moving it to
           * the trash.
           *
           * The the enterprise settings determine whether the item will
           * be permanently deleted from Box or moved to the trash.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {DeleteFileByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFileById(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteFileByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Creates a copy of a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {CopyFileRequestBody} requestBody Request body of copyFile method
           * @param {CopyFileOptionalsInput} optionalsInput
           * @returns {Promise<FileFull>}
           */
        copyFile(fileId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new CopyFileOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/copy'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCopyFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a thumbnail, or smaller image representation, of a file.
           *
           * Sizes of `32x32`,`64x64`, `128x128`, and `256x256` can be returned in
           * the `.png` format and sizes of `32x32`, `160x160`, and `320x320`
           * can be returned in the `.jpg` format.
           *
           * Thumbnails can be generated for the image and video file formats listed
           * [found on our community site][1].
           *
           * [1]: https://community.box.com/t5/Migrating-and-Previewing-Content/File-Types-and-Fonts-Supported-in-Box-Content-Preview/ta-p/327
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileThumbnailUrlExtension} extension The file format for the thumbnail.
          Example: "png"
           * @param {GetFileThumbnailUrlOptionalsInput} optionalsInput
           * @returns {Promise<string>}
           */
        getFileThumbnailUrl(fileId_1, extension_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, extension, optionalsInput = {}) {
                const optionals = new GetFileThumbnailUrlOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['min_height']: toString(queryParams.minHeight),
                    ['min_width']: toString(queryParams.minWidth),
                    ['max_height']: toString(queryParams.maxHeight),
                    ['max_width']: toString(queryParams.maxWidth),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const cancellationController = createCancellationController();
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/thumbnail.', toString(extension)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken == void 0
                        ? cancellationController.signal
                        : cancellationToken,
                    followRedirects: false,
                }));
                if (isBrowser()) {
                    cancellationController.abort();
                    if (response.url == void 0) {
                        throw new BoxSdkError({ message: 'Unable to get response URL' });
                    }
                    return response.url;
                }
                if ('location' in response.headers) {
                    return response.headers.location;
                }
                if ('Location' in response.headers) {
                    return response.headers.Location;
                }
                throw new BoxSdkError({ message: 'No location header in response' });
            });
        }
        /**
           * Retrieves a thumbnail, or smaller image representation, of a file.
           *
           * Sizes of `32x32`,`64x64`, `128x128`, and `256x256` can be returned in
           * the `.png` format and sizes of `32x32`, `160x160`, and `320x320`
           * can be returned in the `.jpg` format.
           *
           * Thumbnails can be generated for the image and video file formats listed
           * [found on our community site][1].
           *
           * [1]: https://community.box.com/t5/Migrating-and-Previewing-Content/File-Types-and-Fonts-Supported-in-Box-Content-Preview/ta-p/327
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileThumbnailByIdExtension} extension The file format for the thumbnail.
          Example: "png"
           * @param {GetFileThumbnailByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined | ByteStream>}
           */
        getFileThumbnailById(fileId_1, extension_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, extension, optionalsInput = {}) {
                const optionals = new GetFileThumbnailByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['min_height']: toString(queryParams.minHeight),
                    ['min_width']: toString(queryParams.minWidth),
                    ['max_height']: toString(queryParams.maxHeight),
                    ['max_width']: toString(queryParams.maxWidth),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/thumbnail.', toString(extension)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                if (toString(response.status) == '202') {
                    return void 0;
                }
                return response.content;
            });
        }
    }
    function serializeUpdateFileByIdRequestBodyParentField(val) {
        return { ['id']: val.id, ['user_id']: val.userId };
    }
    function serializeUpdateFileByIdRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateFileByIdRequestBodySharedLinkPermissionsField(val) {
        return { ['can_download']: val.canDownload };
    }
    function serializeUpdateFileByIdRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateFileByIdRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeUpdateFileByIdRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateFileByIdRequestBodyLockAccessField(val) {
        return val;
    }
    function serializeUpdateFileByIdRequestBodyLockField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateFileByIdRequestBodyLockAccessField(val.access),
            ['expires_at']: val.expiresAt == void 0
                ? val.expiresAt
                : dateTimeToString(val.expiresAt),
            ['is_download_prevented']: val.isDownloadPrevented,
        };
    }
    function serializeUpdateFileByIdRequestBodyPermissionsCanDownloadField(val) {
        return val;
    }
    function serializeUpdateFileByIdRequestBodyPermissionsField(val) {
        return {
            ['can_download']: val.canDownload == void 0
                ? val.canDownload
                : serializeUpdateFileByIdRequestBodyPermissionsCanDownloadField(val.canDownload),
        };
    }
    function serializeUpdateFileByIdRequestBodyCollectionsField(val) {
        return { ['id']: val.id, ['type']: val.type };
    }
    function serializeUpdateFileByIdRequestBody(val) {
        return {
            ['name']: val.name,
            ['description']: val.description,
            ['parent']: val.parent == void 0
                ? val.parent
                : serializeUpdateFileByIdRequestBodyParentField(val.parent),
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeUpdateFileByIdRequestBodySharedLinkField(val.sharedLink),
            ['lock']: val.lock == void 0
                ? val.lock
                : serializeUpdateFileByIdRequestBodyLockField(val.lock),
            ['disposition_at']: val.dispositionAt == void 0
                ? val.dispositionAt
                : dateTimeToString(val.dispositionAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeUpdateFileByIdRequestBodyPermissionsField(val.permissions),
            ['collections']: val.collections == void 0
                ? val.collections
                : val.collections.map(function (item) {
                    return serializeUpdateFileByIdRequestBodyCollectionsField(item);
                }),
            ['tags']: val.tags == void 0
                ? val.tags
                : val.tags.map(function (item) {
                    return item;
                }),
        };
    }
    function serializeCopyFileRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCopyFileRequestBody(val) {
        return {
            ['name']: val.name,
            ['version']: val.version,
            ['parent']: serializeCopyFileRequestBodyParentField(val.parent),
        };
    }

    function deserializeTrashFileRestoredTypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFileRestoredTypeField",
        });
    }
    function deserializeTrashFileRestoredPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFileRestoredPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFileRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFileRestoredPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFileRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFileRestoredPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFileRestoredItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFileRestoredItemStatusField",
        });
    }
    function deserializeTrashFileRestored(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFileRestored"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFileRestored"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFileRestored"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TrashFileRestored" to be defined',
            });
        }
        const type = deserializeTrashFileRestoredTypeField(val.type);
        if (val.sequence_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sequence_id" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFileRestored"',
            });
        }
        const sequenceId = val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFileRestored"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.sha1 == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sha1" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "TrashFileRestored"',
            });
        }
        const sha1 = val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFileRestored"',
            });
        }
        const description = val.description;
        if (val.size == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "size" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFileRestored"',
            });
        }
        const size = val.size;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashFileRestored" to be defined',
            });
        }
        const pathCollection = deserializeTrashFileRestoredPathCollectionField(val.path_collection);
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFileRestored"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (val.modified_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_at" of type "TrashFileRestored" to be defined',
            });
        }
        if (!sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFileRestored"',
            });
        }
        const modifiedAt = dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFileRestored"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : val.trashed_at;
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFileRestored"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : val.purged_at;
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFileRestored"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFileRestored"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (val.modified_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_by" of type "TrashFileRestored" to be defined',
            });
        }
        const modifiedBy = deserializeUserMini(val.modified_by);
        if (val.owned_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "owned_by" of type "TrashFileRestored" to be defined',
            });
        }
        const ownedBy = deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFileRestored"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (val.item_status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_status" of type "TrashFileRestored" to be defined',
            });
        }
        const itemStatus = deserializeTrashFileRestoredItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    function deserializeTrashFileTypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrashFileTypeField" });
    }
    function deserializeTrashFilePathCollectionEntriesTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFilePathCollectionEntriesTypeField",
        });
    }
    function deserializeTrashFilePathCollectionEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFilePathCollectionEntriesField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashFilePathCollectionEntriesTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFilePathCollectionEntriesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
        };
    }
    function deserializeTrashFilePathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFilePathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFilePathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFilePathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFilePathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFilePathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTrashFilePathCollectionEntriesField(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFileItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFileItemStatusField",
        });
    }
    function deserializeTrashFile(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrashFile"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFile"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFile"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TrashFile" to be defined',
            });
        }
        const type = deserializeTrashFileTypeField(val.type);
        if (val.sequence_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sequence_id" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFile"',
            });
        }
        const sequenceId = val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFile"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.sha1 == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sha1" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "TrashFile"',
            });
        }
        const sha1 = val.sha1;
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFile"',
            });
        }
        const description = val.description;
        if (val.size == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "size" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFile"',
            });
        }
        const size = val.size;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashFile" to be defined',
            });
        }
        const pathCollection = deserializeTrashFilePathCollectionField(val.path_collection);
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFile"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (val.modified_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_at" of type "TrashFile" to be defined',
            });
        }
        if (!sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFile"',
            });
        }
        const modifiedAt = dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFile"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFile"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFile"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFile"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (val.modified_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_by" of type "TrashFile" to be defined',
            });
        }
        const modifiedBy = deserializeUserMini(val.modified_by);
        if (val.owned_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "owned_by" of type "TrashFile" to be defined',
            });
        }
        const ownedBy = deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFile"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (val.item_status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_status" of type "TrashFile" to be defined',
            });
        }
        const itemStatus = deserializeTrashFileItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            sha1: sha1,
            fileVersion: fileVersion,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    class RestoreFileFromTrashOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new RestoreFileFromTrashHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTrashedFileByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetTrashedFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTrashedFileByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTrashedFileByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RestoreFileFromTrashHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTrashedFileByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTrashedFileByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedFilesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Restores a file that has been moved to the trash.
           *
           * An optional new parent ID can be provided to restore the file to in case the
           * original folder has been deleted.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {RestoreFileFromTrashOptionalsInput} optionalsInput
           * @returns {Promise<TrashFileRestored>}
           */
        restoreFileFromTrash(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new RestoreFileFromTrashOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId)),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRestoreFileFromTrashRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTrashFileRestored(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a file that has been moved to the trash.
           *
           * Please note that only if the file itself has been moved to the
           * trash can it be retrieved with this API call. If instead one of
           * its parent folders was moved to the trash, only that folder
           * can be inspected using the
           * [`GET /folders/:id/trash`](e://get_folders_id_trash) API.
           *
           * To list all items that have been moved to the trash, please
           * use the [`GET /folders/trash/items`](e://get-folders-trash-items/)
           * API.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetTrashedFileByIdOptionalsInput} optionalsInput
           * @returns {Promise<TrashFile>}
           */
        getTrashedFileById(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetTrashedFileByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/trash'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTrashFile(response.data)), { rawData: response.data });
            });
        }
        /**
           * Permanently deletes a file that is in the trash.
           * This action cannot be undone.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {DeleteTrashedFileByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteTrashedFileById(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteTrashedFileByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/trash'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeRestoreFileFromTrashRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeRestoreFileFromTrashRequestBody(val) {
        return {
            ['name']: val.name,
            ['parent']: val.parent == void 0
                ? val.parent
                : serializeRestoreFileFromTrashRequestBodyParentField(val.parent),
        };
    }

    function deserializeAppItemTypeField(val) {
        if (val == 'app_item') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize AppItemTypeField" });
    }
    function deserializeAppItem(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AppItem"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "AppItem" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AppItem"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AppItem" to be defined',
            });
        }
        const type = deserializeAppItemTypeField(val.type);
        if (val.application_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "application_type" of type "AppItem" to be defined',
            });
        }
        if (!sdIsString(val.application_type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "application_type" of type "AppItem"',
            });
        }
        const applicationType = val.application_type;
        return {
            id: id,
            type: type,
            applicationType: applicationType,
        };
    }

    function deserializeWebLinkBaseTypeField(val) {
        if (val == 'web_link') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WebLinkBaseTypeField" });
    }
    function deserializeWebLinkBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "WebLinkBase"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "WebLinkBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WebLinkBase"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "WebLinkBase" to be defined',
            });
        }
        const type = deserializeWebLinkBaseTypeField(val.type);
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "WebLinkBase"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        return { id: id, type: type, etag: etag };
    }

    function deserializeFileBaseOrFolderBaseOrWebLinkBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileBaseOrFolderBaseOrWebLinkBase"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileBase(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderBase(val);
        }
        if (val.type == 'web_link') {
            return deserializeWebLinkBase(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileBaseOrFolderBaseOrWebLinkBase",
        });
    }

    function deserializeAppItemAssociationTypeField(val) {
        if (val == 'app_item_association') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AppItemAssociationTypeField",
        });
    }
    function deserializeAppItemAssociation(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemAssociation"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "AppItemAssociation" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AppItemAssociation"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AppItemAssociation" to be defined',
            });
        }
        const type = deserializeAppItemAssociationTypeField(val.type);
        if (val.app_item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "app_item" of type "AppItemAssociation" to be defined',
            });
        }
        const appItem = deserializeAppItem(val.app_item);
        if (val.item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item" of type "AppItemAssociation" to be defined',
            });
        }
        const item = deserializeFileBaseOrFolderBaseOrWebLinkBase(val.item);
        return {
            id: id,
            type: type,
            appItem: appItem,
            item: item,
        };
    }

    function deserializeAppItemAssociations(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemAssociations"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "AppItemAssociations"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "AppItemAssociations"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "AppItemAssociations"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "AppItemAssociations"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeAppItemAssociation(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetFileAppItemAssociationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileAppItemAssociationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderAppItemAssociationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFolderAppItemAssociationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileAppItemAssociationsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFolderAppItemAssociationsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AppItemAssociationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * **This is a beta feature, which means that its availability might be limited.**
           * Returns all app items the file is associated with. This includes app items
           * associated with ancestors of the file. Assuming the context user has access
           * to the file, the type/ids are revealed even if the context user does not
           * have **View** permission on the app item.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileAppItemAssociationsOptionalsInput} optionalsInput
           * @returns {Promise<AppItemAssociations>}
           */
        getFileAppItemAssociations(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileAppItemAssociationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                    ['application_type']: toString(queryParams.applicationType),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/app_item_associations'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAppItemAssociations(response.data)), { rawData: response.data });
            });
        }
        /**
           * **This is a beta feature, which means that its availability might be limited.**
           * Returns all app items the folder is associated with. This includes app items
           * associated with ancestors of the folder. Assuming the context user has access
           * to the folder, the type/ids are revealed even if the context user does not
           * have **View** permission on the app item.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetFolderAppItemAssociationsOptionalsInput} optionalsInput
           * @returns {Promise<AppItemAssociations>}
           */
        getFolderAppItemAssociations(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderAppItemAssociationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                    ['application_type']: toString(queryParams.applicationType),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/app_item_associations'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAppItemAssociations(response.data)), { rawData: response.data });
            });
        }
    }

    class GetDownloadFileUrlOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetDownloadFileUrlHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DownloadFileOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new DownloadFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDownloadFileUrlHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.range !== undefined) {
                this.range = fields.range;
            }
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DownloadFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.range !== undefined) {
                this.range = fields.range;
            }
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DownloadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Returns the contents of a file in binary format.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetDownloadFileUrlOptionalsInput} optionalsInput
           * @returns {Promise<string>}
           */
        getDownloadFileUrl(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetDownloadFileUrlOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['version']: toString(queryParams.version),
                    ['access_token']: toString(queryParams.accessToken),
                });
                const headersMap = prepareParams(Object.assign({
                    ['range']: toString(headers.range),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const cancellationController = createCancellationController();
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/content'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken == void 0
                        ? cancellationController.signal
                        : cancellationToken,
                    followRedirects: false,
                }));
                if (isBrowser()) {
                    cancellationController.abort();
                    if (response.url == void 0) {
                        throw new BoxSdkError({ message: 'Unable to get response URL' });
                    }
                    return response.url;
                }
                if ('location' in response.headers) {
                    return response.headers.location;
                }
                if ('Location' in response.headers) {
                    return response.headers.Location;
                }
                throw new BoxSdkError({ message: 'No location header in response' });
            });
        }
        /**
           * Returns the contents of a file in binary format.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {DownloadFileOptionalsInput} optionalsInput
           * @returns {Promise<undefined | ByteStream>}
           */
        downloadFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DownloadFileOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['version']: toString(queryParams.version),
                    ['access_token']: toString(queryParams.accessToken),
                });
                const headersMap = prepareParams(Object.assign({
                    ['range']: toString(headers.range),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/content'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                if (toString(response.status) == '202') {
                    return void 0;
                }
                return response.content;
            });
        }
    }

    function deserializeFiles(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Files"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Files"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Files"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFull(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    function deserializeUploadUrl(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadUrl"' });
        }
        if (!(val.upload_url == void 0) && !sdIsString(val.upload_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "upload_url" of type "UploadUrl"',
            });
        }
        const uploadUrl = val.upload_url == void 0 ? void 0 : val.upload_url;
        if (!(val.upload_token == void 0) && !sdIsString(val.upload_token)) {
            throw new BoxSdkError({
                message: 'Expecting string for "upload_token" of type "UploadUrl"',
            });
        }
        const uploadToken = val.upload_token == void 0 ? void 0 : val.upload_token;
        return { uploadUrl: uploadUrl, uploadToken: uploadToken };
    }

    class UploadFileVersionOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new UploadFileVersionHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadFileOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new UploadFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadWithPreflightCheckOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new UploadWithPreflightCheckHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadFileVersionHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.contentMd5 !== undefined) {
                this.contentMd5 = fields.contentMd5;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class PreflightFileUploadCheckHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.contentMd5 !== undefined) {
                this.contentMd5 = fields.contentMd5;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadWithPreflightCheckHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.contentMd5 !== undefined) {
                this.contentMd5 = fields.contentMd5;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Update a file's content. For file sizes over 50MB we recommend
           * using the Chunk Upload APIs.
           *
           * The `attributes` part of the body must come **before** the
           * `file` part. Requests that do not follow this format when
           * uploading the file will receive a HTTP `400` error with a
           * `metadata_after_file_contents` error code.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {UploadFileVersionRequestBody} requestBody Request body of uploadFileVersion method
           * @param {UploadFileVersionOptionalsInput} optionalsInput
           * @returns {Promise<Files>}
           */
        uploadFileVersion(fileId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UploadFileVersionOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-match']: toString(headers.ifMatch),
                    ['content-md5']: toString(headers.contentMd5),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/', toString(fileId), '/content'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    multipartData: [
                        {
                            partName: 'attributes',
                            data: serializeUploadFileVersionRequestBodyAttributesField(requestBody.attributes),
                        },
                        {
                            partName: 'file',
                            fileStream: requestBody.file,
                            fileName: requestBody.fileFileName,
                            contentType: requestBody.fileContentType,
                        },
                    ],
                    contentType: 'multipart/form-data',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFiles(response.data)), { rawData: response.data });
            });
        }
        /**
         * Performs a check to verify that a file will be accepted by Box
         * before you upload the entire file.
         * @param {PreflightFileUploadCheckRequestBody} requestBody Request body of preflightFileUploadCheck method
         * @param {PreflightFileUploadCheckHeadersInput} headersInput Headers of preflightFileUploadCheck method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<UploadUrl>}
         */
        preflightFileUploadCheck() {
            return __awaiter$1(this, arguments, void 0, function* (requestBody = {}, headersInput = new PreflightFileUploadCheckHeaders({}), cancellationToken) {
                const headers = new PreflightFileUploadCheckHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/content'),
                    method: 'OPTIONS',
                    headers: headersMap,
                    data: serializePreflightFileUploadCheckRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadUrl(response.data)), { rawData: response.data });
            });
        }
        /**
         * Uploads a small file to Box. For file sizes over 50MB we recommend
         * using the Chunk Upload APIs.
         *
         * The `attributes` part of the body must come **before** the
         * `file` part. Requests that do not follow this format when
         * uploading the file will receive a HTTP `400` error with a
         * `metadata_after_file_contents` error code.
         * @param {UploadFileRequestBody} requestBody Request body of uploadFile method
         * @param {UploadFileOptionalsInput} optionalsInput
         * @returns {Promise<Files>}
         */
        uploadFile(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new UploadFileOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({ ['content-md5']: toString(headers.contentMd5) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/content'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    multipartData: [
                        {
                            partName: 'attributes',
                            data: serializeUploadFileRequestBodyAttributesField(requestBody.attributes),
                        },
                        {
                            partName: 'file',
                            fileStream: requestBody.file,
                            fileName: requestBody.fileFileName,
                            contentType: requestBody.fileContentType,
                        },
                    ],
                    contentType: 'multipart/form-data',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFiles(response.data)), { rawData: response.data });
            });
        }
        /**
         *  Upload a file with a preflight check
         * @param {UploadWithPreflightCheckRequestBody} requestBody
         * @param {UploadWithPreflightCheckOptionalsInput} optionalsInput
         * @returns {Promise<Files>}
         */
        uploadWithPreflightCheck(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new UploadWithPreflightCheckOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({ ['content-md5']: toString(headers.contentMd5) }, headers.extraHeaders));
                const preflightUploadUrl = yield this.preflightFileUploadCheck({
                    name: requestBody.attributes.name,
                    size: requestBody.attributes.size,
                    parent: {
                        id: requestBody.attributes.parent.id,
                    },
                }, {
                    extraHeaders: headers.extraHeaders,
                }, cancellationToken);
                if (preflightUploadUrl.uploadUrl == void 0 ||
                    !preflightUploadUrl.uploadUrl.includes('http')) {
                    throw new BoxSdkError({ message: 'Unable to get preflight upload URL' });
                }
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: preflightUploadUrl.uploadUrl,
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    multipartData: [
                        {
                            partName: 'attributes',
                            data: serializeUploadFileRequestBodyAttributesField(requestBody.attributes),
                        },
                        {
                            partName: 'file',
                            fileStream: requestBody.file,
                            fileName: requestBody.fileFileName,
                            contentType: requestBody.fileContentType,
                        },
                    ],
                    contentType: 'multipart/form-data',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFiles(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUploadFileVersionRequestBodyAttributesField(val) {
        return {
            ['name']: val.name,
            ['content_modified_at']: val.contentModifiedAt == void 0
                ? val.contentModifiedAt
                : dateTimeToString(val.contentModifiedAt),
        };
    }
    function serializePreflightFileUploadCheckRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializePreflightFileUploadCheckRequestBody(val) {
        return {
            ['name']: val.name,
            ['size']: val.size,
            ['parent']: val.parent == void 0
                ? val.parent
                : serializePreflightFileUploadCheckRequestBodyParentField(val.parent),
        };
    }
    function serializeUploadFileRequestBodyAttributesParentField(val) {
        return { ['id']: val.id };
    }
    function serializeUploadFileRequestBodyAttributesField(val) {
        return {
            ['name']: val.name,
            ['parent']: serializeUploadFileRequestBodyAttributesParentField(val.parent),
            ['content_created_at']: val.contentCreatedAt == void 0
                ? val.contentCreatedAt
                : dateTimeToString(val.contentCreatedAt),
            ['content_modified_at']: val.contentModifiedAt == void 0
                ? val.contentModifiedAt
                : dateTimeToString(val.contentModifiedAt),
        };
    }

    function deserializeUploadSessionTypeField(val) {
        if (val == 'upload_session') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UploadSessionTypeField",
        });
    }
    function deserializeUploadSessionSessionEndpointsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UploadSessionSessionEndpointsField"',
            });
        }
        if (!(val.upload_part == void 0) && !sdIsString(val.upload_part)) {
            throw new BoxSdkError({
                message: 'Expecting string for "upload_part" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const uploadPart = val.upload_part == void 0 ? void 0 : val.upload_part;
        if (!(val.commit == void 0) && !sdIsString(val.commit)) {
            throw new BoxSdkError({
                message: 'Expecting string for "commit" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const commit = val.commit == void 0 ? void 0 : val.commit;
        if (!(val.abort == void 0) && !sdIsString(val.abort)) {
            throw new BoxSdkError({
                message: 'Expecting string for "abort" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const abort = val.abort == void 0 ? void 0 : val.abort;
        if (!(val.list_parts == void 0) && !sdIsString(val.list_parts)) {
            throw new BoxSdkError({
                message: 'Expecting string for "list_parts" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const listParts = val.list_parts == void 0 ? void 0 : val.list_parts;
        if (!(val.status == void 0) && !sdIsString(val.status)) {
            throw new BoxSdkError({
                message: 'Expecting string for "status" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const status = val.status == void 0 ? void 0 : val.status;
        if (!(val.log_event == void 0) && !sdIsString(val.log_event)) {
            throw new BoxSdkError({
                message: 'Expecting string for "log_event" of type "UploadSessionSessionEndpointsField"',
            });
        }
        const logEvent = val.log_event == void 0 ? void 0 : val.log_event;
        return {
            uploadPart: uploadPart,
            commit: commit,
            abort: abort,
            listParts: listParts,
            status: status,
            logEvent: logEvent,
        };
    }
    function deserializeUploadSession(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadSession"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UploadSession"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeUploadSessionTypeField(val.type);
        if (!(val.session_expires_at == void 0) &&
            !sdIsString(val.session_expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "session_expires_at" of type "UploadSession"',
            });
        }
        const sessionExpiresAt = val.session_expires_at == void 0
            ? void 0
            : dateTimeFromString(val.session_expires_at);
        if (!(val.part_size == void 0) && !sdIsNumber(val.part_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "part_size" of type "UploadSession"',
            });
        }
        const partSize = val.part_size == void 0 ? void 0 : val.part_size;
        if (!(val.total_parts == void 0) && !sdIsNumber(val.total_parts)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_parts" of type "UploadSession"',
            });
        }
        const totalParts = val.total_parts == void 0 ? void 0 : val.total_parts;
        if (!(val.num_parts_processed == void 0) &&
            !sdIsNumber(val.num_parts_processed)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_parts_processed" of type "UploadSession"',
            });
        }
        const numPartsProcessed = val.num_parts_processed == void 0 ? void 0 : val.num_parts_processed;
        const sessionEndpoints = val.session_endpoints == void 0
            ? void 0
            : deserializeUploadSessionSessionEndpointsField(val.session_endpoints);
        return {
            id: id,
            type: type,
            sessionExpiresAt: sessionExpiresAt,
            partSize: partSize,
            totalParts: totalParts,
            numPartsProcessed: numPartsProcessed,
            sessionEndpoints: sessionEndpoints,
        };
    }

    function serializeUploadPartMini(val) {
        return {
            ['part_id']: val.partId,
            ['offset']: val.offset,
            ['size']: val.size,
        };
    }

    function serializeUploadPart(val) {
        const base = serializeUploadPartMini(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadPart"' });
        }
        return Object.assign(Object.assign({}, base), { ['sha1']: val.sha1 });
    }
    function deserializeUploadPart(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadPart"' });
        }
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "UploadPart"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        if (!(val.part_id == void 0) && !sdIsString(val.part_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "part_id" of type "UploadPart"',
            });
        }
        const partId = val.part_id == void 0 ? void 0 : val.part_id;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "UploadPart"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "UploadPart"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        return {
            sha1: sha1,
            partId: partId,
            offset: offset,
            size: size,
        };
    }

    function deserializeUploadedPart(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadedPart"' });
        }
        const part = val.part == void 0 ? void 0 : deserializeUploadPart(val.part);
        return { part: part };
    }

    function deserializeUploadPartsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UploadPartsOrderDirectionField",
        });
    }
    function deserializeUploadPartsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UploadPartsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "UploadPartsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeUploadPartsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeUploadParts(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UploadParts"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "UploadParts"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "UploadParts"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "UploadParts"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "UploadParts"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeUploadPartsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "UploadParts"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeUploadPart(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class CreateFileUploadSessionOptionals {
        constructor(fields) {
            this.headers = new CreateFileUploadSessionHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileUploadSessionForExistingFileOptionals {
        constructor(fields) {
            this.headers = new CreateFileUploadSessionForExistingFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileUploadSessionByUrlOptionals {
        constructor(fields) {
            this.headers = new GetFileUploadSessionByUrlHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileUploadSessionByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileUploadSessionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadFilePartByUrlOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UploadFilePartOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileUploadSessionByUrlOptionals {
        constructor(fields) {
            this.headers = new DeleteFileUploadSessionByUrlHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileUploadSessionByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileUploadSessionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileUploadSessionPartsByUrlOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileUploadSessionPartsByUrlHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileUploadSessionPartsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileUploadSessionPartsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileUploadSessionCommitByUrlOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileUploadSessionCommitOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileUploadSessionHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileUploadSessionForExistingFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileUploadSessionByUrlHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileUploadSessionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadFilePartByUrlHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.digest !== undefined) {
                this.digest = fields.digest;
            }
            if (fields.contentRange !== undefined) {
                this.contentRange = fields.contentRange;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UploadFilePartHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.digest !== undefined) {
                this.digest = fields.digest;
            }
            if (fields.contentRange !== undefined) {
                this.contentRange = fields.contentRange;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileUploadSessionByUrlHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileUploadSessionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileUploadSessionPartsByUrlHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileUploadSessionPartsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileUploadSessionCommitByUrlHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.digest !== undefined) {
                this.digest = fields.digest;
            }
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.ifNoneMatch !== undefined) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileUploadSessionCommitHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.digest !== undefined) {
                this.digest = fields.digest;
            }
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.ifNoneMatch !== undefined) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ChunkedUploadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Creates an upload session for a new file.
         * @param {CreateFileUploadSessionRequestBody} requestBody Request body of createFileUploadSession method
         * @param {CreateFileUploadSessionOptionalsInput} optionalsInput
         * @returns {Promise<UploadSession>}
         */
        createFileUploadSession(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateFileUploadSessionOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileUploadSessionRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadSession(response.data)), { rawData: response.data });
            });
        }
        /**
           * Creates an upload session for an existing file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {CreateFileUploadSessionForExistingFileRequestBody} requestBody Request body of createFileUploadSessionForExistingFile method
           * @param {CreateFileUploadSessionForExistingFileOptionalsInput} optionalsInput
           * @returns {Promise<UploadSession>}
           */
        createFileUploadSessionForExistingFile(fileId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new CreateFileUploadSessionForExistingFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/', toString(fileId), '/upload_sessions'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileUploadSessionForExistingFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadSession(response.data)), { rawData: response.data });
            });
        }
        /**
         * Using this method with urls provided in response when creating a new upload session is preferred to use over GetFileUploadSessionById method.
         * This allows to always upload your content to the closest Box data center and can significantly improve upload speed.
         *  Return information about an upload session.
         *
         * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions) endpoint.
         * @param {string} url URL of getFileUploadSessionById method
         * @param {GetFileUploadSessionByUrlOptionalsInput} optionalsInput
         * @returns {Promise<UploadSession>}
         */
        getFileUploadSessionByUrl(url_1) {
            return __awaiter$1(this, arguments, void 0, function* (url, optionalsInput = {}) {
                const optionals = new GetFileUploadSessionByUrlOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: url,
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadSession(response.data)), { rawData: response.data });
            });
        }
        /**
           * Return information about an upload session.
           *
           * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions) endpoint.
           * @param {string} uploadSessionId The ID of the upload session.
          Example: "D5E3F7A"
           * @param {GetFileUploadSessionByIdOptionalsInput} optionalsInput
           * @returns {Promise<UploadSession>}
           */
        getFileUploadSessionById(uploadSessionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (uploadSessionId, optionalsInput = {}) {
                const optionals = new GetFileUploadSessionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadSession(response.data)), { rawData: response.data });
            });
        }
        /**
         * Using this method with urls provided in response when creating a new upload session is preferred to use over UploadFilePart method.
         * This allows to always upload your content to the closest Box data center and can significantly improve upload speed.
         *  Uploads a chunk of a file for an upload session.
         *
         * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
         * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
         * @param {string} url URL of uploadFilePart method
         * @param {ByteStream} requestBody Request body of uploadFilePart method
         * @param {UploadFilePartByUrlHeadersInput} headersInput Headers of uploadFilePart method
         * @param {UploadFilePartByUrlOptionalsInput} optionalsInput
         * @returns {Promise<UploadedPart>}
         */
        uploadFilePartByUrl(url_1, requestBody_1, headersInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (url, requestBody, headersInput, optionalsInput = {}) {
                const headers = new UploadFilePartByUrlHeaders({
                    digest: headersInput.digest,
                    contentRange: headersInput.contentRange,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new UploadFilePartByUrlOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({
                    ['digest']: toString(headers.digest),
                    ['content-range']: toString(headers.contentRange),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: url,
                    method: 'PUT',
                    headers: headersMap,
                    fileStream: requestBody,
                    contentType: 'application/octet-stream',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadedPart(response.data)), { rawData: response.data });
            });
        }
        /**
           * Uploads a chunk of a file for an upload session.
           *
           * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
           * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
           * @param {string} uploadSessionId The ID of the upload session.
          Example: "D5E3F7A"
           * @param {ByteStream} requestBody Request body of uploadFilePart method
           * @param {UploadFilePartHeadersInput} headersInput Headers of uploadFilePart method
           * @param {UploadFilePartOptionalsInput} optionalsInput
           * @returns {Promise<UploadedPart>}
           */
        uploadFilePart(uploadSessionId_1, requestBody_1, headersInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (uploadSessionId, requestBody, headersInput, optionalsInput = {}) {
                const headers = new UploadFilePartHeaders({
                    digest: headersInput.digest,
                    contentRange: headersInput.contentRange,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new UploadFilePartOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({
                    ['digest']: toString(headers.digest),
                    ['content-range']: toString(headers.contentRange),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId)),
                    method: 'PUT',
                    headers: headersMap,
                    fileStream: requestBody,
                    contentType: 'application/octet-stream',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadedPart(response.data)), { rawData: response.data });
            });
        }
        /**
         * Using this method with urls provided in response when creating a new upload session is preferred to use over DeleteFileUploadSessionById method.
         * This allows to always upload your content to the closest Box data center and can significantly improve upload speed.
         *  Abort an upload session and discard all data uploaded.
         *
         * This cannot be reversed.
         *
         * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
         * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
         * @param {string} url URL of deleteFileUploadSessionById method
         * @param {DeleteFileUploadSessionByUrlOptionalsInput} optionalsInput
         * @returns {Promise<undefined>}
         */
        deleteFileUploadSessionByUrl(url_1) {
            return __awaiter$1(this, arguments, void 0, function* (url, optionalsInput = {}) {
                const optionals = new DeleteFileUploadSessionByUrlOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: url,
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Abort an upload session and discard all data uploaded.
           *
           * This cannot be reversed.
           *
           * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
           * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
           * @param {string} uploadSessionId The ID of the upload session.
          Example: "D5E3F7A"
           * @param {DeleteFileUploadSessionByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFileUploadSessionById(uploadSessionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (uploadSessionId, optionalsInput = {}) {
                const optionals = new DeleteFileUploadSessionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
         * Using this method with urls provided in response when creating a new upload session is preferred to use over GetFileUploadSessionParts method.
         * This allows to always upload your content to the closest Box data center and can significantly improve upload speed.
         *  Return a list of the chunks uploaded to the upload session so far.
         *
         * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
         * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
         * @param {string} url URL of getFileUploadSessionParts method
         * @param {GetFileUploadSessionPartsByUrlOptionalsInput} optionalsInput
         * @returns {Promise<UploadParts>}
         */
        getFileUploadSessionPartsByUrl(url_1) {
            return __awaiter$1(this, arguments, void 0, function* (url, optionalsInput = {}) {
                const optionals = new GetFileUploadSessionPartsByUrlOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: url,
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadParts(response.data)), { rawData: response.data });
            });
        }
        /**
           * Return a list of the chunks uploaded to the upload session so far.
           *
           * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
           * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
           * @param {string} uploadSessionId The ID of the upload session.
          Example: "D5E3F7A"
           * @param {GetFileUploadSessionPartsOptionalsInput} optionalsInput
           * @returns {Promise<UploadParts>}
           */
        getFileUploadSessionParts(uploadSessionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (uploadSessionId, optionalsInput = {}) {
                const optionals = new GetFileUploadSessionPartsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId), '/parts'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUploadParts(response.data)), { rawData: response.data });
            });
        }
        /**
         * Using this method with urls provided in response when creating a new upload session is preferred to use over CreateFileUploadSessionCommit method.
         * This allows to always upload your content to the closest Box data center and can significantly improve upload speed.
         *  Close an upload session and create a file from the uploaded chunks.
         *
         * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
         * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
         * @param {string} url URL of createFileUploadSessionCommit method
         * @param {CreateFileUploadSessionCommitByUrlRequestBody} requestBody Request body of createFileUploadSessionCommit method
         * @param {CreateFileUploadSessionCommitByUrlHeadersInput} headersInput Headers of createFileUploadSessionCommit method
         * @param {CreateFileUploadSessionCommitByUrlOptionalsInput} optionalsInput
         * @returns {Promise<undefined | Files>}
         */
        createFileUploadSessionCommitByUrl(url_1, requestBody_1, headersInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (url, requestBody, headersInput, optionalsInput = {}) {
                const headers = new CreateFileUploadSessionCommitByUrlHeaders({
                    digest: headersInput.digest,
                    ifMatch: headersInput.ifMatch,
                    ifNoneMatch: headersInput.ifNoneMatch,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new CreateFileUploadSessionCommitByUrlOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({
                    ['digest']: toString(headers.digest),
                    ['if-match']: toString(headers.ifMatch),
                    ['if-none-match']: toString(headers.ifNoneMatch),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: url,
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileUploadSessionCommitRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                if (toString(response.status) == '202') {
                    return void 0;
                }
                return Object.assign(Object.assign({}, deserializeFiles(response.data)), { rawData: response.data });
            });
        }
        /**
           * Close an upload session and create a file from the uploaded chunks.
           *
           * The actual endpoint URL is returned by the [`Create upload session`](e://post-files-upload-sessions)
           * and [`Get upload session`](e://get-files-upload-sessions-id) endpoints.
           * @param {string} uploadSessionId The ID of the upload session.
          Example: "D5E3F7A"
           * @param {CreateFileUploadSessionCommitRequestBody} requestBody Request body of createFileUploadSessionCommit method
           * @param {CreateFileUploadSessionCommitHeadersInput} headersInput Headers of createFileUploadSessionCommit method
           * @param {CreateFileUploadSessionCommitOptionalsInput} optionalsInput
           * @returns {Promise<undefined | Files>}
           */
        createFileUploadSessionCommit(uploadSessionId_1, requestBody_1, headersInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (uploadSessionId, requestBody, headersInput, optionalsInput = {}) {
                const headers = new CreateFileUploadSessionCommitHeaders({
                    digest: headersInput.digest,
                    ifMatch: headersInput.ifMatch,
                    ifNoneMatch: headersInput.ifNoneMatch,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new CreateFileUploadSessionCommitOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({
                    ['digest']: toString(headers.digest),
                    ['if-match']: toString(headers.ifMatch),
                    ['if-none-match']: toString(headers.ifNoneMatch),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.uploadUrl, '/2.0/files/upload_sessions/', toString(uploadSessionId), '/commit'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileUploadSessionCommitRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                if (toString(response.status) == '202') {
                    return void 0;
                }
                return Object.assign(Object.assign({}, deserializeFiles(response.data)), { rawData: response.data });
            });
        }
        /**
         * @param {PartAccumulator} acc
         * @param {ByteStream} chunk
         * @returns {Promise<PartAccumulator>}
         */
        reducer(acc, chunk) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const lastIndex = acc.lastIndex;
                const parts = acc.parts;
                const chunkBuffer = yield readByteStream(chunk);
                const hash = new Hash({ algorithm: 'sha1' });
                yield hash.updateHash(chunkBuffer);
                const sha1 = yield hash.digestHash('base64');
                const digest = ''.concat('sha=', sha1);
                const chunkSize = bufferLength(chunkBuffer);
                const bytesStart = lastIndex + 1;
                const bytesEnd = lastIndex + chunkSize;
                const contentRange = ''.concat('bytes ', toString(bytesStart), '-', toString(bytesEnd), '/', toString(acc.fileSize));
                const uploadedPart = yield this.uploadFilePartByUrl(acc.uploadPartUrl, generateByteStreamFromBuffer(chunkBuffer), {
                    digest: digest,
                    contentRange: contentRange,
                });
                const part = uploadedPart.part;
                const partSha1 = hexToBase64(part.sha1);
                if (!(partSha1 == sha1)) {
                    throw new Error('Assertion failed');
                }
                if (!(part.size == chunkSize)) {
                    throw new Error('Assertion failed');
                }
                if (!(part.offset == bytesStart)) {
                    throw new Error('Assertion failed');
                }
                yield acc.fileHash.updateHash(chunkBuffer);
                return {
                    lastIndex: bytesEnd,
                    parts: parts.concat([part]),
                    fileSize: acc.fileSize,
                    uploadPartUrl: acc.uploadPartUrl,
                    fileHash: acc.fileHash,
                };
            });
        }
        /**
         * Starts the process of chunk uploading a big file. Should return a File object representing uploaded file.
         * @param {ByteStream} file The stream of the file to upload.
         * @param {string} fileName The name of the file, which will be used for storage in Box.
         * @param {number} fileSize The total size of the file for the chunked upload in bytes.
         * @param {string} parentFolderId The ID of the folder where the file should be uploaded.
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<FileFull>}
         */
        uploadBigFile(file, fileName, fileSize, parentFolderId, cancellationToken) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const uploadSession = yield this.createFileUploadSession({
                    fileName: fileName,
                    fileSize: fileSize,
                    folderId: parentFolderId,
                }, {
                    headers: new CreateFileUploadSessionHeaders({}),
                    cancellationToken: cancellationToken,
                });
                const uploadPartUrl = uploadSession.sessionEndpoints.uploadPart;
                const commitUrl = uploadSession.sessionEndpoints.commit;
                const listPartsUrl = uploadSession.sessionEndpoints.listParts;
                const partSize = uploadSession.partSize;
                const totalParts = uploadSession.totalParts;
                if (!(partSize * totalParts >= fileSize)) {
                    throw new Error('Assertion failed');
                }
                if (!(uploadSession.numPartsProcessed == 0)) {
                    throw new Error('Assertion failed');
                }
                const fileHash = new Hash({ algorithm: 'sha1' });
                const chunksIterator = iterateChunks(file, partSize, fileSize);
                const results = yield reduceIterator(chunksIterator, this.reducer.bind(this), {
                    lastIndex: -1,
                    parts: [],
                    fileSize: fileSize,
                    uploadPartUrl: uploadPartUrl,
                    fileHash: fileHash,
                });
                const parts = results.parts;
                const processedSessionParts = yield this.getFileUploadSessionPartsByUrl(listPartsUrl, {
                    queryParams: {},
                    headers: new GetFileUploadSessionPartsByUrlHeaders({}),
                    cancellationToken: cancellationToken,
                });
                if (!(processedSessionParts.totalCount == totalParts)) {
                    throw new Error('Assertion failed');
                }
                const sha1 = yield fileHash.digestHash('base64');
                const digest = ''.concat('sha=', sha1);
                const committedSession = yield this.createFileUploadSessionCommitByUrl(commitUrl, {
                    parts: parts,
                }, {
                    digest: digest,
                }, {
                    cancellationToken: cancellationToken,
                });
                return committedSession.entries[0];
            });
        }
    }
    function serializeCreateFileUploadSessionRequestBody(val) {
        return {
            ['folder_id']: val.folderId,
            ['file_size']: val.fileSize,
            ['file_name']: val.fileName,
        };
    }
    function serializeCreateFileUploadSessionForExistingFileRequestBody(val) {
        return { ['file_size']: val.fileSize, ['file_name']: val.fileName };
    }
    function serializeCreateFileUploadSessionCommitRequestBody(val) {
        return {
            ['parts']: val.parts.map(function (item) {
                return serializeUploadPart(item);
            }),
        };
    }

    function deserializeWebLinkPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebLinkPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "WebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "WebLinkPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "WebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "WebLinkPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeWebLinkSharedLinkAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkSharedLinkAccessField",
        });
    }
    function deserializeWebLinkSharedLinkEffectiveAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkSharedLinkEffectiveAccessField",
        });
    }
    function deserializeWebLinkSharedLinkEffectivePermissionField(val) {
        if (val == 'can_edit') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'no_access') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkSharedLinkEffectivePermissionField",
        });
    }
    function deserializeWebLinkSharedLinkPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebLinkSharedLinkPermissionsField"',
            });
        }
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "WebLinkSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "WebLinkSharedLinkPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_preview == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_preview" of type "WebLinkSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "WebLinkSharedLinkPermissionsField"',
            });
        }
        const canPreview = val.can_preview;
        if (val.can_edit == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_edit" of type "WebLinkSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_edit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_edit" of type "WebLinkSharedLinkPermissionsField"',
            });
        }
        const canEdit = val.can_edit;
        return {
            canDownload: canDownload,
            canPreview: canPreview,
            canEdit: canEdit,
        };
    }
    function deserializeWebLinkSharedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebLinkSharedLinkField"',
            });
        }
        if (val.url == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "url" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "WebLinkSharedLinkField"',
            });
        }
        const url = val.url;
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "WebLinkSharedLinkField"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.vanity_url == void 0) && !sdIsString(val.vanity_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_url" of type "WebLinkSharedLinkField"',
            });
        }
        const vanityUrl = val.vanity_url == void 0 ? void 0 : val.vanity_url;
        if (!(val.vanity_name == void 0) && !sdIsString(val.vanity_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_name" of type "WebLinkSharedLinkField"',
            });
        }
        const vanityName = val.vanity_name == void 0 ? void 0 : val.vanity_name;
        const access = val.access == void 0
            ? void 0
            : deserializeWebLinkSharedLinkAccessField(val.access);
        if (val.effective_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_access" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        const effectiveAccess = deserializeWebLinkSharedLinkEffectiveAccessField(val.effective_access);
        if (val.effective_permission == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_permission" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        const effectivePermission = deserializeWebLinkSharedLinkEffectivePermissionField(val.effective_permission);
        if (!(val.unshared_at == void 0) && !sdIsString(val.unshared_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "unshared_at" of type "WebLinkSharedLinkField"',
            });
        }
        const unsharedAt = val.unshared_at == void 0 ? void 0 : dateTimeFromString(val.unshared_at);
        if (val.is_password_enabled == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "is_password_enabled" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsBoolean(val.is_password_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_password_enabled" of type "WebLinkSharedLinkField"',
            });
        }
        const isPasswordEnabled = val.is_password_enabled;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeWebLinkSharedLinkPermissionsField(val.permissions);
        if (val.download_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "download_count" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.download_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "download_count" of type "WebLinkSharedLinkField"',
            });
        }
        const downloadCount = val.download_count;
        if (val.preview_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "preview_count" of type "WebLinkSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.preview_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "preview_count" of type "WebLinkSharedLinkField"',
            });
        }
        const previewCount = val.preview_count;
        return {
            url: url,
            downloadUrl: downloadUrl,
            vanityUrl: vanityUrl,
            vanityName: vanityName,
            access: access,
            effectiveAccess: effectiveAccess,
            effectivePermission: effectivePermission,
            unsharedAt: unsharedAt,
            isPasswordEnabled: isPasswordEnabled,
            permissions: permissions,
            downloadCount: downloadCount,
            previewCount: previewCount,
        };
    }
    function deserializeWebLinkItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebLinkItemStatusField",
        });
    }
    function deserializeWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "WebLink"' });
        }
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "WebLink"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeWebLinkPathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "WebLink"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "WebLink"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "WebLink"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "WebLink"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeWebLinkSharedLinkField(val.shared_link);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeWebLinkItemStatusField(val.item_status);
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "WebLink"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "WebLink"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "WebLink"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "WebLink" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WebLink"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "WebLink" to be defined',
            });
        }
        const type = deserializeWebLinkBaseTypeField(val.type);
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "WebLink"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        return {
            parent: parent,
            description: description,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            itemStatus: itemStatus,
            url: url,
            sequenceId: sequenceId,
            name: name,
            id: id,
            type: type,
            etag: etag,
        };
    }

    function deserializeFileFullOrFolderMiniOrWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullOrFolderMiniOrWebLink"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileFull(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderMini(val);
        }
        if (val.type == 'web_link') {
            return deserializeWebLink(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullOrFolderMiniOrWebLink",
        });
    }

    function deserializeItemsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ItemsOrderDirectionField",
        });
    }
    function deserializeItemsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "ItemsOrderField"' });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "ItemsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeItemsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeItems(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Items"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Items"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Items"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Items"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Items"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Items"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Items"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeItemsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Items"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullOrFolderMiniOrWebLink(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            totalCount: totalCount,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    function deserializeFolderPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "FolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "FolderPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "FolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FolderPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeFolderSharedLinkAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderSharedLinkAccessField",
        });
    }
    function deserializeFolderSharedLinkEffectiveAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderSharedLinkEffectiveAccessField",
        });
    }
    function deserializeFolderSharedLinkEffectivePermissionField(val) {
        if (val == 'can_edit') {
            return val;
        }
        if (val == 'can_download') {
            return val;
        }
        if (val == 'can_preview') {
            return val;
        }
        if (val == 'no_access') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderSharedLinkEffectivePermissionField",
        });
    }
    function deserializeFolderSharedLinkPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderSharedLinkPermissionsField"',
            });
        }
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FolderSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FolderSharedLinkPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_preview == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_preview" of type "FolderSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_preview)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_preview" of type "FolderSharedLinkPermissionsField"',
            });
        }
        const canPreview = val.can_preview;
        if (val.can_edit == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_edit" of type "FolderSharedLinkPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_edit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_edit" of type "FolderSharedLinkPermissionsField"',
            });
        }
        const canEdit = val.can_edit;
        return {
            canDownload: canDownload,
            canPreview: canPreview,
            canEdit: canEdit,
        };
    }
    function deserializeFolderSharedLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderSharedLinkField"',
            });
        }
        if (val.url == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "url" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FolderSharedLinkField"',
            });
        }
        const url = val.url;
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "FolderSharedLinkField"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.vanity_url == void 0) && !sdIsString(val.vanity_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_url" of type "FolderSharedLinkField"',
            });
        }
        const vanityUrl = val.vanity_url == void 0 ? void 0 : val.vanity_url;
        if (!(val.vanity_name == void 0) && !sdIsString(val.vanity_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "vanity_name" of type "FolderSharedLinkField"',
            });
        }
        const vanityName = val.vanity_name == void 0 ? void 0 : val.vanity_name;
        const access = val.access == void 0
            ? void 0
            : deserializeFolderSharedLinkAccessField(val.access);
        if (val.effective_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_access" of type "FolderSharedLinkField" to be defined',
            });
        }
        const effectiveAccess = deserializeFolderSharedLinkEffectiveAccessField(val.effective_access);
        if (val.effective_permission == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "effective_permission" of type "FolderSharedLinkField" to be defined',
            });
        }
        const effectivePermission = deserializeFolderSharedLinkEffectivePermissionField(val.effective_permission);
        if (!(val.unshared_at == void 0) && !sdIsString(val.unshared_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "unshared_at" of type "FolderSharedLinkField"',
            });
        }
        const unsharedAt = val.unshared_at == void 0 ? void 0 : dateTimeFromString(val.unshared_at);
        if (val.is_password_enabled == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "is_password_enabled" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsBoolean(val.is_password_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_password_enabled" of type "FolderSharedLinkField"',
            });
        }
        const isPasswordEnabled = val.is_password_enabled;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFolderSharedLinkPermissionsField(val.permissions);
        if (val.download_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "download_count" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.download_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "download_count" of type "FolderSharedLinkField"',
            });
        }
        const downloadCount = val.download_count;
        if (val.preview_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "preview_count" of type "FolderSharedLinkField" to be defined',
            });
        }
        if (!sdIsNumber(val.preview_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "preview_count" of type "FolderSharedLinkField"',
            });
        }
        const previewCount = val.preview_count;
        return {
            url: url,
            downloadUrl: downloadUrl,
            vanityUrl: vanityUrl,
            vanityName: vanityName,
            access: access,
            effectiveAccess: effectiveAccess,
            effectivePermission: effectivePermission,
            unsharedAt: unsharedAt,
            isPasswordEnabled: isPasswordEnabled,
            permissions: permissions,
            downloadCount: downloadCount,
            previewCount: previewCount,
        };
    }
    function deserializeFolderFolderUploadEmailAccessField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFolderUploadEmailAccessField",
        });
    }
    function deserializeFolderFolderUploadEmailField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFolderUploadEmailField"',
            });
        }
        const access = val.access == void 0
            ? void 0
            : deserializeFolderFolderUploadEmailAccessField(val.access);
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "FolderFolderUploadEmailField"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        return {
            access: access,
            email: email,
        };
    }
    function deserializeFolderItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FolderItemStatusField" });
    }
    function deserializeFolder(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Folder"' });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Folder"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "Folder"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "Folder"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "Folder"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFolderPathCollectionField(val.path_collection);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "Folder"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "Folder"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "Folder"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "Folder"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFolderSharedLinkField(val.shared_link);
        const folderUploadEmail = val.folder_upload_email == void 0
            ? void 0
            : deserializeFolderFolderUploadEmailField(val.folder_upload_email);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFolderItemStatusField(val.item_status);
        const itemCollection = val.item_collection == void 0
            ? void 0
            : deserializeItems(val.item_collection);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "Folder"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "Folder"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "Folder" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Folder"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "Folder"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "Folder" to be defined',
            });
        }
        const type = deserializeFolderBaseTypeField(val.type);
        return {
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
            itemCollection: itemCollection,
            sequenceId: sequenceId,
            name: name,
            id: id,
            etag: etag,
            type: type,
        };
    }

    function deserializeFileOrFolderOrWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileOrFolderOrWebLink"',
            });
        }
        if (val.type == 'file') {
            return deserializeFile(val);
        }
        if (val.type == 'folder') {
            return deserializeFolder(val);
        }
        if (val.type == 'web_link') {
            return deserializeWebLink(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize FileOrFolderOrWebLink" });
    }

    function serializeGroupBaseTypeField(val) {
        return val;
    }
    function deserializeGroupBaseTypeField(val) {
        if (val == 'group') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize GroupBaseTypeField" });
    }
    function serializeGroupBase(val) {
        return { ['id']: val.id, ['type']: serializeGroupBaseTypeField(val.type) };
    }
    function deserializeGroupBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "GroupBase"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "GroupBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupBase"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "GroupBase" to be defined',
            });
        }
        const type = deserializeGroupBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeGroupMiniGroupTypeField(val) {
        if (val == 'managed_group') {
            return val;
        }
        if (val == 'all_users_group') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMiniGroupTypeField",
        });
    }
    function deserializeGroupMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "GroupMini"' });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "GroupMini"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const groupType = val.group_type == void 0
            ? void 0
            : deserializeGroupMiniGroupTypeField(val.group_type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "GroupMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "GroupMini" to be defined',
            });
        }
        const type = deserializeGroupBaseTypeField(val.type);
        return {
            name: name,
            groupType: groupType,
            id: id,
            type: type,
        };
    }

    function deserializeUserCollaborations(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserCollaborations"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserCollaborations"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserCollaborations"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (!(val.is_active == void 0) && !sdIsBoolean(val.is_active)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_active" of type "UserCollaborations"',
            });
        }
        const isActive = val.is_active == void 0 ? void 0 : val.is_active;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserCollaborations" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserCollaborations"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserCollaborations" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            name: name,
            login: login,
            isActive: isActive,
            id: id,
            type: type,
        };
    }

    function deserializeGroupMiniOrUserCollaborations(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupMiniOrUserCollaborations"',
            });
        }
        if (val.type == 'group') {
            return deserializeGroupMini(val);
        }
        if (val.type == 'user') {
            return deserializeUserCollaborations(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMiniOrUserCollaborations",
        });
    }

    function deserializeTermsOfServiceBaseTypeField(val) {
        if (val == 'terms_of_service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceBaseTypeField",
        });
    }
    function deserializeTermsOfServiceBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceBase"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TermsOfServiceBase" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfServiceBase"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TermsOfServiceBase" to be defined',
            });
        }
        const type = deserializeTermsOfServiceBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeCollaborationTypeField(val) {
        if (val == 'collaboration') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationTypeField",
        });
    }
    function deserializeCollaborationRoleField(val) {
        if (val == 'editor') {
            return val;
        }
        if (val == 'viewer') {
            return val;
        }
        if (val == 'previewer') {
            return val;
        }
        if (val == 'uploader') {
            return val;
        }
        if (val == 'previewer uploader') {
            return val;
        }
        if (val == 'viewer uploader') {
            return val;
        }
        if (val == 'co-owner') {
            return val;
        }
        if (val == 'owner') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationRoleField",
        });
    }
    function deserializeCollaborationStatusField(val) {
        if (val == 'accepted') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (val == 'rejected') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationStatusField",
        });
    }
    function deserializeCollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField"',
            });
        }
        if (!(val.is_accepted == void 0) && !sdIsBoolean(val.is_accepted)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accepted" of type "CollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField"',
            });
        }
        const isAccepted = val.is_accepted == void 0 ? void 0 : val.is_accepted;
        const termsOfService = val.terms_of_service == void 0
            ? void 0
            : deserializeTermsOfServiceBase(val.terms_of_service);
        return {
            isAccepted: isAccepted,
            termsOfService: termsOfService,
        };
    }
    function deserializeCollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        if (!(val.enterprise_has_strong_password_required_for_external_users == void 0) &&
            !sdIsBoolean(val.enterprise_has_strong_password_required_for_external_users)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "enterprise_has_strong_password_required_for_external_users" of type "CollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        const enterpriseHasStrongPasswordRequiredForExternalUsers = val.enterprise_has_strong_password_required_for_external_users == void 0
            ? void 0
            : val.enterprise_has_strong_password_required_for_external_users;
        if (!(val.user_has_strong_password == void 0) &&
            !sdIsBoolean(val.user_has_strong_password)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "user_has_strong_password" of type "CollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        const userHasStrongPassword = val.user_has_strong_password == void 0
            ? void 0
            : val.user_has_strong_password;
        return {
            enterpriseHasStrongPasswordRequiredForExternalUsers: enterpriseHasStrongPasswordRequiredForExternalUsers,
            userHasStrongPassword: userHasStrongPassword,
        };
    }
    function deserializeCollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        if (!(val.enterprise_has_two_factor_auth_enabled == void 0) &&
            !sdIsBoolean(val.enterprise_has_two_factor_auth_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "enterprise_has_two_factor_auth_enabled" of type "CollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        const enterpriseHasTwoFactorAuthEnabled = val.enterprise_has_two_factor_auth_enabled == void 0
            ? void 0
            : val.enterprise_has_two_factor_auth_enabled;
        if (!(val.user_has_two_factor_authentication_enabled == void 0) &&
            !sdIsBoolean(val.user_has_two_factor_authentication_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "user_has_two_factor_authentication_enabled" of type "CollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        const userHasTwoFactorAuthenticationEnabled = val.user_has_two_factor_authentication_enabled == void 0
            ? void 0
            : val.user_has_two_factor_authentication_enabled;
        return {
            enterpriseHasTwoFactorAuthEnabled: enterpriseHasTwoFactorAuthEnabled,
            userHasTwoFactorAuthenticationEnabled: userHasTwoFactorAuthenticationEnabled,
        };
    }
    function deserializeCollaborationAcceptanceRequirementsStatusField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAcceptanceRequirementsStatusField"',
            });
        }
        const termsOfServiceRequirement = val.terms_of_service_requirement == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusTermsOfServiceRequirementField(val.terms_of_service_requirement);
        const strongPasswordRequirement = val.strong_password_requirement == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusStrongPasswordRequirementField(val.strong_password_requirement);
        const twoFactorAuthenticationRequirement = val.two_factor_authentication_requirement == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField(val.two_factor_authentication_requirement);
        return {
            termsOfServiceRequirement: termsOfServiceRequirement,
            strongPasswordRequirement: strongPasswordRequirement,
            twoFactorAuthenticationRequirement: twoFactorAuthenticationRequirement,
        };
    }
    function deserializeCollaboration(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collaboration"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "Collaboration" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Collaboration"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "Collaboration" to be defined',
            });
        }
        const type = deserializeCollaborationTypeField(val.type);
        const item = val.item == void 0 ? void 0 : deserializeFileOrFolderOrWebLink(val.item);
        const appItem = val.app_item == void 0 ? void 0 : deserializeAppItem(val.app_item);
        const accessibleBy = val.accessible_by == void 0
            ? void 0
            : deserializeGroupMiniOrUserCollaborations(val.accessible_by);
        if (!(val.invite_email == void 0) && !sdIsString(val.invite_email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "invite_email" of type "Collaboration"',
            });
        }
        const inviteEmail = val.invite_email == void 0 ? void 0 : val.invite_email;
        const role = val.role == void 0 ? void 0 : deserializeCollaborationRoleField(val.role);
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "Collaboration"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        if (!(val.is_access_only == void 0) && !sdIsBoolean(val.is_access_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_access_only" of type "Collaboration"',
            });
        }
        const isAccessOnly = val.is_access_only == void 0 ? void 0 : val.is_access_only;
        const status = val.status == void 0
            ? void 0
            : deserializeCollaborationStatusField(val.status);
        if (!(val.acknowledged_at == void 0) && !sdIsString(val.acknowledged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "acknowledged_at" of type "Collaboration"',
            });
        }
        const acknowledgedAt = val.acknowledged_at == void 0
            ? void 0
            : dateTimeFromString(val.acknowledged_at);
        const createdBy = val.created_by == void 0
            ? void 0
            : deserializeUserCollaborations(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Collaboration"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "Collaboration"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        const acceptanceRequirementsStatus = val.acceptance_requirements_status == void 0
            ? void 0
            : deserializeCollaborationAcceptanceRequirementsStatusField(val.acceptance_requirements_status);
        return {
            id: id,
            type: type,
            item: item,
            appItem: appItem,
            accessibleBy: accessibleBy,
            inviteEmail: inviteEmail,
            role: role,
            expiresAt: expiresAt,
            isAccessOnly: isAccessOnly,
            status: status,
            acknowledgedAt: acknowledgedAt,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            acceptanceRequirementsStatus: acceptanceRequirementsStatus,
        };
    }

    function deserializeCollaborations(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collaborations"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Collaborations"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Collaborations"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Collaborations"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Collaborations"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollaboration(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function deserializeCollaborationsOffsetPaginated(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationsOffsetPaginated"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "CollaborationsOffsetPaginated"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "CollaborationsOffsetPaginated"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "CollaborationsOffsetPaginated"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "CollaborationsOffsetPaginated"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollaboration(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            entries: entries,
        };
    }

    class GetFileCollaborationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderCollaborationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFolderCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationsOptionals {
        constructor(fields) {
            this.headers = new GetCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupCollaborationsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupCollaborationsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileCollaborationsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFolderCollaborationsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollaborationsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupCollaborationsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ListCollaborationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves a list of pending and active collaborations for a
           * file. This returns all the users that have access to the file
           * or have been invited to the file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileCollaborationsOptionalsInput} optionalsInput
           * @returns {Promise<Collaborations>}
           */
        getFileCollaborations(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileCollaborationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/collaborations'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborations(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a list of pending and active collaborations for a
           * folder. This returns all the users that have access to the folder
           * or have been invited to the folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          Example: "12345"
           * @param {GetFolderCollaborationsOptionalsInput} optionalsInput
           * @returns {Promise<Collaborations>}
           */
        getFolderCollaborations(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderCollaborationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/collaborations'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborations(response.data)), { rawData: response.data });
            });
        }
        /**
         * Retrieves all pending collaboration invites for this user.
         * @param {GetCollaborationsQueryParams} queryParams Query parameters of getCollaborations method
         * @param {GetCollaborationsOptionalsInput} optionalsInput
         * @returns {Promise<CollaborationsOffsetPaginated>}
         */
        getCollaborations(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetCollaborationsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['status']: toString(queryParams.status),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationsOffsetPaginated(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves all the collaborations for a group. The user
           * must have admin permissions to inspect enterprise's groups.
           *
           * Each collaboration object has details on which files or
           * folders the group has access to and with what role.
           * @param {string} groupId The ID of the group.
          Example: "57645"
           * @param {GetGroupCollaborationsOptionalsInput} optionalsInput
           * @returns {Promise<CollaborationsOffsetPaginated>}
           */
        getGroupCollaborations(groupId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new GetGroupCollaborationsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId), '/collaborations'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationsOffsetPaginated(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeCommentBaseTypeField(val) {
        if (val == 'comment') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize CommentBaseTypeField" });
    }

    function deserializeCommentItemField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CommentItemField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CommentItemField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "CommentItemField"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        return { id: id, type: type };
    }

    function deserializeCommentFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "CommentFull"' });
        }
        if (!(val.tagged_message == void 0) && !sdIsString(val.tagged_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "tagged_message" of type "CommentFull"',
            });
        }
        const taggedMessage = val.tagged_message == void 0 ? void 0 : val.tagged_message;
        if (!(val.is_reply_comment == void 0) && !sdIsBoolean(val.is_reply_comment)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_reply_comment" of type "CommentFull"',
            });
        }
        const isReplyComment = val.is_reply_comment == void 0 ? void 0 : val.is_reply_comment;
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "CommentFull"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "CommentFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "CommentFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        const item = val.item == void 0 ? void 0 : deserializeCommentItemField(val.item);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CommentFull"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeCommentBaseTypeField(val.type);
        return {
            taggedMessage: taggedMessage,
            isReplyComment: isReplyComment,
            message: message,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            item: item,
            id: id,
            type: type,
        };
    }

    function deserializeCommentsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CommentsOrderDirectionField",
        });
    }
    function deserializeCommentsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CommentsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "CommentsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeCommentsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeComments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Comments"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Comments"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Comments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Comments"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Comments"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeCommentsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Comments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCommentFull(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetFileCommentsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileCommentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCommentByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetCommentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateCommentByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateCommentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCommentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCommentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateCommentOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateCommentHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileCommentsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCommentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateCommentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCommentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCommentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CommentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves a list of comments for a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileCommentsOptionalsInput} optionalsInput
           * @returns {Promise<Comments>}
           */
        getFileComments(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileCommentsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/comments'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeComments(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves the message and metadata for a specific comment, as well
           * as information on the user who created the comment.
           * @param {string} commentId The ID of the comment.
          Example: "12345"
           * @param {GetCommentByIdOptionalsInput} optionalsInput
           * @returns {Promise<CommentFull>}
           */
        getCommentById(commentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (commentId, optionalsInput = {}) {
                const optionals = new GetCommentByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments/', toString(commentId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCommentFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Update the message of a comment.
           * @param {string} commentId The ID of the comment.
          Example: "12345"
           * @param {UpdateCommentByIdOptionalsInput} optionalsInput
           * @returns {Promise<CommentFull>}
           */
        updateCommentById(commentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (commentId, optionalsInput = {}) {
                const optionals = new UpdateCommentByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments/', toString(commentId)),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateCommentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCommentFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Permanently deletes a comment.
           * @param {string} commentId The ID of the comment.
          Example: "12345"
           * @param {DeleteCommentByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteCommentById(commentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (commentId, optionalsInput = {}) {
                const optionals = new DeleteCommentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments/', toString(commentId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
         * Adds a comment by the user to a specific file, or
         * as a reply to an other comment.
         * @param {CreateCommentRequestBody} requestBody Request body of createComment method
         * @param {CreateCommentOptionalsInput} optionalsInput
         * @returns {Promise<CommentFull>}
         */
        createComment(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCommentOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/comments'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateCommentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCommentFull(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUpdateCommentByIdRequestBody(val) {
        return { ['message']: val.message };
    }
    function serializeCreateCommentRequestBodyItemTypeField(val) {
        return val;
    }
    function serializeCreateCommentRequestBodyItemField(val) {
        return {
            ['id']: val.id,
            ['type']: serializeCreateCommentRequestBodyItemTypeField(val.type),
        };
    }
    function serializeCreateCommentRequestBody(val) {
        return {
            ['message']: val.message,
            ['tagged_message']: val.taggedMessage,
            ['item']: serializeCreateCommentRequestBodyItemField(val.item),
        };
    }

    function deserializeTaskAssignmentTypeField(val) {
        if (val == 'task_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TaskAssignmentTypeField",
        });
    }
    function deserializeTaskAssignmentResolutionStateField(val) {
        if (val == 'completed') {
            return val;
        }
        if (val == 'incomplete') {
            return val;
        }
        if (val == 'approved') {
            return val;
        }
        if (val == 'rejected') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TaskAssignmentResolutionStateField",
        });
    }
    function deserializeTaskAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TaskAssignment"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TaskAssignment"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeTaskAssignmentTypeField(val.type);
        const item = val.item == void 0 ? void 0 : deserializeFileMini(val.item);
        const assignedTo = val.assigned_to == void 0 ? void 0 : deserializeUserMini(val.assigned_to);
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "TaskAssignment"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        if (!(val.completed_at == void 0) && !sdIsString(val.completed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "completed_at" of type "TaskAssignment"',
            });
        }
        const completedAt = val.completed_at == void 0 ? void 0 : dateTimeFromString(val.completed_at);
        if (!(val.assigned_at == void 0) && !sdIsString(val.assigned_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "assigned_at" of type "TaskAssignment"',
            });
        }
        const assignedAt = val.assigned_at == void 0 ? void 0 : dateTimeFromString(val.assigned_at);
        if (!(val.reminded_at == void 0) && !sdIsString(val.reminded_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "reminded_at" of type "TaskAssignment"',
            });
        }
        const remindedAt = val.reminded_at == void 0 ? void 0 : dateTimeFromString(val.reminded_at);
        const resolutionState = val.resolution_state == void 0
            ? void 0
            : deserializeTaskAssignmentResolutionStateField(val.resolution_state);
        const assignedBy = val.assigned_by == void 0 ? void 0 : deserializeUserMini(val.assigned_by);
        return {
            id: id,
            type: type,
            item: item,
            assignedTo: assignedTo,
            message: message,
            completedAt: completedAt,
            assignedAt: assignedAt,
            remindedAt: remindedAt,
            resolutionState: resolutionState,
            assignedBy: assignedBy,
        };
    }

    function deserializeTaskAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TaskAssignments"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TaskAssignments"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TaskAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTaskAssignment(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    function deserializeTaskTypeField(val) {
        if (val == 'task') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TaskTypeField" });
    }
    function deserializeTaskActionField(val) {
        if (val == 'review') {
            return val;
        }
        if (val == 'complete') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TaskActionField" });
    }
    function deserializeTaskCompletionRuleField(val) {
        if (val == 'all_assignees') {
            return val;
        }
        if (val == 'any_assignee') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TaskCompletionRuleField",
        });
    }
    function deserializeTask(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Task"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Task"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeTaskTypeField(val.type);
        const item = val.item == void 0 ? void 0 : deserializeFileMini(val.item);
        if (!(val.due_at == void 0) && !sdIsString(val.due_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "due_at" of type "Task"',
            });
        }
        const dueAt = val.due_at == void 0 ? void 0 : dateTimeFromString(val.due_at);
        const action = val.action == void 0 ? void 0 : deserializeTaskActionField(val.action);
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "Task"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        const taskAssignmentCollection = val.task_assignment_collection == void 0
            ? void 0
            : deserializeTaskAssignments(val.task_assignment_collection);
        if (!(val.is_completed == void 0) && !sdIsBoolean(val.is_completed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_completed" of type "Task"',
            });
        }
        const isCompleted = val.is_completed == void 0 ? void 0 : val.is_completed;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Task"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const completionRule = val.completion_rule == void 0
            ? void 0
            : deserializeTaskCompletionRuleField(val.completion_rule);
        return {
            id: id,
            type: type,
            item: item,
            dueAt: dueAt,
            action: action,
            message: message,
            taskAssignmentCollection: taskAssignmentCollection,
            isCompleted: isCompleted,
            createdBy: createdBy,
            createdAt: createdAt,
            completionRule: completionRule,
        };
    }

    function deserializeTasks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Tasks"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Tasks"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Tasks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTask(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    class GetFileTasksOptionals {
        constructor(fields) {
            this.headers = new GetFileTasksHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateTaskOptionals {
        constructor(fields) {
            this.headers = new CreateTaskHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTaskByIdOptionals {
        constructor(fields) {
            this.headers = new GetTaskByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTaskByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateTaskByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTaskByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTaskByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileTasksHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTaskHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTaskByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTaskByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTaskByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TasksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves a list of all the tasks for a file. This
           * endpoint does not support pagination.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileTasksOptionalsInput} optionalsInput
           * @returns {Promise<Tasks>}
           */
        getFileTasks(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileTasksOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/tasks'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTasks(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a single task on a file. This task is not assigned to any user and
         * will need to be assigned separately.
         * @param {CreateTaskRequestBody} requestBody Request body of createTask method
         * @param {CreateTaskOptionalsInput} optionalsInput
         * @returns {Promise<Task>}
         */
        createTask(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTaskOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTaskRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTask(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves information about a specific task.
           * @param {string} taskId The ID of the task.
          Example: "12345"
           * @param {GetTaskByIdOptionalsInput} optionalsInput
           * @returns {Promise<Task>}
           */
        getTaskById(taskId_1) {
            return __awaiter$1(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new GetTaskByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTask(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a task. This can be used to update a task's configuration, or to
           * update its completion state.
           * @param {string} taskId The ID of the task.
          Example: "12345"
           * @param {UpdateTaskByIdOptionalsInput} optionalsInput
           * @returns {Promise<Task>}
           */
        updateTaskById(taskId_1) {
            return __awaiter$1(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new UpdateTaskByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTaskByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTask(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes a task from a file.
           * @param {string} taskId The ID of the task.
          Example: "12345"
           * @param {DeleteTaskByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteTaskById(taskId_1) {
            return __awaiter$1(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new DeleteTaskByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateTaskRequestBodyItemTypeField(val) {
        return val;
    }
    function serializeCreateTaskRequestBodyItemField(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeCreateTaskRequestBodyItemTypeField(val.type),
        };
    }
    function serializeCreateTaskRequestBodyActionField(val) {
        return val;
    }
    function serializeCreateTaskRequestBodyCompletionRuleField(val) {
        return val;
    }
    function serializeCreateTaskRequestBody(val) {
        return {
            ['item']: serializeCreateTaskRequestBodyItemField(val.item),
            ['action']: val.action == void 0
                ? val.action
                : serializeCreateTaskRequestBodyActionField(val.action),
            ['message']: val.message,
            ['due_at']: val.dueAt == void 0 ? val.dueAt : dateTimeToString(val.dueAt),
            ['completion_rule']: val.completionRule == void 0
                ? val.completionRule
                : serializeCreateTaskRequestBodyCompletionRuleField(val.completionRule),
        };
    }
    function serializeUpdateTaskByIdRequestBodyActionField(val) {
        return val;
    }
    function serializeUpdateTaskByIdRequestBodyCompletionRuleField(val) {
        return val;
    }
    function serializeUpdateTaskByIdRequestBody(val) {
        return {
            ['action']: val.action == void 0
                ? val.action
                : serializeUpdateTaskByIdRequestBodyActionField(val.action),
            ['message']: val.message,
            ['due_at']: val.dueAt == void 0 ? val.dueAt : dateTimeToString(val.dueAt),
            ['completion_rule']: val.completionRule == void 0
                ? val.completionRule
                : serializeUpdateTaskByIdRequestBodyCompletionRuleField(val.completionRule),
        };
    }

    function deserializeFileVersionFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileVersionFull"' });
        }
        if (!(val.version_number == void 0) && !sdIsString(val.version_number)) {
            throw new BoxSdkError({
                message: 'Expecting string for "version_number" of type "FileVersionFull"',
            });
        }
        const versionNumber = val.version_number == void 0 ? void 0 : val.version_number;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FileVersionFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "FileVersionFull"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileVersionFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "FileVersionFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "FileVersionFull"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        const trashedBy = val.trashed_by == void 0 ? void 0 : deserializeUserMini(val.trashed_by);
        if (!(val.restored_at == void 0) && !sdIsString(val.restored_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "restored_at" of type "FileVersionFull"',
            });
        }
        const restoredAt = val.restored_at == void 0 ? void 0 : dateTimeFromString(val.restored_at);
        const restoredBy = val.restored_by == void 0 ? void 0 : deserializeUserMini(val.restored_by);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "FileVersionFull"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.uploader_display_name == void 0) &&
            !sdIsString(val.uploader_display_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "uploader_display_name" of type "FileVersionFull"',
            });
        }
        const uploaderDisplayName = val.uploader_display_name == void 0 ? void 0 : val.uploader_display_name;
        if (!(val.sha1 == void 0) && !sdIsString(val.sha1)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sha1" of type "FileVersionFull"',
            });
        }
        const sha1 = val.sha1 == void 0 ? void 0 : val.sha1;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileVersionFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionFull"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileVersionFull" to be defined',
            });
        }
        const type = deserializeFileVersionBaseTypeField(val.type);
        return {
            versionNumber: versionNumber,
            name: name,
            size: size,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            trashedBy: trashedBy,
            restoredAt: restoredAt,
            restoredBy: restoredBy,
            purgedAt: purgedAt,
            uploaderDisplayName: uploaderDisplayName,
            sha1: sha1,
            id: id,
            type: type,
        };
    }

    function deserializeFileVersionsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionsOrderDirectionField",
        });
    }
    function deserializeFileVersionsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "FileVersionsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeFileVersionsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeFileVersions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileVersions"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "FileVersions"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FileVersions"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "FileVersions"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "FileVersions"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeFileVersionsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileVersions"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileVersionFull(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetFileVersionsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileVersionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFileVersionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileVersionByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileVersionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileVersionByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateFileVersionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class PromoteFileVersionOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new PromoteFileVersionHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileVersionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileVersionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileVersionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class PromoteFileVersionHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileVersionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieve a list of the past versions for a file.
           *
           * Versions are only tracked by Box users with premium accounts. To fetch the ID
           * of the current version of a file, use the `GET /file/:id` API.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileVersionsOptionalsInput} optionalsInput
           * @returns {Promise<FileVersions>}
           */
        getFileVersions(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileVersionsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersions(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieve a specific version of a file.
           *
           * Versions are only tracked for Box users with premium accounts.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {string} fileVersionId The ID of the file version.
          Example: "1234"
           * @param {GetFileVersionByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileVersionFull>}
           */
        getFileVersionById(fileId_1, fileVersionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, fileVersionId, optionalsInput = {}) {
                const optionals = new GetFileVersionByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/', toString(fileVersionId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersionFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Move a file version to the trash.
           *
           * Versions are only tracked for Box users with premium accounts.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {string} fileVersionId The ID of the file version.
          Example: "1234"
           * @param {DeleteFileVersionByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFileVersionById(fileId_1, fileVersionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, fileVersionId, optionalsInput = {}) {
                const optionals = new DeleteFileVersionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/', toString(fileVersionId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Restores a specific version of a file after it was deleted.
           * Don't use this endpoint to restore Box Notes,
           * as it works with file formats such as PDF, DOC,
           * PPTX or similar.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {string} fileVersionId The ID of the file version.
          Example: "1234"
           * @param {UpdateFileVersionByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileVersionFull>}
           */
        updateFileVersionById(fileId_1, fileVersionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, fileVersionId, optionalsInput = {}) {
                const optionals = new UpdateFileVersionByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/', toString(fileVersionId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateFileVersionByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersionFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Promote a specific version of a file.
           *
           * If previous versions exist, this method can be used to
           * promote one of the older versions to the top of the version history.
           *
           * This creates a new copy of the old version and puts it at the
           * top of the versions history. The file will have the exact same contents
           * as the older version, with the the same hash digest, `etag`, and
           * name as the original.
           *
           * Other properties such as comments do not get updated to their
           * former values.
           *
           * Don't use this endpoint to restore Box Notes,
           * as it works with file formats such as PDF, DOC,
           * PPTX or similar.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {PromoteFileVersionOptionalsInput} optionalsInput
           * @returns {Promise<FileVersionFull>}
           */
        promoteFileVersion(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new PromoteFileVersionOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/versions/current'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializePromoteFileVersionRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersionFull(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUpdateFileVersionByIdRequestBody(val) {
        return { ['trashed_at']: val.trashedAt };
    }
    function serializePromoteFileVersionRequestBodyTypeField(val) {
        return val;
    }
    function serializePromoteFileVersionRequestBody(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializePromoteFileVersionRequestBodyTypeField(val.type),
        };
    }

    function deserializeMetadatas(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Metadatas"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Metadatas"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeMetadata(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Metadatas"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        return { entries: entries, limit: limit };
    }

    function serializeMetadataInstanceValue(val) {
        return val;
    }

    class GetFileMetadataOptionals {
        constructor(fields) {
            this.headers = new GetFileMetadataHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new CreateFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileMetadataHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileMetadataManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves all metadata for a given file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileMetadataOptionalsInput} optionalsInput
           * @returns {Promise<Metadatas>}
           */
        getFileMetadata(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileMetadataOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadatas(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves the instance of a metadata template that has been applied to a
           * file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {GetFileMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataFull>}
           */
        getFileMetadataById(fileId_1, scope_1, templateKey_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, scope, templateKey, optionalsInput = {}) {
                const optionals = new GetFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Applies an instance of a metadata template to a file.
           *
           * In most cases only values that are present in the metadata template
           * will be accepted, except for the `global.properties` template which accepts
           * any key-value pair.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {CreateFileMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {CreateFileMetadataByIdRequestBody} requestBody Request body of createFileMetadataById method
           * @param {CreateFileMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataFull>}
           */
        createFileMetadataById(fileId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new CreateFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFileMetadataByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a piece of metadata on a file.
           *
           * The metadata instance can only be updated if the template has already been
           * applied to the file before. When editing metadata, only values that match
           * the metadata template schema will be accepted.
           *
           * The update is applied atomically. If any errors occur during the
           * application of the operations, the metadata instance will not be changed.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {UpdateFileMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {readonly UpdateFileMetadataByIdRequestBody[]} requestBody Request body of updateFileMetadataById method
           * @param {UpdateFileMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataFull>}
           */
        updateFileMetadataById(fileId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateFileMetadataByIdRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a piece of file metadata.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {DeleteFileMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {DeleteFileMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFileMetadataById(fileId_1, scope_1, templateKey_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, scope, templateKey, optionalsInput = {}) {
                const optionals = new DeleteFileMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateFileMetadataByIdRequestBody(val) {
        return Object.fromEntries(Object.entries(val).map(([k, v]) => [
            k,
            (function (v) {
                return v;
            })(v),
        ]));
    }
    function serializeUpdateFileMetadataByIdRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateFileMetadataByIdRequestBody(val) {
        return {
            ['op']: val.op == void 0
                ? val.op
                : serializeUpdateFileMetadataByIdRequestBodyOpField(val.op),
            ['path']: val.path,
            ['value']: val.value == void 0
                ? val.value
                : serializeMetadataInstanceValue(val.value),
            ['from']: val.from,
        };
    }

    function deserializeClassificationTemplateField(val) {
        if (val == 'securityClassification-6VMVochwUWo') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateField",
        });
    }
    function deserializeClassification(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Classification"' });
        }
        if (!(val.Box__Security__Classification__Key == void 0) &&
            !sdIsString(val.Box__Security__Classification__Key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "Box__Security__Classification__Key" of type "Classification"',
            });
        }
        const boxSecurityClassificationKey = val.Box__Security__Classification__Key == void 0
            ? void 0
            : val.Box__Security__Classification__Key;
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "Classification"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        const template = val.$template == void 0
            ? void 0
            : deserializeClassificationTemplateField(val.$template);
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "Classification"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "Classification"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        if (!(val.$type == void 0) && !sdIsString(val.$type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$type" of type "Classification"',
            });
        }
        const type = val.$type == void 0 ? void 0 : val.$type;
        if (!(val.$typeVersion == void 0) && !sdIsNumber(val.$typeVersion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$typeVersion" of type "Classification"',
            });
        }
        const typeVersion = val.$typeVersion == void 0 ? void 0 : val.$typeVersion;
        if (!(val.$canEdit == void 0) && !sdIsBoolean(val.$canEdit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "$canEdit" of type "Classification"',
            });
        }
        const canEdit = val.$canEdit == void 0 ? void 0 : val.$canEdit;
        return {
            boxSecurityClassificationKey: boxSecurityClassificationKey,
            parent: parent,
            template: template,
            scope: scope,
            version: version,
            type: type,
            typeVersion: typeVersion,
            canEdit: canEdit,
        };
    }

    class GetClassificationOnFileOptionals {
        constructor(fields) {
            this.headers = new GetClassificationOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddClassificationToFileOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new AddClassificationToFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateClassificationOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateClassificationOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteClassificationFromFileOptionals {
        constructor(fields) {
            this.headers = new DeleteClassificationFromFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetClassificationOnFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddClassificationToFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateClassificationOnFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteClassificationFromFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileClassificationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves the classification metadata instance that
           * has been applied to a file.
           *
           * This API can also be called by including the enterprise ID in the
           * URL explicitly, for example
           * `/files/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetClassificationOnFileOptionalsInput} optionalsInput
           * @returns {Promise<Classification>}
           */
        getClassificationOnFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetClassificationOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassification(response.data)), { rawData: response.data });
            });
        }
        /**
           * Adds a classification to a file by specifying the label of the
           * classification to add.
           *
           * This API can also be called by including the enterprise ID in the
           * URL explicitly, for example
           * `/files/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {AddClassificationToFileOptionalsInput} optionalsInput
           * @returns {Promise<Classification>}
           */
        addClassificationToFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new AddClassificationToFileOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAddClassificationToFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassification(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a classification on a file.
           *
           * The classification can only be updated if a classification has already been
           * applied to the file before. When editing classifications, only values are
           * defined for the enterprise will be accepted.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {readonly UpdateClassificationOnFileRequestBody[]} requestBody Request body of updateClassificationOnFile method
           * @param {UpdateClassificationOnFileOptionalsInput} optionalsInput
           * @returns {Promise<Classification>}
           */
        updateClassificationOnFile(fileId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateClassificationOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateClassificationOnFileRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassification(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes any classifications from a file.
           *
           * This API can also be called by including the enterprise ID in the
           * URL explicitly, for example
           * `/files/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {DeleteClassificationFromFileOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteClassificationFromFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteClassificationFromFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeAddClassificationToFileRequestBody(val) {
        return {
            ['Box__Security__Classification__Key']: val.boxSecurityClassificationKey,
        };
    }
    function serializeUpdateClassificationOnFileRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFileRequestBodyPathField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFileRequestBody(val) {
        return {
            ['op']: serializeUpdateClassificationOnFileRequestBodyOpField(val.op),
            ['path']: serializeUpdateClassificationOnFileRequestBodyPathField(val.path),
            ['value']: val.value,
        };
    }

    function serializeKeywordSkillCardTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardTypeField",
        });
    }
    function serializeKeywordSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardSkillCardTypeField(val) {
        if (val == 'keyword') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardSkillCardTypeField",
        });
    }
    function serializeKeywordSkillCardSkillCardTitleField(val) {
        return { ['code']: val.code, ['message']: val.message };
    }
    function deserializeKeywordSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "KeywordSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "KeywordSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "KeywordSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeKeywordSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardSkillTypeField",
        });
    }
    function serializeKeywordSkillCardSkillField(val) {
        return {
            ['type']: serializeKeywordSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeKeywordSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "KeywordSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeKeywordSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "KeywordSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "KeywordSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeKeywordSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeKeywordSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardInvocationTypeField",
        });
    }
    function serializeKeywordSkillCardInvocationField(val) {
        return {
            ['type']: serializeKeywordSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeKeywordSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "KeywordSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeKeywordSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "KeywordSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "KeywordSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeKeywordSkillCardEntriesField(val) {
        return { ['text']: val.text };
    }
    function deserializeKeywordSkillCardEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardEntriesField"',
            });
        }
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "KeywordSkillCardEntriesField"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        return { text: text };
    }
    function serializeKeywordSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0
                ? val.createdAt
                : dateTimeToString(val.createdAt),
            ['type']: serializeKeywordSkillCardTypeField(val.type),
            ['skill_card_type']: serializeKeywordSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? val.skillCardTitle
                : serializeKeywordSkillCardSkillCardTitleField(val.skillCardTitle),
            ['skill']: serializeKeywordSkillCardSkillField(val.skill),
            ['invocation']: serializeKeywordSkillCardInvocationField(val.invocation),
            ['entries']: val.entries.map(function (item) {
                return serializeKeywordSkillCardEntriesField(item);
            }),
        };
    }
    function deserializeKeywordSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCard"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "KeywordSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "KeywordSkillCard" to be defined',
            });
        }
        const type = deserializeKeywordSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "KeywordSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeKeywordSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeKeywordSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "KeywordSkillCard" to be defined',
            });
        }
        const skill = deserializeKeywordSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "KeywordSkillCard" to be defined',
            });
        }
        const invocation = deserializeKeywordSkillCardInvocationField(val.invocation);
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "KeywordSkillCard" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "KeywordSkillCard"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeKeywordSkillCardEntriesField(itm);
            })
            : [];
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            skill: skill,
            invocation: invocation,
            entries: entries,
        };
    }

    function serializeStatusSkillCardTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardTypeField",
        });
    }
    function serializeStatusSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardSkillCardTypeField(val) {
        if (val == 'status') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardSkillCardTypeField",
        });
    }
    function serializeStatusSkillCardSkillCardTitleField(val) {
        return { ['code']: val.code, ['message']: val.message };
    }
    function deserializeStatusSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "StatusSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "StatusSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "StatusSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeStatusSkillCardStatusCodeField(val) {
        return val;
    }
    function deserializeStatusSkillCardStatusCodeField(val) {
        if (val == 'invoked') {
            return val;
        }
        if (val == 'processing') {
            return val;
        }
        if (val == 'success') {
            return val;
        }
        if (val == 'transient_failure') {
            return val;
        }
        if (val == 'permanent_failure') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardStatusCodeField",
        });
    }
    function serializeStatusSkillCardStatusField(val) {
        return {
            ['code']: serializeStatusSkillCardStatusCodeField(val.code),
            ['message']: val.message,
        };
    }
    function deserializeStatusSkillCardStatusField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardStatusField"',
            });
        }
        if (val.code == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "code" of type "StatusSkillCardStatusField" to be defined',
            });
        }
        const code = deserializeStatusSkillCardStatusCodeField(val.code);
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "StatusSkillCardStatusField"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        return { code: code, message: message };
    }
    function serializeStatusSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardSkillTypeField",
        });
    }
    function serializeStatusSkillCardSkillField(val) {
        return {
            ['type']: serializeStatusSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeStatusSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StatusSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeStatusSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StatusSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StatusSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeStatusSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeStatusSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StatusSkillCardInvocationTypeField",
        });
    }
    function serializeStatusSkillCardInvocationField(val) {
        return {
            ['type']: serializeStatusSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeStatusSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StatusSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StatusSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeStatusSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StatusSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StatusSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeStatusSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0
                ? val.createdAt
                : dateTimeToString(val.createdAt),
            ['type']: serializeStatusSkillCardTypeField(val.type),
            ['skill_card_type']: serializeStatusSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? val.skillCardTitle
                : serializeStatusSkillCardSkillCardTitleField(val.skillCardTitle),
            ['status']: serializeStatusSkillCardStatusField(val.status),
            ['skill']: serializeStatusSkillCardSkillField(val.skill),
            ['invocation']: serializeStatusSkillCardInvocationField(val.invocation),
        };
    }
    function deserializeStatusSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "StatusSkillCard"' });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "StatusSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StatusSkillCard" to be defined',
            });
        }
        const type = deserializeStatusSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "StatusSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeStatusSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeStatusSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "status" of type "StatusSkillCard" to be defined',
            });
        }
        const status = deserializeStatusSkillCardStatusField(val.status);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "StatusSkillCard" to be defined',
            });
        }
        const skill = deserializeStatusSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "StatusSkillCard" to be defined',
            });
        }
        const invocation = deserializeStatusSkillCardInvocationField(val.invocation);
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            status: status,
            skill: skill,
            invocation: invocation,
        };
    }

    function serializeTimelineSkillCardTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardTypeField",
        });
    }
    function serializeTimelineSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardSkillCardTypeField(val) {
        if (val == 'timeline') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardSkillCardTypeField",
        });
    }
    function serializeTimelineSkillCardSkillCardTitleField(val) {
        return { ['code']: val.code, ['message']: val.message };
    }
    function deserializeTimelineSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "TimelineSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "TimelineSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "TimelineSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeTimelineSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardSkillTypeField",
        });
    }
    function serializeTimelineSkillCardSkillField(val) {
        return {
            ['type']: serializeTimelineSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTimelineSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TimelineSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeTimelineSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TimelineSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TimelineSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTimelineSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeTimelineSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TimelineSkillCardInvocationTypeField",
        });
    }
    function serializeTimelineSkillCardInvocationField(val) {
        return {
            ['type']: serializeTimelineSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTimelineSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TimelineSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeTimelineSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TimelineSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TimelineSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTimelineSkillCardEntriesAppearsField(val) {
        return { ['start']: val.start, ['end']: val.end };
    }
    function deserializeTimelineSkillCardEntriesAppearsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardEntriesAppearsField"',
            });
        }
        if (!(val.start == void 0) && !sdIsNumber(val.start)) {
            throw new BoxSdkError({
                message: 'Expecting number for "start" of type "TimelineSkillCardEntriesAppearsField"',
            });
        }
        const start = val.start == void 0 ? void 0 : val.start;
        if (!(val.end == void 0) && !sdIsNumber(val.end)) {
            throw new BoxSdkError({
                message: 'Expecting number for "end" of type "TimelineSkillCardEntriesAppearsField"',
            });
        }
        const end = val.end == void 0 ? void 0 : val.end;
        return {
            start: start,
            end: end,
        };
    }
    function serializeTimelineSkillCardEntriesField(val) {
        return {
            ['text']: val.text,
            ['appears']: val.appears == void 0
                ? val.appears
                : val.appears.map(function (item) {
                    return serializeTimelineSkillCardEntriesAppearsField(item);
                }),
            ['image_url']: val.imageUrl,
        };
    }
    function deserializeTimelineSkillCardEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCardEntriesField"',
            });
        }
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "TimelineSkillCardEntriesField"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        if (!(val.appears == void 0) && !sdIsList(val.appears)) {
            throw new BoxSdkError({
                message: 'Expecting array for "appears" of type "TimelineSkillCardEntriesField"',
            });
        }
        const appears = val.appears == void 0
            ? void 0
            : sdIsList(val.appears)
                ? val.appears.map(function (itm) {
                    return deserializeTimelineSkillCardEntriesAppearsField(itm);
                })
                : [];
        if (!(val.image_url == void 0) && !sdIsString(val.image_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "image_url" of type "TimelineSkillCardEntriesField"',
            });
        }
        const imageUrl = val.image_url == void 0 ? void 0 : val.image_url;
        return {
            text: text,
            appears: appears,
            imageUrl: imageUrl,
        };
    }
    function serializeTimelineSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0
                ? val.createdAt
                : dateTimeToString(val.createdAt),
            ['type']: serializeTimelineSkillCardTypeField(val.type),
            ['skill_card_type']: serializeTimelineSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? val.skillCardTitle
                : serializeTimelineSkillCardSkillCardTitleField(val.skillCardTitle),
            ['skill']: serializeTimelineSkillCardSkillField(val.skill),
            ['invocation']: serializeTimelineSkillCardInvocationField(val.invocation),
            ['duration']: val.duration,
            ['entries']: val.entries.map(function (item) {
                return serializeTimelineSkillCardEntriesField(item);
            }),
        };
    }
    function deserializeTimelineSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TimelineSkillCard"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TimelineSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TimelineSkillCard" to be defined',
            });
        }
        const type = deserializeTimelineSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "TimelineSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeTimelineSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeTimelineSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "TimelineSkillCard" to be defined',
            });
        }
        const skill = deserializeTimelineSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "TimelineSkillCard" to be defined',
            });
        }
        const invocation = deserializeTimelineSkillCardInvocationField(val.invocation);
        if (!(val.duration == void 0) && !sdIsNumber(val.duration)) {
            throw new BoxSdkError({
                message: 'Expecting number for "duration" of type "TimelineSkillCard"',
            });
        }
        const duration = val.duration == void 0 ? void 0 : val.duration;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TimelineSkillCard" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TimelineSkillCard"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTimelineSkillCardEntriesField(itm);
            })
            : [];
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            skill: skill,
            invocation: invocation,
            duration: duration,
            entries: entries,
        };
    }

    function serializeTranscriptSkillCardTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardTypeField(val) {
        if (val == 'skill_card') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardTypeField",
        });
    }
    function serializeTranscriptSkillCardSkillCardTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardSkillCardTypeField(val) {
        if (val == 'transcript') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardSkillCardTypeField",
        });
    }
    function serializeTranscriptSkillCardSkillCardTitleField(val) {
        return { ['code']: val.code, ['message']: val.message };
    }
    function deserializeTranscriptSkillCardSkillCardTitleField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardSkillCardTitleField"',
            });
        }
        if (!(val.code == void 0) && !sdIsString(val.code)) {
            throw new BoxSdkError({
                message: 'Expecting string for "code" of type "TranscriptSkillCardSkillCardTitleField"',
            });
        }
        const code = val.code == void 0 ? void 0 : val.code;
        if (val.message == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "message" of type "TranscriptSkillCardSkillCardTitleField" to be defined',
            });
        }
        if (!sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "TranscriptSkillCardSkillCardTitleField"',
            });
        }
        const message = val.message;
        return {
            code: code,
            message: message,
        };
    }
    function serializeTranscriptSkillCardSkillTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardSkillTypeField(val) {
        if (val == 'service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardSkillTypeField",
        });
    }
    function serializeTranscriptSkillCardSkillField(val) {
        return {
            ['type']: serializeTranscriptSkillCardSkillTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTranscriptSkillCardSkillField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardSkillField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TranscriptSkillCardSkillField" to be defined',
            });
        }
        const type = deserializeTranscriptSkillCardSkillTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TranscriptSkillCardSkillField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TranscriptSkillCardSkillField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTranscriptSkillCardInvocationTypeField(val) {
        return val;
    }
    function deserializeTranscriptSkillCardInvocationTypeField(val) {
        if (val == 'skill_invocation') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TranscriptSkillCardInvocationTypeField",
        });
    }
    function serializeTranscriptSkillCardInvocationField(val) {
        return {
            ['type']: serializeTranscriptSkillCardInvocationTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeTranscriptSkillCardInvocationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardInvocationField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TranscriptSkillCardInvocationField" to be defined',
            });
        }
        const type = deserializeTranscriptSkillCardInvocationTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TranscriptSkillCardInvocationField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TranscriptSkillCardInvocationField"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }
    function serializeTranscriptSkillCardEntriesAppearsField(val) {
        return { ['start']: val.start };
    }
    function deserializeTranscriptSkillCardEntriesAppearsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardEntriesAppearsField"',
            });
        }
        if (!(val.start == void 0) && !sdIsNumber(val.start)) {
            throw new BoxSdkError({
                message: 'Expecting number for "start" of type "TranscriptSkillCardEntriesAppearsField"',
            });
        }
        const start = val.start == void 0 ? void 0 : val.start;
        return { start: start };
    }
    function serializeTranscriptSkillCardEntriesField(val) {
        return {
            ['text']: val.text,
            ['appears']: val.appears == void 0
                ? val.appears
                : val.appears.map(function (item) {
                    return serializeTranscriptSkillCardEntriesAppearsField(item);
                }),
        };
    }
    function deserializeTranscriptSkillCardEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCardEntriesField"',
            });
        }
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "TranscriptSkillCardEntriesField"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        if (!(val.appears == void 0) && !sdIsList(val.appears)) {
            throw new BoxSdkError({
                message: 'Expecting array for "appears" of type "TranscriptSkillCardEntriesField"',
            });
        }
        const appears = val.appears == void 0
            ? void 0
            : sdIsList(val.appears)
                ? val.appears.map(function (itm) {
                    return deserializeTranscriptSkillCardEntriesAppearsField(itm);
                })
                : [];
        return {
            text: text,
            appears: appears,
        };
    }
    function serializeTranscriptSkillCard(val) {
        return {
            ['created_at']: val.createdAt == void 0
                ? val.createdAt
                : dateTimeToString(val.createdAt),
            ['type']: serializeTranscriptSkillCardTypeField(val.type),
            ['skill_card_type']: serializeTranscriptSkillCardSkillCardTypeField(val.skillCardType),
            ['skill_card_title']: val.skillCardTitle == void 0
                ? val.skillCardTitle
                : serializeTranscriptSkillCardSkillCardTitleField(val.skillCardTitle),
            ['skill']: serializeTranscriptSkillCardSkillField(val.skill),
            ['invocation']: serializeTranscriptSkillCardInvocationField(val.invocation),
            ['duration']: val.duration,
            ['entries']: val.entries.map(function (item) {
                return serializeTranscriptSkillCardEntriesField(item);
            }),
        };
    }
    function deserializeTranscriptSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TranscriptSkillCard"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TranscriptSkillCard"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TranscriptSkillCard" to be defined',
            });
        }
        const type = deserializeTranscriptSkillCardTypeField(val.type);
        if (val.skill_card_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill_card_type" of type "TranscriptSkillCard" to be defined',
            });
        }
        const skillCardType = deserializeTranscriptSkillCardSkillCardTypeField(val.skill_card_type);
        const skillCardTitle = val.skill_card_title == void 0
            ? void 0
            : deserializeTranscriptSkillCardSkillCardTitleField(val.skill_card_title);
        if (val.skill == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "skill" of type "TranscriptSkillCard" to be defined',
            });
        }
        const skill = deserializeTranscriptSkillCardSkillField(val.skill);
        if (val.invocation == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "invocation" of type "TranscriptSkillCard" to be defined',
            });
        }
        const invocation = deserializeTranscriptSkillCardInvocationField(val.invocation);
        if (!(val.duration == void 0) && !sdIsNumber(val.duration)) {
            throw new BoxSdkError({
                message: 'Expecting number for "duration" of type "TranscriptSkillCard"',
            });
        }
        const duration = val.duration == void 0 ? void 0 : val.duration;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TranscriptSkillCard" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TranscriptSkillCard"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTranscriptSkillCardEntriesField(itm);
            })
            : [];
        return {
            createdAt: createdAt,
            type: type,
            skillCardType: skillCardType,
            skillCardTitle: skillCardTitle,
            skill: skill,
            invocation: invocation,
            duration: duration,
            entries: entries,
        };
    }

    function serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(val) {
        if (val.skillCardType == 'keyword') {
            return serializeKeywordSkillCard(val);
        }
        if (val.skillCardType == 'status') {
            return serializeStatusSkillCard(val);
        }
        if (val.skillCardType == 'timeline') {
            return serializeTimelineSkillCard(val);
        }
        if (val.skillCardType == 'transcript') {
            return serializeTranscriptSkillCard(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }
    function deserializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "KeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard"',
            });
        }
        if (val.skill_card_type == 'keyword') {
            return deserializeKeywordSkillCard(val);
        }
        if (val.skill_card_type == 'status') {
            return deserializeStatusSkillCard(val);
        }
        if (val.skill_card_type == 'timeline') {
            return deserializeTimelineSkillCard(val);
        }
        if (val.skill_card_type == 'transcript') {
            return deserializeTranscriptSkillCard(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize KeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard",
        });
    }

    function deserializeSkillCardsMetadata(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SkillCardsMetadata"',
            });
        }
        if (!(val.$canEdit == void 0) && !sdIsBoolean(val.$canEdit)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "$canEdit" of type "SkillCardsMetadata"',
            });
        }
        const canEdit = val.$canEdit == void 0 ? void 0 : val.$canEdit;
        if (!(val.$id == void 0) && !sdIsString(val.$id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$id" of type "SkillCardsMetadata"',
            });
        }
        const id = val.$id == void 0 ? void 0 : val.$id;
        if (!(val.$parent == void 0) && !sdIsString(val.$parent)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$parent" of type "SkillCardsMetadata"',
            });
        }
        const parent = val.$parent == void 0 ? void 0 : val.$parent;
        if (!(val.$scope == void 0) && !sdIsString(val.$scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$scope" of type "SkillCardsMetadata"',
            });
        }
        const scope = val.$scope == void 0 ? void 0 : val.$scope;
        if (!(val.$template == void 0) && !sdIsString(val.$template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$template" of type "SkillCardsMetadata"',
            });
        }
        const template = val.$template == void 0 ? void 0 : val.$template;
        if (!(val.$type == void 0) && !sdIsString(val.$type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "$type" of type "SkillCardsMetadata"',
            });
        }
        const type = val.$type == void 0 ? void 0 : val.$type;
        if (!(val.$typeVersion == void 0) && !sdIsNumber(val.$typeVersion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$typeVersion" of type "SkillCardsMetadata"',
            });
        }
        const typeVersion = val.$typeVersion == void 0 ? void 0 : val.$typeVersion;
        if (!(val.$version == void 0) && !sdIsNumber(val.$version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "$version" of type "SkillCardsMetadata"',
            });
        }
        const version = val.$version == void 0 ? void 0 : val.$version;
        if (!(val.cards == void 0) && !sdIsList(val.cards)) {
            throw new BoxSdkError({
                message: 'Expecting array for "cards" of type "SkillCardsMetadata"',
            });
        }
        const cards = val.cards == void 0
            ? void 0
            : sdIsList(val.cards)
                ? val.cards.map(function (itm) {
                    return deserializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(itm);
                })
                : [];
        return {
            canEdit: canEdit,
            id: id,
            parent: parent,
            scope: scope,
            template: template,
            type: type,
            typeVersion: typeVersion,
            version: version,
            cards: cards,
        };
    }

    class GetBoxSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new GetBoxSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateBoxSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new CreateBoxSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateBoxSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateBoxSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteBoxSkillCardsFromFileOptionals {
        constructor(fields) {
            this.headers = new DeleteBoxSkillCardsFromFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateAllSkillCardsOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateAllSkillCardsOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetBoxSkillCardsOnFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateBoxSkillCardsOnFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateBoxSkillCardsOnFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteBoxSkillCardsFromFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateAllSkillCardsOnFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SkillsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * List the Box Skills metadata cards that are attached to a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetBoxSkillCardsOnFileOptionalsInput} optionalsInput
           * @returns {Promise<SkillCardsMetadata>}
           */
        getBoxSkillCardsOnFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetBoxSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSkillCardsMetadata(response.data)), { rawData: response.data });
            });
        }
        /**
           * Applies one or more Box Skills metadata cards to a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {CreateBoxSkillCardsOnFileRequestBody} requestBody Request body of createBoxSkillCardsOnFile method
           * @param {CreateBoxSkillCardsOnFileOptionalsInput} optionalsInput
           * @returns {Promise<SkillCardsMetadata>}
           */
        createBoxSkillCardsOnFile(fileId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new CreateBoxSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateBoxSkillCardsOnFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSkillCardsMetadata(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates one or more Box Skills metadata cards to a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {readonly UpdateBoxSkillCardsOnFileRequestBody[]} requestBody Request body of updateBoxSkillCardsOnFile method
           * @param {UpdateBoxSkillCardsOnFileOptionalsInput} optionalsInput
           * @returns {Promise<SkillCardsMetadata>}
           */
        updateBoxSkillCardsOnFile(fileId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateBoxSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateBoxSkillCardsOnFileRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSkillCardsMetadata(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes any Box Skills cards metadata from a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {DeleteBoxSkillCardsFromFileOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteBoxSkillCardsFromFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteBoxSkillCardsFromFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/metadata/global/boxSkillsCards'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * An alternative method that can be used to overwrite and update all Box Skill
           * metadata cards on a file.
           * @param {string} skillId The ID of the skill to apply this metadata for.
          Example: "33243242"
           * @param {UpdateAllSkillCardsOnFileRequestBody} requestBody Request body of updateAllSkillCardsOnFile method
           * @param {UpdateAllSkillCardsOnFileOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        updateAllSkillCardsOnFile(skillId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (skillId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateAllSkillCardsOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/skill_invocations/', toString(skillId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateAllSkillCardsOnFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateBoxSkillCardsOnFileRequestBody(val) {
        return {
            ['cards']: val.cards.map(function (item) {
                return serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(item);
            }),
        };
    }
    function serializeUpdateBoxSkillCardsOnFileRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateBoxSkillCardsOnFileRequestBody(val) {
        return {
            ['op']: val.op == void 0
                ? val.op
                : serializeUpdateBoxSkillCardsOnFileRequestBodyOpField(val.op),
            ['path']: val.path,
            ['value']: val.value == void 0
                ? val.value
                : serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(val.value),
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyMetadataField(val) {
        return {
            ['cards']: val.cards == void 0
                ? val.cards
                : val.cards.map(function (item) {
                    return serializeKeywordSkillCardOrStatusSkillCardOrTimelineSkillCardOrTranscriptSkillCard(item);
                }),
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileTypeField(val) {
        return val;
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileField(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeUpdateAllSkillCardsOnFileRequestBodyFileTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionTypeField(val) {
        return val;
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionField(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBodyUsageField(val) {
        return { ['unit']: val.unit, ['value']: val.value };
    }
    function serializeUpdateAllSkillCardsOnFileRequestBody(val) {
        return {
            ['status']: serializeUpdateAllSkillCardsOnFileRequestBodyStatusField(val.status),
            ['metadata']: serializeUpdateAllSkillCardsOnFileRequestBodyMetadataField(val.metadata),
            ['file']: serializeUpdateAllSkillCardsOnFileRequestBodyFileField(val.file),
            ['file_version']: val.fileVersion == void 0
                ? val.fileVersion
                : serializeUpdateAllSkillCardsOnFileRequestBodyFileVersionField(val.fileVersion),
            ['usage']: val.usage == void 0
                ? val.usage
                : serializeUpdateAllSkillCardsOnFileRequestBodyUsageField(val.usage),
        };
    }

    function deserializeWatermarkWatermarkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WatermarkWatermarkField"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "WatermarkWatermarkField"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "WatermarkWatermarkField"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }
    function deserializeWatermark(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Watermark"' });
        }
        const watermark = val.watermark == void 0
            ? void 0
            : deserializeWatermarkWatermarkField(val.watermark);
        return { watermark: watermark };
    }

    class GetFileWatermarkOptionals {
        constructor(fields) {
            this.headers = new GetFileWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileWatermarkOptionals {
        constructor(fields) {
            this.headers = new UpdateFileWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileWatermarkOptionals {
        constructor(fields) {
            this.headers = new DeleteFileWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileWatermarkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileWatermarkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileWatermarkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileWatermarksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieve the watermark for a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetFileWatermarkOptionalsInput} optionalsInput
           * @returns {Promise<Watermark>}
           */
        getFileWatermark(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new GetFileWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/watermark'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWatermark(response.data)), { rawData: response.data });
            });
        }
        /**
           * Applies or update a watermark on a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {UpdateFileWatermarkRequestBody} requestBody Request body of updateFileWatermark method
           * @param {UpdateFileWatermarkOptionalsInput} optionalsInput
           * @returns {Promise<Watermark>}
           */
        updateFileWatermark(fileId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFileWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/watermark'),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateFileWatermarkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWatermark(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes the watermark from a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {DeleteFileWatermarkOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFileWatermark(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, optionalsInput = {}) {
                const optionals = new DeleteFileWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '/watermark'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeUpdateFileWatermarkRequestBodyWatermarkImprintField(val) {
        return val;
    }
    function serializeUpdateFileWatermarkRequestBodyWatermarkField(val) {
        return {
            ['imprint']: serializeUpdateFileWatermarkRequestBodyWatermarkImprintField(val.imprint),
        };
    }
    function serializeUpdateFileWatermarkRequestBody(val) {
        return {
            ['watermark']: serializeUpdateFileWatermarkRequestBodyWatermarkField(val.watermark),
        };
    }

    function deserializeFileRequestTypeField(val) {
        if (val == 'file_request') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize FileRequestTypeField" });
    }
    function deserializeFileRequestStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'inactive') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileRequestStatusField",
        });
    }
    function deserializeFileRequest(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FileRequest"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileRequest" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileRequest"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileRequest" to be defined',
            });
        }
        const type = deserializeFileRequestTypeField(val.type);
        if (!(val.title == void 0) && !sdIsString(val.title)) {
            throw new BoxSdkError({
                message: 'Expecting string for "title" of type "FileRequest"',
            });
        }
        const title = val.title == void 0 ? void 0 : val.title;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "FileRequest"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const status = val.status == void 0
            ? void 0
            : deserializeFileRequestStatusField(val.status);
        if (!(val.is_email_required == void 0) &&
            !sdIsBoolean(val.is_email_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_email_required" of type "FileRequest"',
            });
        }
        const isEmailRequired = val.is_email_required == void 0 ? void 0 : val.is_email_required;
        if (!(val.is_description_required == void 0) &&
            !sdIsBoolean(val.is_description_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_description_required" of type "FileRequest"',
            });
        }
        const isDescriptionRequired = val.is_description_required == void 0
            ? void 0
            : val.is_description_required;
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "FileRequest"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        if (val.folder == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "folder" of type "FileRequest" to be defined',
            });
        }
        const folder = deserializeFolderMini(val.folder);
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "FileRequest"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FileRequest"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "FileRequest" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FileRequest"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserMini(val.updated_by);
        if (val.updated_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "updated_at" of type "FileRequest" to be defined',
            });
        }
        if (!sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "FileRequest"',
            });
        }
        const updatedAt = dateTimeFromString(val.updated_at);
        return {
            id: id,
            type: type,
            title: title,
            description: description,
            status: status,
            isEmailRequired: isEmailRequired,
            isDescriptionRequired: isDescriptionRequired,
            expiresAt: expiresAt,
            folder: folder,
            url: url,
            etag: etag,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedBy: updatedBy,
            updatedAt: updatedAt,
        };
    }

    function serializeFileRequestUpdateRequestStatusField(val) {
        return val;
    }
    function serializeFileRequestUpdateRequest(val) {
        return {
            ['title']: val.title,
            ['description']: val.description,
            ['status']: val.status == void 0
                ? val.status
                : serializeFileRequestUpdateRequestStatusField(val.status),
            ['is_email_required']: val.isEmailRequired,
            ['is_description_required']: val.isDescriptionRequired,
            ['expires_at']: val.expiresAt == void 0
                ? val.expiresAt
                : dateTimeToString(val.expiresAt),
        };
    }

    function serializeFileRequestCopyRequestFolderTypeField(val) {
        return val;
    }
    function serializeFileRequestCopyRequestFolderField(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeFileRequestCopyRequestFolderTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeFileRequestCopyRequest(val) {
        const base = serializeFileRequestUpdateRequest(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileRequestCopyRequest"',
            });
        }
        return Object.assign(Object.assign({}, base), { ['folder']: serializeFileRequestCopyRequestFolderField(val.folder) });
    }

    class GetFileRequestByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFileRequestByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateFileRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFileRequestByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFileRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFileRequestCopyOptionals {
        constructor(fields) {
            this.headers = new CreateFileRequestCopyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileRequestByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFileRequestByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFileRequestByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFileRequestCopyHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileRequestsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves the information about a file request.
           * @param {string} fileRequestId The unique identifier that represent a file request.
          
          The ID for any file request can be determined
          by visiting a file request builder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/filerequest/123`
          the `file_request_id` is `123`.
          Example: "123"
           * @param {GetFileRequestByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileRequest>}
           */
        getFileRequestById(fileRequestId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileRequestId, optionalsInput = {}) {
                const optionals = new GetFileRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileRequest(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a file request. This can be used to activate or
           * deactivate a file request.
           * @param {string} fileRequestId The unique identifier that represent a file request.
          
          The ID for any file request can be determined
          by visiting a file request builder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/filerequest/123`
          the `file_request_id` is `123`.
          Example: "123"
           * @param {FileRequestUpdateRequest} requestBody Request body of updateFileRequestById method
           * @param {UpdateFileRequestByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileRequest>}
           */
        updateFileRequestById(fileRequestId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileRequestId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFileRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeFileRequestUpdateRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileRequest(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a file request permanently.
           * @param {string} fileRequestId The unique identifier that represent a file request.
          
          The ID for any file request can be determined
          by visiting a file request builder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/filerequest/123`
          the `file_request_id` is `123`.
          Example: "123"
           * @param {DeleteFileRequestByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFileRequestById(fileRequestId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileRequestId, optionalsInput = {}) {
                const optionals = new DeleteFileRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Copies an existing file request that is already present on one folder,
           * and applies it to another folder.
           * @param {string} fileRequestId The unique identifier that represent a file request.
          
          The ID for any file request can be determined
          by visiting a file request builder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/filerequest/123`
          the `file_request_id` is `123`.
          Example: "123"
           * @param {FileRequestCopyRequest} requestBody Request body of createFileRequestCopy method
           * @param {CreateFileRequestCopyOptionalsInput} optionalsInput
           * @returns {Promise<FileRequest>}
           */
        createFileRequestCopy(fileRequestId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileRequestId, requestBody, optionalsInput = {}) {
                const optionals = new CreateFileRequestCopyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_requests/', toString(fileRequestId), '/copy'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeFileRequestCopyRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileRequest(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeFolderFullSyncStateField(val) {
        if (val == 'synced') {
            return val;
        }
        if (val == 'not_synced') {
            return val;
        }
        if (val == 'partially_synced') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFullSyncStateField",
        });
    }
    function deserializeFolderFullPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullPermissionsField"',
            });
        }
        if (val.can_delete == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_delete" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_delete)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_delete" of type "FolderFullPermissionsField"',
            });
        }
        const canDelete = val.can_delete;
        if (val.can_download == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_download" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_download" of type "FolderFullPermissionsField"',
            });
        }
        const canDownload = val.can_download;
        if (val.can_invite_collaborator == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_invite_collaborator" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_invite_collaborator)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_invite_collaborator" of type "FolderFullPermissionsField"',
            });
        }
        const canInviteCollaborator = val.can_invite_collaborator;
        if (val.can_rename == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_rename" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_rename)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_rename" of type "FolderFullPermissionsField"',
            });
        }
        const canRename = val.can_rename;
        if (val.can_set_share_access == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_set_share_access" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_set_share_access)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_set_share_access" of type "FolderFullPermissionsField"',
            });
        }
        const canSetShareAccess = val.can_set_share_access;
        if (val.can_share == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_share" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_share)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_share" of type "FolderFullPermissionsField"',
            });
        }
        const canShare = val.can_share;
        if (val.can_upload == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "can_upload" of type "FolderFullPermissionsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.can_upload)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_upload" of type "FolderFullPermissionsField"',
            });
        }
        const canUpload = val.can_upload;
        return {
            canDelete: canDelete,
            canDownload: canDownload,
            canInviteCollaborator: canInviteCollaborator,
            canRename: canRename,
            canSetShareAccess: canSetShareAccess,
            canShare: canShare,
            canUpload: canUpload,
        };
    }
    function deserializeFolderFullMetadataField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullMetadataField"',
            });
        }
        if (!(val == void 0) && !sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting object for "extraData" of type "FolderFullMetadataField"',
            });
        }
        const extraData = val == void 0
            ? void 0
            : sdIsMap(val)
                ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                    k,
                    (function (v) {
                        return sdIsMap(v)
                            ? Object.fromEntries(Object.entries(v).map(([k, v]) => [
                                k,
                                deserializeMetadataFull(v),
                            ]))
                            : {};
                    })(v),
                ]))
                : {};
        return { extraData: extraData };
    }
    function deserializeFolderFullAllowedSharedLinkAccessLevelsField(val) {
        if (val == 'open') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'collaborators') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFullAllowedSharedLinkAccessLevelsField",
        });
    }
    function deserializeFolderFullAllowedInviteeRolesField(val) {
        if (val == 'editor') {
            return val;
        }
        if (val == 'viewer') {
            return val;
        }
        if (val == 'previewer') {
            return val;
        }
        if (val == 'uploader') {
            return val;
        }
        if (val == 'previewer uploader') {
            return val;
        }
        if (val == 'viewer uploader') {
            return val;
        }
        if (val == 'co-owner') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderFullAllowedInviteeRolesField",
        });
    }
    function deserializeFolderFullWatermarkInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullWatermarkInfoField"',
            });
        }
        if (!(val.is_watermarked == void 0) && !sdIsBoolean(val.is_watermarked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_watermarked" of type "FolderFullWatermarkInfoField"',
            });
        }
        const isWatermarked = val.is_watermarked == void 0 ? void 0 : val.is_watermarked;
        return {
            isWatermarked: isWatermarked,
        };
    }
    function deserializeFolderFullClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderFullClassificationField"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FolderFullClassificationField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.definition == void 0) && !sdIsString(val.definition)) {
            throw new BoxSdkError({
                message: 'Expecting string for "definition" of type "FolderFullClassificationField"',
            });
        }
        const definition = val.definition == void 0 ? void 0 : val.definition;
        if (!(val.color == void 0) && !sdIsString(val.color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "color" of type "FolderFullClassificationField"',
            });
        }
        const color = val.color == void 0 ? void 0 : val.color;
        return {
            name: name,
            definition: definition,
            color: color,
        };
    }
    function deserializeFolderFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderFull"' });
        }
        const syncState = val.sync_state == void 0
            ? void 0
            : deserializeFolderFullSyncStateField(val.sync_state);
        if (!(val.has_collaborations == void 0) &&
            !sdIsBoolean(val.has_collaborations)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "has_collaborations" of type "FolderFull"',
            });
        }
        const hasCollaborations = val.has_collaborations == void 0 ? void 0 : val.has_collaborations;
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeFolderFullPermissionsField(val.permissions);
        if (!(val.tags == void 0) && !sdIsList(val.tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "tags" of type "FolderFull"',
            });
        }
        const tags = val.tags == void 0
            ? void 0
            : sdIsList(val.tags)
                ? val.tags.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "FolderFull"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.can_non_owners_invite == void 0) &&
            !sdIsBoolean(val.can_non_owners_invite)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_non_owners_invite" of type "FolderFull"',
            });
        }
        const canNonOwnersInvite = val.can_non_owners_invite == void 0 ? void 0 : val.can_non_owners_invite;
        if (!(val.is_externally_owned == void 0) &&
            !sdIsBoolean(val.is_externally_owned)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_externally_owned" of type "FolderFull"',
            });
        }
        const isExternallyOwned = val.is_externally_owned == void 0 ? void 0 : val.is_externally_owned;
        const metadata = val.metadata == void 0
            ? void 0
            : deserializeFolderFullMetadataField(val.metadata);
        if (!(val.is_collaboration_restricted_to_enterprise == void 0) &&
            !sdIsBoolean(val.is_collaboration_restricted_to_enterprise)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_collaboration_restricted_to_enterprise" of type "FolderFull"',
            });
        }
        const isCollaborationRestrictedToEnterprise = val.is_collaboration_restricted_to_enterprise == void 0
            ? void 0
            : val.is_collaboration_restricted_to_enterprise;
        if (!(val.allowed_shared_link_access_levels == void 0) &&
            !sdIsList(val.allowed_shared_link_access_levels)) {
            throw new BoxSdkError({
                message: 'Expecting array for "allowed_shared_link_access_levels" of type "FolderFull"',
            });
        }
        const allowedSharedLinkAccessLevels = val.allowed_shared_link_access_levels == void 0
            ? void 0
            : sdIsList(val.allowed_shared_link_access_levels)
                ? val.allowed_shared_link_access_levels.map(function (itm) {
                    return deserializeFolderFullAllowedSharedLinkAccessLevelsField(itm);
                })
                : [];
        if (!(val.allowed_invitee_roles == void 0) &&
            !sdIsList(val.allowed_invitee_roles)) {
            throw new BoxSdkError({
                message: 'Expecting array for "allowed_invitee_roles" of type "FolderFull"',
            });
        }
        const allowedInviteeRoles = val.allowed_invitee_roles == void 0
            ? void 0
            : sdIsList(val.allowed_invitee_roles)
                ? val.allowed_invitee_roles.map(function (itm) {
                    return deserializeFolderFullAllowedInviteeRolesField(itm);
                })
                : [];
        const watermarkInfo = val.watermark_info == void 0
            ? void 0
            : deserializeFolderFullWatermarkInfoField(val.watermark_info);
        if (!(val.is_accessible_via_shared_link == void 0) &&
            !sdIsBoolean(val.is_accessible_via_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accessible_via_shared_link" of type "FolderFull"',
            });
        }
        const isAccessibleViaSharedLink = val.is_accessible_via_shared_link == void 0
            ? void 0
            : val.is_accessible_via_shared_link;
        if (!(val.can_non_owners_view_collaborators == void 0) &&
            !sdIsBoolean(val.can_non_owners_view_collaborators)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_non_owners_view_collaborators" of type "FolderFull"',
            });
        }
        const canNonOwnersViewCollaborators = val.can_non_owners_view_collaborators == void 0
            ? void 0
            : val.can_non_owners_view_collaborators;
        const classification = val.classification == void 0
            ? void 0
            : deserializeFolderFullClassificationField(val.classification);
        if (!(val.is_associated_with_app_item == void 0) &&
            !sdIsBoolean(val.is_associated_with_app_item)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_associated_with_app_item" of type "FolderFull"',
            });
        }
        const isAssociatedWithAppItem = val.is_associated_with_app_item == void 0
            ? void 0
            : val.is_associated_with_app_item;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FolderFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "FolderFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "FolderFull"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "FolderFull"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeFolderPathCollectionField(val.path_collection);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "FolderFull"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "FolderFull"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "FolderFull"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "FolderFull"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        const sharedLink = val.shared_link == void 0
            ? void 0
            : deserializeFolderSharedLinkField(val.shared_link);
        const folderUploadEmail = val.folder_upload_email == void 0
            ? void 0
            : deserializeFolderFolderUploadEmailField(val.folder_upload_email);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeFolderItemStatusField(val.item_status);
        const itemCollection = val.item_collection == void 0
            ? void 0
            : deserializeItems(val.item_collection);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "FolderFull"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "FolderFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FolderFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderFull"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "FolderFull"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FolderFull" to be defined',
            });
        }
        const type = deserializeFolderBaseTypeField(val.type);
        return {
            syncState: syncState,
            hasCollaborations: hasCollaborations,
            permissions: permissions,
            tags: tags,
            canNonOwnersInvite: canNonOwnersInvite,
            isExternallyOwned: isExternallyOwned,
            metadata: metadata,
            isCollaborationRestrictedToEnterprise: isCollaborationRestrictedToEnterprise,
            allowedSharedLinkAccessLevels: allowedSharedLinkAccessLevels,
            allowedInviteeRoles: allowedInviteeRoles,
            watermarkInfo: watermarkInfo,
            isAccessibleViaSharedLink: isAccessibleViaSharedLink,
            canNonOwnersViewCollaborators: canNonOwnersViewCollaborators,
            classification: classification,
            isAssociatedWithAppItem: isAssociatedWithAppItem,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
            itemCollection: itemCollection,
            sequenceId: sequenceId,
            name: name,
            id: id,
            etag: etag,
            type: type,
        };
    }

    class GetFolderByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFolderByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new DeleteFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderItemsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFolderItemsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFolderOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CopyFolderOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CopyFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifNoneMatch !== undefined) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFolderByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifMatch !== undefined) {
                this.ifMatch = fields.ifMatch;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFolderItemsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CopyFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FoldersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves details for a folder, including the first 100 entries
           * in the folder.
           *
           * Passing `sort`, `direction`, `offset`, and `limit`
           * parameters in query allows you to manage the
           * list of returned
           * [folder items](r://folder--full#param-item-collection).
           *
           * To fetch more items within the folder, use the
           * [Get items in a folder](e://get-folders-id-items) endpoint.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetFolderByIdOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        getFolderById(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a folder. This can be also be used to move the folder,
           * create shared links, update collaborations, and more.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {UpdateFolderByIdOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        updateFolderById(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new UpdateFolderByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateFolderByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a folder, either permanently or by moving it to
           * the trash.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {DeleteFolderByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFolderById(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteFolderByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['recursive']: toString(queryParams.recursive),
                });
                const headersMap = prepareParams(Object.assign({ ['if-match']: toString(headers.ifMatch) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)),
                    method: 'DELETE',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Retrieves a page of items in a folder. These items can be files,
           * folders, and web links.
           *
           * To request more information about the folder itself, like its size,
           * use the [Get a folder](#get-folders-id) endpoint instead.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetFolderItemsOptionalsInput} optionalsInput
           * @returns {Promise<Items>}
           */
        getFolderItems(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderItemsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['usemarker']: toString(queryParams.usemarker),
                    ['marker']: toString(queryParams.marker),
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                });
                const headersMap = prepareParams(Object.assign({ ['boxapi']: toString(headers.boxapi) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/items'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeItems(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new empty folder within the specified parent folder.
         * @param {CreateFolderRequestBody} requestBody Request body of createFolder method
         * @param {CreateFolderOptionalsInput} optionalsInput
         * @returns {Promise<FolderFull>}
         */
        createFolder(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateFolderOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Creates a copy of a folder within a destination folder.
           *
           * The original folder will not be changed.
           * @param {string} folderId The unique identifier of the folder to copy.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder with the ID `0` can not be copied.
          Example: "0"
           * @param {CopyFolderRequestBody} requestBody Request body of copyFolder method
           * @param {CopyFolderOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        copyFolder(folderId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, requestBody, optionalsInput = {}) {
                const optionals = new CopyFolderOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/copy'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCopyFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUpdateFolderByIdRequestBodySyncStateField(val) {
        return val;
    }
    function serializeUpdateFolderByIdRequestBodyParentField(val) {
        return { ['id']: val.id, ['user_id']: val.userId };
    }
    function serializeUpdateFolderByIdRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateFolderByIdRequestBodySharedLinkPermissionsField(val) {
        return { ['can_download']: val.canDownload };
    }
    function serializeUpdateFolderByIdRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateFolderByIdRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeUpdateFolderByIdRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateFolderByIdRequestBodyFolderUploadEmailAccessField(val) {
        return val;
    }
    function serializeUpdateFolderByIdRequestBodyFolderUploadEmailField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateFolderByIdRequestBodyFolderUploadEmailAccessField(val.access),
        };
    }
    function serializeUpdateFolderByIdRequestBodyCollectionsField(val) {
        return { ['id']: val.id, ['type']: val.type };
    }
    function serializeUpdateFolderByIdRequestBody(val) {
        return {
            ['name']: val.name,
            ['description']: val.description,
            ['sync_state']: val.syncState == void 0
                ? val.syncState
                : serializeUpdateFolderByIdRequestBodySyncStateField(val.syncState),
            ['can_non_owners_invite']: val.canNonOwnersInvite,
            ['parent']: val.parent == void 0
                ? val.parent
                : serializeUpdateFolderByIdRequestBodyParentField(val.parent),
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeUpdateFolderByIdRequestBodySharedLinkField(val.sharedLink),
            ['folder_upload_email']: val.folderUploadEmail == void 0
                ? val.folderUploadEmail
                : serializeUpdateFolderByIdRequestBodyFolderUploadEmailField(val.folderUploadEmail),
            ['tags']: val.tags == void 0
                ? val.tags
                : val.tags.map(function (item) {
                    return item;
                }),
            ['is_collaboration_restricted_to_enterprise']: val.isCollaborationRestrictedToEnterprise,
            ['collections']: val.collections == void 0
                ? val.collections
                : val.collections.map(function (item) {
                    return serializeUpdateFolderByIdRequestBodyCollectionsField(item);
                }),
            ['can_non_owners_view_collaborators']: val.canNonOwnersViewCollaborators,
        };
    }
    function serializeCreateFolderRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateFolderRequestBodyFolderUploadEmailAccessField(val) {
        return val;
    }
    function serializeCreateFolderRequestBodyFolderUploadEmailField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeCreateFolderRequestBodyFolderUploadEmailAccessField(val.access),
        };
    }
    function serializeCreateFolderRequestBodySyncStateField(val) {
        return val;
    }
    function serializeCreateFolderRequestBody(val) {
        return {
            ['name']: val.name,
            ['parent']: serializeCreateFolderRequestBodyParentField(val.parent),
            ['folder_upload_email']: val.folderUploadEmail == void 0
                ? val.folderUploadEmail
                : serializeCreateFolderRequestBodyFolderUploadEmailField(val.folderUploadEmail),
            ['sync_state']: val.syncState == void 0
                ? val.syncState
                : serializeCreateFolderRequestBodySyncStateField(val.syncState),
        };
    }
    function serializeCopyFolderRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCopyFolderRequestBody(val) {
        return {
            ['name']: val.name,
            ['parent']: serializeCopyFolderRequestBodyParentField(val.parent),
        };
    }

    function deserializeTrashFolderRestoredTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderRestoredTypeField",
        });
    }
    function deserializeTrashFolderRestoredPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderRestoredPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFolderRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFolderRestoredPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFolderRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFolderRestoredPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFolderRestoredItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderRestoredItemStatusField",
        });
    }
    function deserializeTrashFolderRestored(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderRestored"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFolderRestored"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFolderRestored"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        const type = val.type == void 0
            ? void 0
            : deserializeTrashFolderRestoredTypeField(val.type);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFolderRestored"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFolderRestored"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFolderRestored"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFolderRestored"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFolderRestored"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.size == void 0) && !sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFolderRestored"',
            });
        }
        const size = val.size == void 0 ? void 0 : val.size;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeTrashFolderRestoredPathCollectionField(val.path_collection);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFolderRestored"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : val.trashed_at;
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFolderRestored"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : val.purged_at;
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFolderRestored"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFolderRestored"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFolderRestored"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        if (!(val.folder_upload_email == void 0) &&
            !sdIsString(val.folder_upload_email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_upload_email" of type "TrashFolderRestored"',
            });
        }
        const folderUploadEmail = val.folder_upload_email == void 0 ? void 0 : val.folder_upload_email;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeTrashFolderRestoredItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    function deserializeTrashFolderTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrashFolderTypeField" });
    }
    function deserializeTrashFolderPathCollectionEntriesTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderPathCollectionEntriesTypeField",
        });
    }
    function deserializeTrashFolderPathCollectionEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderPathCollectionEntriesField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashFolderPathCollectionEntriesTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFolderPathCollectionEntriesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
        };
    }
    function deserializeTrashFolderPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashFolderPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashFolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashFolderPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashFolderPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashFolderPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTrashFolderPathCollectionEntriesField(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashFolderItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashFolderItemStatusField",
        });
    }
    function deserializeTrashFolder(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrashFolder"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashFolder"',
            });
        }
        const id = val.id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashFolder"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TrashFolder" to be defined',
            });
        }
        const type = deserializeTrashFolderTypeField(val.type);
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashFolder"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (val.name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "name" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashFolder"',
            });
        }
        const name = val.name;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashFolder"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashFolder"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashFolder"',
            });
        }
        const description = val.description;
        if (val.size == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "size" of type "TrashFolder" to be defined',
            });
        }
        if (!sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "TrashFolder"',
            });
        }
        const size = val.size;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashFolder" to be defined',
            });
        }
        const pathCollection = deserializeTrashFolderPathCollectionField(val.path_collection);
        if (val.created_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_by" of type "TrashFolder" to be defined',
            });
        }
        const createdBy = deserializeUserMini(val.created_by);
        if (val.modified_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "modified_by" of type "TrashFolder" to be defined',
            });
        }
        const modifiedBy = deserializeUserMini(val.modified_by);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashFolder"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashFolder"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        if (!(val.content_created_at == void 0) &&
            !sdIsString(val.content_created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_created_at" of type "TrashFolder"',
            });
        }
        const contentCreatedAt = val.content_created_at == void 0
            ? void 0
            : dateTimeFromString(val.content_created_at);
        if (!(val.content_modified_at == void 0) &&
            !sdIsString(val.content_modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_modified_at" of type "TrashFolder"',
            });
        }
        const contentModifiedAt = val.content_modified_at == void 0
            ? void 0
            : dateTimeFromString(val.content_modified_at);
        if (val.owned_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "owned_by" of type "TrashFolder" to be defined',
            });
        }
        const ownedBy = deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashFolder"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        if (!(val.folder_upload_email == void 0) &&
            !sdIsString(val.folder_upload_email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_upload_email" of type "TrashFolder"',
            });
        }
        const folderUploadEmail = val.folder_upload_email == void 0 ? void 0 : val.folder_upload_email;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (val.item_status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_status" of type "TrashFolder" to be defined',
            });
        }
        const itemStatus = deserializeTrashFolderItemStatusField(val.item_status);
        return {
            id: id,
            etag: etag,
            type: type,
            sequenceId: sequenceId,
            name: name,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            description: description,
            size: size,
            pathCollection: pathCollection,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            contentCreatedAt: contentCreatedAt,
            contentModifiedAt: contentModifiedAt,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            folderUploadEmail: folderUploadEmail,
            parent: parent,
            itemStatus: itemStatus,
        };
    }

    class RestoreFolderFromTrashOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new RestoreFolderFromTrashHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTrashedFolderByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetTrashedFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTrashedFolderByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTrashedFolderByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RestoreFolderFromTrashHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTrashedFolderByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTrashedFolderByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedFoldersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Restores a folder that has been moved to the trash.
           *
           * An optional new parent ID can be provided to restore the folder to in case the
           * original folder has been deleted.
           *
           * During this operation, part of the file tree will be locked, mainly
           * the source folder and all of its descendants, as well as the destination
           * folder.
           *
           * For the duration of the operation, no other move, copy, delete, or restore
           * operation can performed on any of the locked folders.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {RestoreFolderFromTrashOptionalsInput} optionalsInput
           * @returns {Promise<TrashFolderRestored>}
           */
        restoreFolderFromTrash(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new RestoreFolderFromTrashOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId)),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRestoreFolderFromTrashRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTrashFolderRestored(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a folder that has been moved to the trash.
           *
           * Please note that only if the folder itself has been moved to the
           * trash can it be retrieved with this API call. If instead one of
           * its parent folders was moved to the trash, only that folder
           * can be inspected using the
           * [`GET /folders/:id/trash`](e://get_folders_id_trash) API.
           *
           * To list all items that have been moved to the trash, please
           * use the [`GET /folders/trash/items`](e://get-folders-trash-items/)
           * API.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetTrashedFolderByIdOptionalsInput} optionalsInput
           * @returns {Promise<TrashFolder>}
           */
        getTrashedFolderById(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetTrashedFolderByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/trash'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTrashFolder(response.data)), { rawData: response.data });
            });
        }
        /**
           * Permanently deletes a folder that is in the trash.
           * This action cannot be undone.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {DeleteTrashedFolderByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteTrashedFolderById(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteTrashedFolderByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/trash'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeRestoreFolderFromTrashRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeRestoreFolderFromTrashRequestBody(val) {
        return {
            ['name']: val.name,
            ['parent']: val.parent == void 0
                ? val.parent
                : serializeRestoreFolderFromTrashRequestBodyParentField(val.parent),
        };
    }

    class GetFolderMetadataOptionals {
        constructor(fields) {
            this.headers = new GetFolderMetadataHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new GetFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new CreateFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderMetadataByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFolderMetadataByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderMetadataHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFolderMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFolderMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFolderMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderMetadataByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderMetadataManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves all metadata for a given folder. This can not be used on the root
           * folder with ID `0`.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetFolderMetadataOptionalsInput} optionalsInput
           * @returns {Promise<Metadatas>}
           */
        getFolderMetadata(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderMetadataOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadatas(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves the instance of a metadata template that has been applied to a
           * folder. This can not be used on the root folder with ID `0`.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetFolderMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {GetFolderMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataFull>}
           */
        getFolderMetadataById(folderId_1, scope_1, templateKey_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, scope, templateKey, optionalsInput = {}) {
                const optionals = new GetFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Applies an instance of a metadata template to a folder.
           *
           * In most cases only values that are present in the metadata template
           * will be accepted, except for the `global.properties` template which accepts
           * any key-value pair.
           *
           * To display the metadata template in the Box web app the enterprise needs to be
           * configured to enable **Cascading Folder Level Metadata** for the user in the
           * admin console.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {CreateFolderMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {CreateFolderMetadataByIdRequestBody} requestBody Request body of createFolderMetadataById method
           * @param {CreateFolderMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataFull>}
           */
        createFolderMetadataById(folderId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new CreateFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFolderMetadataByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a piece of metadata on a folder.
           *
           * The metadata instance can only be updated if the template has already been
           * applied to the folder before. When editing metadata, only values that match
           * the metadata template schema will be accepted.
           *
           * The update is applied atomically. If any errors occur during the
           * application of the operations, the metadata instance will not be changed.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {UpdateFolderMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {readonly UpdateFolderMetadataByIdRequestBody[]} requestBody Request body of updateFolderMetadataById method
           * @param {UpdateFolderMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataFull>}
           */
        updateFolderMetadataById(folderId_1, scope_1, templateKey_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateFolderMetadataByIdRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a piece of folder metadata.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {DeleteFolderMetadataByIdScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {DeleteFolderMetadataByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFolderMetadataById(folderId_1, scope_1, templateKey_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, scope, templateKey, optionalsInput = {}) {
                const optionals = new DeleteFolderMetadataByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/', toString(scope), '/', toString(templateKey)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateFolderMetadataByIdRequestBody(val) {
        return Object.fromEntries(Object.entries(val).map(([k, v]) => [
            k,
            (function (v) {
                return v;
            })(v),
        ]));
    }
    function serializeUpdateFolderMetadataByIdRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateFolderMetadataByIdRequestBody(val) {
        return {
            ['op']: val.op == void 0
                ? val.op
                : serializeUpdateFolderMetadataByIdRequestBodyOpField(val.op),
            ['path']: val.path,
            ['value']: val.value == void 0
                ? val.value
                : serializeMetadataInstanceValue(val.value),
            ['from']: val.from,
        };
    }

    class GetClassificationOnFolderOptionals {
        constructor(fields) {
            this.headers = new GetClassificationOnFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddClassificationToFolderOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new AddClassificationToFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateClassificationOnFolderOptionals {
        constructor(fields) {
            this.headers = new UpdateClassificationOnFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteClassificationFromFolderOptionals {
        constructor(fields) {
            this.headers = new DeleteClassificationFromFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetClassificationOnFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddClassificationToFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateClassificationOnFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteClassificationFromFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderClassificationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves the classification metadata instance that
           * has been applied to a folder.
           *
           * This API can also be called by including the enterprise ID in the
           * URL explicitly, for example
           * `/folders/:id/enterprise_12345/securityClassification-6VMVochwUWo`.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetClassificationOnFolderOptionalsInput} optionalsInput
           * @returns {Promise<Classification>}
           */
        getClassificationOnFolder(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetClassificationOnFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassification(response.data)), { rawData: response.data });
            });
        }
        /**
           * Adds a classification to a folder by specifying the label of the
           * classification to add.
           *
           * This API can also be called by including the enterprise ID in the
           * URL explicitly, for example
           * `/folders/:id/enterprise_12345/securityClassification-6VMVochwUWo`.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {AddClassificationToFolderOptionalsInput} optionalsInput
           * @returns {Promise<Classification>}
           */
        addClassificationToFolder(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new AddClassificationToFolderOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAddClassificationToFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassification(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a classification on a folder.
           *
           * The classification can only be updated if a classification has already been
           * applied to the folder before. When editing classifications, only values are
           * defined for the enterprise will be accepted.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {readonly UpdateClassificationOnFolderRequestBody[]} requestBody Request body of updateClassificationOnFolder method
           * @param {UpdateClassificationOnFolderOptionalsInput} optionalsInput
           * @returns {Promise<Classification>}
           */
        updateClassificationOnFolder(folderId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateClassificationOnFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateClassificationOnFolderRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassification(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes any classifications from a folder.
           *
           * This API can also be called by including the enterprise ID in the
           * URL explicitly, for example
           * `/folders/:id/enterprise_12345/securityClassification-6VMVochwUWo`.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {DeleteClassificationFromFolderOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteClassificationFromFolder(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteClassificationFromFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/metadata/enterprise/securityClassification-6VMVochwUWo'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeAddClassificationToFolderRequestBody(val) {
        return {
            ['Box__Security__Classification__Key']: val.boxSecurityClassificationKey,
        };
    }
    function serializeUpdateClassificationOnFolderRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFolderRequestBodyPathField(val) {
        return val;
    }
    function serializeUpdateClassificationOnFolderRequestBody(val) {
        return {
            ['op']: serializeUpdateClassificationOnFolderRequestBodyOpField(val.op),
            ['path']: serializeUpdateClassificationOnFolderRequestBodyPathField(val.path),
            ['value']: val.value,
        };
    }

    class GetTrashedItemsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedItemsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves the files and folders that have been moved
         * to the trash.
         *
         * Any attribute in the full files or folders objects can be passed
         * in with the `fields` parameter to retrieve those specific
         * attributes that are not returned by default.
         *
         * This endpoint defaults to use offset-based pagination, yet also supports
         * marker-based pagination using the `marker` parameter.
         * @param {GetTrashedItemsQueryParams} queryParams Query parameters of getTrashedItems method
         * @param {GetTrashedItemsHeadersInput} headersInput Headers of getTrashedItems method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<Items>}
         */
        getTrashedItems() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetTrashedItemsHeaders({}), cancellationToken) {
                const headers = new GetTrashedItemsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                    ['usemarker']: toString(queryParams.usemarker),
                    ['marker']: toString(queryParams.marker),
                    ['direction']: toString(queryParams.direction),
                    ['sort']: toString(queryParams.sort),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/trash/items'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeItems(response.data)), { rawData: response.data });
            });
        }
    }

    class GetFolderWatermarkOptionals {
        constructor(fields) {
            this.headers = new GetFolderWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateFolderWatermarkOptionals {
        constructor(fields) {
            this.headers = new UpdateFolderWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderWatermarkOptionals {
        constructor(fields) {
            this.headers = new DeleteFolderWatermarkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderWatermarkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateFolderWatermarkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderWatermarkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderWatermarksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieve the watermark for a folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetFolderWatermarkOptionalsInput} optionalsInput
           * @returns {Promise<Watermark>}
           */
        getFolderWatermark(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new GetFolderWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/watermark'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWatermark(response.data)), { rawData: response.data });
            });
        }
        /**
           * Applies or update a watermark on a folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {UpdateFolderWatermarkRequestBody} requestBody Request body of updateFolderWatermark method
           * @param {UpdateFolderWatermarkOptionalsInput} optionalsInput
           * @returns {Promise<Watermark>}
           */
        updateFolderWatermark(folderId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateFolderWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/watermark'),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateFolderWatermarkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWatermark(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes the watermark from a folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {DeleteFolderWatermarkOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFolderWatermark(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, optionalsInput = {}) {
                const optionals = new DeleteFolderWatermarkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '/watermark'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeUpdateFolderWatermarkRequestBodyWatermarkImprintField(val) {
        return val;
    }
    function serializeUpdateFolderWatermarkRequestBodyWatermarkField(val) {
        return {
            ['imprint']: serializeUpdateFolderWatermarkRequestBodyWatermarkImprintField(val.imprint),
        };
    }
    function serializeUpdateFolderWatermarkRequestBody(val) {
        return {
            ['watermark']: serializeUpdateFolderWatermarkRequestBodyWatermarkField(val.watermark),
        };
    }

    function deserializeFolderLockLockedOperationsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderLockLockedOperationsField"',
            });
        }
        if (val.move == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "move" of type "FolderLockLockedOperationsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.move)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "move" of type "FolderLockLockedOperationsField"',
            });
        }
        const move = val.move;
        if (val.delete == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "delete" of type "FolderLockLockedOperationsField" to be defined',
            });
        }
        if (!sdIsBoolean(val.delete)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "delete" of type "FolderLockLockedOperationsField"',
            });
        }
        const _delete = val.delete;
        return {
            move: move,
            delete: _delete,
        };
    }
    function deserializeFolderLock(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderLock"' });
        }
        const folder = val.folder == void 0 ? void 0 : deserializeFolderMini(val.folder);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderLock"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "FolderLock"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "FolderLock"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const lockedOperations = val.locked_operations == void 0
            ? void 0
            : deserializeFolderLockLockedOperationsField(val.locked_operations);
        if (!(val.lock_type == void 0) && !sdIsString(val.lock_type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "lock_type" of type "FolderLock"',
            });
        }
        const lockType = val.lock_type == void 0 ? void 0 : val.lock_type;
        return {
            folder: folder,
            id: id,
            type: type,
            createdBy: createdBy,
            createdAt: createdAt,
            lockedOperations: lockedOperations,
            lockType: lockType,
        };
    }

    function deserializeFolderLocks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderLocks"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FolderLocks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFolderLock(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsString(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting string for "limit" of type "FolderLocks"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FolderLocks"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    class GetFolderLocksOptionals {
        constructor(fields) {
            this.headers = new GetFolderLocksHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateFolderLockOptionals {
        constructor(fields) {
            this.headers = new CreateFolderLockHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteFolderLockByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteFolderLockByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFolderLocksHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateFolderLockHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteFolderLockByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FolderLocksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves folder lock details for a given folder.
         *
         * You must be authenticated as the owner or co-owner of the folder to
         * use this endpoint.
         * @param {GetFolderLocksQueryParams} queryParams Query parameters of getFolderLocks method
         * @param {GetFolderLocksOptionalsInput} optionalsInput
         * @returns {Promise<FolderLocks>}
         */
        getFolderLocks(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetFolderLocksOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['folder_id']: toString(queryParams.folderId),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folder_locks'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderLocks(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a folder lock on a folder, preventing it from being moved and/or
         * deleted.
         *
         * You must be authenticated as the owner or co-owner of the folder to
         * use this endpoint.
         * @param {CreateFolderLockRequestBody} requestBody Request body of createFolderLock method
         * @param {CreateFolderLockOptionalsInput} optionalsInput
         * @returns {Promise<FolderLock>}
         */
        createFolderLock(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateFolderLockOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folder_locks'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateFolderLockRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderLock(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a folder lock on a given folder.
           *
           * You must be authenticated as the owner or co-owner of the folder to
           * use this endpoint.
           * @param {string} folderLockId The ID of the folder lock.
          Example: "12345"
           * @param {DeleteFolderLockByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteFolderLockById(folderLockId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderLockId, optionalsInput = {}) {
                const optionals = new DeleteFolderLockByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folder_locks/', toString(folderLockId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateFolderLockRequestBodyLockedOperationsField(val) {
        return { ['move']: val.move, ['delete']: val.delete };
    }
    function serializeCreateFolderLockRequestBodyFolderField(val) {
        return { ['type']: val.type, ['id']: val.id };
    }
    function serializeCreateFolderLockRequestBody(val) {
        return {
            ['locked_operations']: val.lockedOperations == void 0
                ? val.lockedOperations
                : serializeCreateFolderLockRequestBodyLockedOperationsField(val.lockedOperations),
            ['folder']: serializeCreateFolderLockRequestBodyFolderField(val.folder),
        };
    }

    function deserializeMetadataTemplateTypeField(val) {
        if (val == 'metadata_template') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataTemplateTypeField",
        });
    }
    function deserializeMetadataTemplateFieldsTypeField(val) {
        if (val == 'string') {
            return val;
        }
        if (val == 'float') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'enum') {
            return val;
        }
        if (val == 'multiSelect') {
            return val;
        }
        if (val == 'integer') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataTemplateFieldsTypeField",
        });
    }
    function deserializeMetadataTemplateFieldsOptionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplateFieldsOptionsField"',
            });
        }
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "MetadataTemplateFieldsOptionsField" to be defined',
            });
        }
        if (!sdIsString(val.key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "key" of type "MetadataTemplateFieldsOptionsField"',
            });
        }
        const key = val.key;
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataTemplateFieldsOptionsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return { key: key, id: id };
    }
    function deserializeMetadataTemplateFieldsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplateFieldsField"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "MetadataTemplateFieldsField" to be defined',
            });
        }
        const type = deserializeMetadataTemplateFieldsTypeField(val.type);
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "MetadataTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsString(val.key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "key" of type "MetadataTemplateFieldsField"',
            });
        }
        const key = val.key;
        if (val.displayName == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "displayName" of type "MetadataTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsString(val.displayName)) {
            throw new BoxSdkError({
                message: 'Expecting string for "displayName" of type "MetadataTemplateFieldsField"',
            });
        }
        const displayName = val.displayName;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "MetadataTemplateFieldsField"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "MetadataTemplateFieldsField"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (!(val.options == void 0) && !sdIsList(val.options)) {
            throw new BoxSdkError({
                message: 'Expecting array for "options" of type "MetadataTemplateFieldsField"',
            });
        }
        const options = val.options == void 0
            ? void 0
            : sdIsList(val.options)
                ? val.options.map(function (itm) {
                    return deserializeMetadataTemplateFieldsOptionsField(itm);
                })
                : [];
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataTemplateFieldsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return {
            type: type,
            key: key,
            displayName: displayName,
            description: description,
            hidden: hidden,
            options: options,
            id: id,
        };
    }
    function deserializeMetadataTemplate(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplate"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "MetadataTemplate" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataTemplate"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "MetadataTemplate" to be defined',
            });
        }
        const type = deserializeMetadataTemplateTypeField(val.type);
        if (!(val.scope == void 0) && !sdIsString(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "scope" of type "MetadataTemplate"',
            });
        }
        const scope = val.scope == void 0 ? void 0 : val.scope;
        if (!(val.templateKey == void 0) && !sdIsString(val.templateKey)) {
            throw new BoxSdkError({
                message: 'Expecting string for "templateKey" of type "MetadataTemplate"',
            });
        }
        const templateKey = val.templateKey == void 0 ? void 0 : val.templateKey;
        if (!(val.displayName == void 0) && !sdIsString(val.displayName)) {
            throw new BoxSdkError({
                message: 'Expecting string for "displayName" of type "MetadataTemplate"',
            });
        }
        const displayName = val.displayName == void 0 ? void 0 : val.displayName;
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "MetadataTemplate"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (!(val.fields == void 0) && !sdIsList(val.fields)) {
            throw new BoxSdkError({
                message: 'Expecting array for "fields" of type "MetadataTemplate"',
            });
        }
        const fields = val.fields == void 0
            ? void 0
            : sdIsList(val.fields)
                ? val.fields.map(function (itm) {
                    return deserializeMetadataTemplateFieldsField(itm);
                })
                : [];
        if (!(val.copyInstanceOnItemCopy == void 0) &&
            !sdIsBoolean(val.copyInstanceOnItemCopy)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "copyInstanceOnItemCopy" of type "MetadataTemplate"',
            });
        }
        const copyInstanceOnItemCopy = val.copyInstanceOnItemCopy == void 0 ? void 0 : val.copyInstanceOnItemCopy;
        return {
            id: id,
            type: type,
            scope: scope,
            templateKey: templateKey,
            displayName: displayName,
            hidden: hidden,
            fields: fields,
            copyInstanceOnItemCopy: copyInstanceOnItemCopy,
        };
    }

    function deserializeMetadataTemplates(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataTemplates"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "MetadataTemplates"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "MetadataTemplates"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "MetadataTemplates"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "MetadataTemplates"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeMetadataTemplate(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetMetadataTemplatesByInstanceIdOptionals {
        constructor(fields) {
            this.headers = new GetMetadataTemplatesByInstanceIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new GetMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new UpdateMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new DeleteMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataTemplateByIdOptionals {
        constructor(fields) {
            this.headers = new GetMetadataTemplateByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateMetadataTemplateOptionals {
        constructor(fields) {
            this.headers = new CreateMetadataTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataTemplatesByInstanceIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetMetadataTemplateHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateMetadataTemplateHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteMetadataTemplateHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetMetadataTemplateByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGlobalMetadataTemplatesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetEnterpriseMetadataTemplatesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateMetadataTemplateHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class MetadataTemplatesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Finds a metadata template by searching for the ID of an instance of the
         * template.
         * @param {GetMetadataTemplatesByInstanceIdQueryParams} queryParams Query parameters of getMetadataTemplatesByInstanceId method
         * @param {GetMetadataTemplatesByInstanceIdOptionalsInput} optionalsInput
         * @returns {Promise<MetadataTemplates>}
         */
        getMetadataTemplatesByInstanceId(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetMetadataTemplatesByInstanceIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['metadata_instance_id']: toString(queryParams.metadataInstanceId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataTemplates(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a metadata template by its `scope` and `templateKey` values.
           *
           * To find the `scope` and `templateKey` for a template, list all templates for
           * an enterprise or globally, or list all templates applied to a file or folder.
           * @param {GetMetadataTemplateScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {GetMetadataTemplateOptionalsInput} optionalsInput
           * @returns {Promise<MetadataTemplate>}
           */
        getMetadataTemplate(scope_1, templateKey_1) {
            return __awaiter$1(this, arguments, void 0, function* (scope, templateKey, optionalsInput = {}) {
                const optionals = new GetMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(scope), '/', toString(templateKey), '/schema'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataTemplate(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a metadata template.
           *
           * The metadata template can only be updated if the template
           * already exists.
           *
           * The update is applied atomically. If any errors occur during the
           * application of the operations, the metadata template will not be changed.
           * @param {UpdateMetadataTemplateScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {readonly UpdateMetadataTemplateRequestBody[]} requestBody Request body of updateMetadataTemplate method
           * @param {UpdateMetadataTemplateOptionalsInput} optionalsInput
           * @returns {Promise<MetadataTemplate>}
           */
        updateMetadataTemplate(scope_1, templateKey_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (scope, templateKey, requestBody, optionalsInput = {}) {
                const optionals = new UpdateMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(scope), '/', toString(templateKey), '/schema'),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateMetadataTemplateRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataTemplate(response.data)), { rawData: response.data });
            });
        }
        /**
           * Delete a metadata template and its instances.
           * This deletion is permanent and can not be reversed.
           * @param {DeleteMetadataTemplateScope} scope The scope of the metadata template.
          Example: "global"
           * @param {string} templateKey The name of the metadata template.
          Example: "properties"
           * @param {DeleteMetadataTemplateOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteMetadataTemplate(scope_1, templateKey_1) {
            return __awaiter$1(this, arguments, void 0, function* (scope, templateKey, optionalsInput = {}) {
                const optionals = new DeleteMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(scope), '/', toString(templateKey), '/schema'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Retrieves a metadata template by its ID.
           * @param {string} templateId The ID of the template.
          Example: "f7a9891f"
           * @param {GetMetadataTemplateByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataTemplate>}
           */
        getMetadataTemplateById(templateId_1) {
            return __awaiter$1(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new GetMetadataTemplateByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/', toString(templateId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataTemplate(response.data)), { rawData: response.data });
            });
        }
        /**
         * Used to retrieve all generic, global metadata templates available to all
         * enterprises using Box.
         * @param {GetGlobalMetadataTemplatesQueryParams} queryParams Query parameters of getGlobalMetadataTemplates method
         * @param {GetGlobalMetadataTemplatesHeadersInput} headersInput Headers of getGlobalMetadataTemplates method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<MetadataTemplates>}
         */
        getGlobalMetadataTemplates() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetGlobalMetadataTemplatesHeaders({}), cancellationToken) {
                const headers = new GetGlobalMetadataTemplatesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/global'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataTemplates(response.data)), { rawData: response.data });
            });
        }
        /**
         * Used to retrieve all metadata templates created to be used specifically within
         * the user's enterprise.
         * @param {GetEnterpriseMetadataTemplatesQueryParams} queryParams Query parameters of getEnterpriseMetadataTemplates method
         * @param {GetEnterpriseMetadataTemplatesHeadersInput} headersInput Headers of getEnterpriseMetadataTemplates method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<MetadataTemplates>}
         */
        getEnterpriseMetadataTemplates() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetEnterpriseMetadataTemplatesHeaders({}), cancellationToken) {
                const headers = new GetEnterpriseMetadataTemplatesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataTemplates(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new metadata template that can be applied to
         * files and folders.
         * @param {CreateMetadataTemplateRequestBody} requestBody Request body of createMetadataTemplate method
         * @param {CreateMetadataTemplateOptionalsInput} optionalsInput
         * @returns {Promise<MetadataTemplate>}
         */
        createMetadataTemplate(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateMetadataTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/schema'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateMetadataTemplateRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataTemplate(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUpdateMetadataTemplateRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateMetadataTemplateRequestBody(val) {
        return {
            ['op']: serializeUpdateMetadataTemplateRequestBodyOpField(val.op),
            ['data']: val.data == void 0
                ? val.data
                : Object.fromEntries(Object.entries(val.data).map(([k, v]) => [
                    k,
                    (function (v) {
                        return v;
                    })(v),
                ])),
            ['fieldKey']: val.fieldKey,
            ['fieldKeys']: val.fieldKeys == void 0
                ? val.fieldKeys
                : val.fieldKeys.map(function (item) {
                    return item;
                }),
            ['enumOptionKey']: val.enumOptionKey,
            ['enumOptionKeys']: val.enumOptionKeys == void 0
                ? val.enumOptionKeys
                : val.enumOptionKeys.map(function (item) {
                    return item;
                }),
            ['multiSelectOptionKey']: val.multiSelectOptionKey,
            ['multiSelectOptionKeys']: val.multiSelectOptionKeys == void 0
                ? val.multiSelectOptionKeys
                : val.multiSelectOptionKeys.map(function (item) {
                    return item;
                }),
        };
    }
    function serializeCreateMetadataTemplateRequestBodyFieldsTypeField(val) {
        return val;
    }
    function serializeCreateMetadataTemplateRequestBodyFieldsOptionsField(val) {
        return { ['key']: val.key };
    }
    function serializeCreateMetadataTemplateRequestBodyFieldsField(val) {
        return {
            ['type']: serializeCreateMetadataTemplateRequestBodyFieldsTypeField(val.type),
            ['key']: val.key,
            ['displayName']: val.displayName,
            ['description']: val.description,
            ['hidden']: val.hidden,
            ['options']: val.options == void 0
                ? val.options
                : val.options.map(function (item) {
                    return serializeCreateMetadataTemplateRequestBodyFieldsOptionsField(item);
                }),
        };
    }
    function serializeCreateMetadataTemplateRequestBody(val) {
        return {
            ['scope']: val.scope,
            ['templateKey']: val.templateKey,
            ['displayName']: val.displayName,
            ['hidden']: val.hidden,
            ['fields']: val.fields == void 0
                ? val.fields
                : val.fields.map(function (item) {
                    return serializeCreateMetadataTemplateRequestBodyFieldsField(item);
                }),
            ['copyInstanceOnItemCopy']: val.copyInstanceOnItemCopy,
        };
    }

    function deserializeClassificationTemplateTypeField(val) {
        if (val == 'metadata_template') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateTypeField",
        });
    }
    function deserializeClassificationTemplateTemplateKeyField(val) {
        if (val == 'securityClassification-6VMVochwUWo') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateTemplateKeyField",
        });
    }
    function deserializeClassificationTemplateDisplayNameField(val) {
        if (val == 'Classification') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateDisplayNameField",
        });
    }
    function deserializeClassificationTemplateFieldsTypeField(val) {
        if (val == 'enum') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateFieldsTypeField",
        });
    }
    function deserializeClassificationTemplateFieldsKeyField(val) {
        if (val == 'Box__Security__Classification__Key') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateFieldsKeyField",
        });
    }
    function deserializeClassificationTemplateFieldsDisplayNameField(val) {
        if (val == 'Classification') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ClassificationTemplateFieldsDisplayNameField",
        });
    }
    function deserializeClassificationTemplateFieldsOptionsStaticConfigClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsOptionsStaticConfigClassificationField"',
            });
        }
        if (!(val.classificationDefinition == void 0) &&
            !sdIsString(val.classificationDefinition)) {
            throw new BoxSdkError({
                message: 'Expecting string for "classificationDefinition" of type "ClassificationTemplateFieldsOptionsStaticConfigClassificationField"',
            });
        }
        const classificationDefinition = val.classificationDefinition == void 0
            ? void 0
            : val.classificationDefinition;
        if (!(val.colorID == void 0) && !sdIsNumber(val.colorID)) {
            throw new BoxSdkError({
                message: 'Expecting number for "colorID" of type "ClassificationTemplateFieldsOptionsStaticConfigClassificationField"',
            });
        }
        const colorId = val.colorID == void 0 ? void 0 : val.colorID;
        return {
            classificationDefinition: classificationDefinition,
            colorId: colorId,
        };
    }
    function deserializeClassificationTemplateFieldsOptionsStaticConfigField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsOptionsStaticConfigField"',
            });
        }
        const classification = val.classification == void 0
            ? void 0
            : deserializeClassificationTemplateFieldsOptionsStaticConfigClassificationField(val.classification);
        return {
            classification: classification,
        };
    }
    function deserializeClassificationTemplateFieldsOptionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsOptionsField"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ClassificationTemplateFieldsOptionsField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ClassificationTemplateFieldsOptionsField"',
            });
        }
        const id = val.id;
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "ClassificationTemplateFieldsOptionsField" to be defined',
            });
        }
        if (!sdIsString(val.key)) {
            throw new BoxSdkError({
                message: 'Expecting string for "key" of type "ClassificationTemplateFieldsOptionsField"',
            });
        }
        const key = val.key;
        const staticConfig = val.staticConfig == void 0
            ? void 0
            : deserializeClassificationTemplateFieldsOptionsStaticConfigField(val.staticConfig);
        return {
            id: id,
            key: key,
            staticConfig: staticConfig,
        };
    }
    function deserializeClassificationTemplateFieldsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplateFieldsField"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ClassificationTemplateFieldsField"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        const type = deserializeClassificationTemplateFieldsTypeField(val.type);
        if (val.key == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "key" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        const key = deserializeClassificationTemplateFieldsKeyField(val.key);
        if (val.displayName == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "displayName" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        const displayName = deserializeClassificationTemplateFieldsDisplayNameField(val.displayName);
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "ClassificationTemplateFieldsField"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (val.options == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "options" of type "ClassificationTemplateFieldsField" to be defined',
            });
        }
        if (!sdIsList(val.options)) {
            throw new BoxSdkError({
                message: 'Expecting array for "options" of type "ClassificationTemplateFieldsField"',
            });
        }
        const options = sdIsList(val.options)
            ? val.options.map(function (itm) {
                return deserializeClassificationTemplateFieldsOptionsField(itm);
            })
            : [];
        return {
            id: id,
            type: type,
            key: key,
            displayName: displayName,
            hidden: hidden,
            options: options,
        };
    }
    function deserializeClassificationTemplate(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ClassificationTemplate"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ClassificationTemplate" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ClassificationTemplate"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ClassificationTemplate" to be defined',
            });
        }
        const type = deserializeClassificationTemplateTypeField(val.type);
        if (val.scope == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "scope" of type "ClassificationTemplate" to be defined',
            });
        }
        if (!sdIsString(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "scope" of type "ClassificationTemplate"',
            });
        }
        const scope = val.scope;
        if (val.templateKey == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "templateKey" of type "ClassificationTemplate" to be defined',
            });
        }
        const templateKey = deserializeClassificationTemplateTemplateKeyField(val.templateKey);
        if (val.displayName == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "displayName" of type "ClassificationTemplate" to be defined',
            });
        }
        const displayName = deserializeClassificationTemplateDisplayNameField(val.displayName);
        if (!(val.hidden == void 0) && !sdIsBoolean(val.hidden)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "hidden" of type "ClassificationTemplate"',
            });
        }
        const hidden = val.hidden == void 0 ? void 0 : val.hidden;
        if (!(val.copyInstanceOnItemCopy == void 0) &&
            !sdIsBoolean(val.copyInstanceOnItemCopy)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "copyInstanceOnItemCopy" of type "ClassificationTemplate"',
            });
        }
        const copyInstanceOnItemCopy = val.copyInstanceOnItemCopy == void 0 ? void 0 : val.copyInstanceOnItemCopy;
        if (val.fields == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "fields" of type "ClassificationTemplate" to be defined',
            });
        }
        if (!sdIsList(val.fields)) {
            throw new BoxSdkError({
                message: 'Expecting array for "fields" of type "ClassificationTemplate"',
            });
        }
        const fields = sdIsList(val.fields)
            ? val.fields.map(function (itm) {
                return deserializeClassificationTemplateFieldsField(itm);
            })
            : [];
        return {
            id: id,
            type: type,
            scope: scope,
            templateKey: templateKey,
            displayName: displayName,
            hidden: hidden,
            copyInstanceOnItemCopy: copyInstanceOnItemCopy,
            fields: fields,
        };
    }

    class AddClassificationOptionals {
        constructor(fields) {
            this.headers = new AddClassificationHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateClassificationOptionals {
        constructor(fields) {
            this.headers = new UpdateClassificationHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateClassificationTemplateOptionals {
        constructor(fields) {
            this.headers = new CreateClassificationTemplateHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetClassificationTemplateHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddClassificationHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateClassificationHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateClassificationTemplateRequestBody {
        constructor(fields) {
            /**
             * The scope in which to create the classifications. This should
             * be `enterprise` or `enterprise_{id}` where `id` is the unique
             * ID of the enterprise. */
            this.scope = 'enterprise';
            /**
             * Defines the list of metadata templates. */
            this.templateKey = 'securityClassification-6VMVochwUWo';
            /**
             * The name of the
             * template as shown in web and mobile interfaces. */
            this.displayName = 'Classification';
            if (fields.scope !== undefined) {
                this.scope = fields.scope;
            }
            if (fields.templateKey !== undefined) {
                this.templateKey = fields.templateKey;
            }
            if (fields.displayName !== undefined) {
                this.displayName = fields.displayName;
            }
            if (fields.hidden !== undefined) {
                this.hidden = fields.hidden;
            }
            if (fields.copyInstanceOnItemCopy !== undefined) {
                this.copyInstanceOnItemCopy = fields.copyInstanceOnItemCopy;
            }
            if (fields.fields !== undefined) {
                this.fields = fields.fields;
            }
            if (fields.rawData !== undefined) {
                this.rawData = fields.rawData;
            }
        }
    }
    class CreateClassificationTemplateHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ClassificationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves the classification metadata template and lists all the
         * classifications available to this enterprise.
         *
         * This API can also be called by including the enterprise ID in the
         * URL explicitly, for example
         * `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
         * @param {GetClassificationTemplateHeadersInput} headersInput Headers of getClassificationTemplate method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<ClassificationTemplate>}
         */
        getClassificationTemplate() {
            return __awaiter$1(this, arguments, void 0, function* (headersInput = new GetClassificationTemplateHeaders({}), cancellationToken) {
                const headers = new GetClassificationTemplateHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassificationTemplate(response.data)), { rawData: response.data });
            });
        }
        /**
         * Adds one or more new classifications to the list of classifications
         * available to the enterprise.
         *
         * This API can also be called by including the enterprise ID in the
         * URL explicitly, for example
         * `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
         * @param {readonly AddClassificationRequestBody[]} requestBody Request body of addClassification method
         * @param {AddClassificationOptionalsInput} optionalsInput
         * @returns {Promise<ClassificationTemplate>}
         */
        addClassification(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new AddClassificationOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#add'),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeAddClassificationRequestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassificationTemplate(response.data)), { rawData: response.data });
            });
        }
        /**
         * Updates the labels and descriptions of one or more classifications
         * available to the enterprise.
         *
         * This API can also be called by including the enterprise ID in the
         * URL explicitly, for example
         * `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
         * @param {readonly UpdateClassificationRequestBody[]} requestBody Request body of updateClassification method
         * @param {UpdateClassificationOptionalsInput} optionalsInput
         * @returns {Promise<ClassificationTemplate>}
         */
        updateClassification(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new UpdateClassificationOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#update'),
                    method: 'PUT',
                    headers: headersMap,
                    data: requestBody.map(serializeUpdateClassificationRequestBody),
                    contentType: 'application/json-patch+json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassificationTemplate(response.data)), { rawData: response.data });
            });
        }
        /**
         * When an enterprise does not yet have any classifications, this API call
         * initializes the classification template with an initial set of
         * classifications.
         *
         * If an enterprise already has a classification, the template will already
         * exist and instead an API call should be made to add additional
         * classifications.
         * @param {CreateClassificationTemplateRequestBodyInput} requestBodyInput Request body of createClassificationTemplate method
         * @param {CreateClassificationTemplateOptionalsInput} optionalsInput
         * @returns {Promise<ClassificationTemplate>}
         */
        createClassificationTemplate(requestBodyInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBodyInput, optionalsInput = {}) {
                const requestBody = new CreateClassificationTemplateRequestBody({
                    scope: requestBodyInput.scope,
                    templateKey: requestBodyInput.templateKey,
                    displayName: requestBodyInput.displayName,
                    hidden: requestBodyInput.hidden,
                    copyInstanceOnItemCopy: requestBodyInput.copyInstanceOnItemCopy,
                    fields: requestBodyInput.fields,
                });
                const optionals = new CreateClassificationTemplateOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_templates/schema#classifications'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateClassificationTemplateRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeClassificationTemplate(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeAddClassificationRequestBodyOpField(val) {
        return val;
    }
    function serializeAddClassificationRequestBodyFieldKeyField(val) {
        return val;
    }
    function serializeAddClassificationRequestBodyDataStaticConfigClassificationField(val) {
        return {
            ['classificationDefinition']: val.classificationDefinition,
            ['colorID']: val.colorId,
        };
    }
    function serializeAddClassificationRequestBodyDataStaticConfigField(val) {
        return {
            ['classification']: val.classification == void 0
                ? val.classification
                : serializeAddClassificationRequestBodyDataStaticConfigClassificationField(val.classification),
        };
    }
    function serializeAddClassificationRequestBodyDataField(val) {
        return {
            ['key']: val.key,
            ['staticConfig']: val.staticConfig == void 0
                ? val.staticConfig
                : serializeAddClassificationRequestBodyDataStaticConfigField(val.staticConfig),
        };
    }
    function serializeAddClassificationRequestBody(val) {
        return {
            ['op']: serializeAddClassificationRequestBodyOpField(val.op),
            ['fieldKey']: serializeAddClassificationRequestBodyFieldKeyField(val.fieldKey),
            ['data']: serializeAddClassificationRequestBodyDataField(val.data),
        };
    }
    function serializeUpdateClassificationRequestBodyOpField(val) {
        return val;
    }
    function serializeUpdateClassificationRequestBodyFieldKeyField(val) {
        return val;
    }
    function serializeUpdateClassificationRequestBodyDataStaticConfigClassificationField(val) {
        return {
            ['classificationDefinition']: val.classificationDefinition,
            ['colorID']: val.colorId,
        };
    }
    function serializeUpdateClassificationRequestBodyDataStaticConfigField(val) {
        return {
            ['classification']: val.classification == void 0
                ? val.classification
                : serializeUpdateClassificationRequestBodyDataStaticConfigClassificationField(val.classification),
        };
    }
    function serializeUpdateClassificationRequestBodyDataField(val) {
        return {
            ['key']: val.key,
            ['staticConfig']: val.staticConfig == void 0
                ? val.staticConfig
                : serializeUpdateClassificationRequestBodyDataStaticConfigField(val.staticConfig),
        };
    }
    function serializeUpdateClassificationRequestBody(val) {
        return {
            ['op']: serializeUpdateClassificationRequestBodyOpField(val.op),
            ['fieldKey']: serializeUpdateClassificationRequestBodyFieldKeyField(val.fieldKey),
            ['enumOptionKey']: val.enumOptionKey,
            ['data']: serializeUpdateClassificationRequestBodyDataField(val.data),
        };
    }
    function serializeCreateClassificationTemplateRequestBodyScopeField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyTemplateKeyField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyDisplayNameField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsTypeField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsKeyField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsDisplayNameField(val) {
        return val;
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigClassificationField(val) {
        return {
            ['classificationDefinition']: val.classificationDefinition,
            ['colorID']: val.colorId,
        };
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigField(val) {
        return {
            ['classification']: val.classification == void 0
                ? val.classification
                : serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigClassificationField(val.classification),
        };
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsOptionsField(val) {
        return {
            ['key']: val.key,
            ['staticConfig']: val.staticConfig == void 0
                ? val.staticConfig
                : serializeCreateClassificationTemplateRequestBodyFieldsOptionsStaticConfigField(val.staticConfig),
        };
    }
    function serializeCreateClassificationTemplateRequestBodyFieldsField(val) {
        return {
            ['type']: serializeCreateClassificationTemplateRequestBodyFieldsTypeField(val.type),
            ['key']: serializeCreateClassificationTemplateRequestBodyFieldsKeyField(val.key),
            ['displayName']: serializeCreateClassificationTemplateRequestBodyFieldsDisplayNameField(val.displayName),
            ['hidden']: val.hidden,
            ['options']: val.options.map(function (item) {
                return serializeCreateClassificationTemplateRequestBodyFieldsOptionsField(item);
            }),
        };
    }
    function serializeCreateClassificationTemplateRequestBody(val) {
        return {
            ['scope']: serializeCreateClassificationTemplateRequestBodyScopeField(val.scope),
            ['templateKey']: serializeCreateClassificationTemplateRequestBodyTemplateKeyField(val.templateKey),
            ['displayName']: serializeCreateClassificationTemplateRequestBodyDisplayNameField(val.displayName),
            ['hidden']: val.hidden,
            ['copyInstanceOnItemCopy']: val.copyInstanceOnItemCopy,
            ['fields']: val.fields.map(function (item) {
                return serializeCreateClassificationTemplateRequestBodyFieldsField(item);
            }),
        };
    }

    function deserializeMetadataCascadePolicyTypeField(val) {
        if (val == 'metadata_cascade_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataCascadePolicyTypeField",
        });
    }
    function deserializeMetadataCascadePolicyOwnerEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataCascadePolicyOwnerEnterpriseTypeField",
        });
    }
    function deserializeMetadataCascadePolicyOwnerEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicyOwnerEnterpriseField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeMetadataCascadePolicyOwnerEnterpriseTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataCascadePolicyOwnerEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return {
            type: type,
            id: id,
        };
    }
    function deserializeMetadataCascadePolicyParentTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize MetadataCascadePolicyParentTypeField",
        });
    }
    function deserializeMetadataCascadePolicyParentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicyParentField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeMetadataCascadePolicyParentTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataCascadePolicyParentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return { type: type, id: id };
    }
    function deserializeMetadataCascadePolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicy"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "MetadataCascadePolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "MetadataCascadePolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "MetadataCascadePolicy" to be defined',
            });
        }
        const type = deserializeMetadataCascadePolicyTypeField(val.type);
        const ownerEnterprise = val.owner_enterprise == void 0
            ? void 0
            : deserializeMetadataCascadePolicyOwnerEnterpriseField(val.owner_enterprise);
        const parent = val.parent == void 0
            ? void 0
            : deserializeMetadataCascadePolicyParentField(val.parent);
        if (!(val.scope == void 0) && !sdIsString(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting string for "scope" of type "MetadataCascadePolicy"',
            });
        }
        const scope = val.scope == void 0 ? void 0 : val.scope;
        if (!(val.templateKey == void 0) && !sdIsString(val.templateKey)) {
            throw new BoxSdkError({
                message: 'Expecting string for "templateKey" of type "MetadataCascadePolicy"',
            });
        }
        const templateKey = val.templateKey == void 0 ? void 0 : val.templateKey;
        return {
            id: id,
            type: type,
            ownerEnterprise: ownerEnterprise,
            parent: parent,
            scope: scope,
            templateKey: templateKey,
        };
    }

    function deserializeMetadataCascadePolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataCascadePolicies"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "MetadataCascadePolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "MetadataCascadePolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "MetadataCascadePolicies"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "MetadataCascadePolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeMetadataCascadePolicy(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetMetadataCascadePoliciesOptionals {
        constructor(fields) {
            this.headers = new GetMetadataCascadePoliciesHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateMetadataCascadePolicyOptionals {
        constructor(fields) {
            this.headers = new CreateMetadataCascadePolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataCascadePolicyByIdOptionals {
        constructor(fields) {
            this.headers = new GetMetadataCascadePolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteMetadataCascadePolicyByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteMetadataCascadePolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class ApplyMetadataCascadePolicyOptionals {
        constructor(fields) {
            this.headers = new ApplyMetadataCascadePolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetMetadataCascadePoliciesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateMetadataCascadePolicyHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetMetadataCascadePolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteMetadataCascadePolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ApplyMetadataCascadePolicyHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class MetadataCascadePoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves a list of all the metadata cascade policies
         * that are applied to a given folder. This can not be used on the root
         * folder with ID `0`.
         * @param {GetMetadataCascadePoliciesQueryParams} queryParams Query parameters of getMetadataCascadePolicies method
         * @param {GetMetadataCascadePoliciesOptionalsInput} optionalsInput
         * @returns {Promise<MetadataCascadePolicies>}
         */
        getMetadataCascadePolicies(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetMetadataCascadePoliciesOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['folder_id']: toString(queryParams.folderId),
                    ['owner_enterprise_id']: toString(queryParams.ownerEnterpriseId),
                    ['marker']: toString(queryParams.marker),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataCascadePolicies(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new metadata cascade policy that applies a given
         * metadata template to a given folder and automatically
         * cascades it down to any files within that folder.
         *
         * In order for the policy to be applied a metadata instance must first
         * be applied to the folder the policy is to be applied to.
         * @param {CreateMetadataCascadePolicyRequestBody} requestBody Request body of createMetadataCascadePolicy method
         * @param {CreateMetadataCascadePolicyOptionalsInput} optionalsInput
         * @returns {Promise<MetadataCascadePolicy>}
         */
        createMetadataCascadePolicy(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateMetadataCascadePolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateMetadataCascadePolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataCascadePolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieve a specific metadata cascade policy assigned to a folder.
           * @param {string} metadataCascadePolicyId The ID of the metadata cascade policy.
          Example: "6fd4ff89-8fc1-42cf-8b29-1890dedd26d7"
           * @param {GetMetadataCascadePolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<MetadataCascadePolicy>}
           */
        getMetadataCascadePolicyById(metadataCascadePolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (metadataCascadePolicyId, optionalsInput = {}) {
                const optionals = new GetMetadataCascadePolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies/', toString(metadataCascadePolicyId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataCascadePolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a metadata cascade policy.
           * @param {string} metadataCascadePolicyId The ID of the metadata cascade policy.
          Example: "6fd4ff89-8fc1-42cf-8b29-1890dedd26d7"
           * @param {DeleteMetadataCascadePolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteMetadataCascadePolicyById(metadataCascadePolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (metadataCascadePolicyId, optionalsInput = {}) {
                const optionals = new DeleteMetadataCascadePolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies/', toString(metadataCascadePolicyId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Force the metadata on a folder with a metadata cascade policy to be applied to
           * all of its children. This can be used after creating a new cascade policy to
           * enforce the metadata to be cascaded down to all existing files within that
           * folder.
           * @param {string} metadataCascadePolicyId The ID of the cascade policy to force-apply.
          Example: "6fd4ff89-8fc1-42cf-8b29-1890dedd26d7"
           * @param {ApplyMetadataCascadePolicyRequestBody} requestBody Request body of applyMetadataCascadePolicy method
           * @param {ApplyMetadataCascadePolicyOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        applyMetadataCascadePolicy(metadataCascadePolicyId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (metadataCascadePolicyId, requestBody, optionalsInput = {}) {
                const optionals = new ApplyMetadataCascadePolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_cascade_policies/', toString(metadataCascadePolicyId), '/apply'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeApplyMetadataCascadePolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateMetadataCascadePolicyRequestBodyScopeField(val) {
        return val;
    }
    function serializeCreateMetadataCascadePolicyRequestBody(val) {
        return {
            ['folder_id']: val.folderId,
            ['scope']: serializeCreateMetadataCascadePolicyRequestBodyScopeField(val.scope),
            ['templateKey']: val.templateKey,
        };
    }
    function serializeApplyMetadataCascadePolicyRequestBodyConflictResolutionField(val) {
        return val;
    }
    function serializeApplyMetadataCascadePolicyRequestBody(val) {
        return {
            ['conflict_resolution']: serializeApplyMetadataCascadePolicyRequestBodyConflictResolutionField(val.conflictResolution),
        };
    }

    function deserializeFileFullOrFolderFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullOrFolderFull"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileFull(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderFull(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize FileFullOrFolderFull" });
    }

    function deserializeMetadataQueryResults(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "MetadataQueryResults"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "MetadataQueryResults"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullOrFolderFull(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "MetadataQueryResults"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "MetadataQueryResults"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    function serializeMetadataQueryOrderByDirectionField(val) {
        return val;
    }
    function serializeMetadataQueryOrderByField(val) {
        return {
            ['field_key']: val.fieldKey,
            ['direction']: val.direction == void 0
                ? val.direction
                : serializeMetadataQueryOrderByDirectionField(val.direction),
        };
    }
    function serializeMetadataQuery(val) {
        return {
            ['from']: val.from,
            ['query']: val.query,
            ['query_params']: val.queryParams == void 0
                ? val.queryParams
                : Object.fromEntries(Object.entries(val.queryParams).map(([k, v]) => [
                    k,
                    (function (v) {
                        return v;
                    })(v),
                ])),
            ['ancestor_folder_id']: val.ancestorFolderId,
            ['order_by']: val.orderBy == void 0
                ? val.orderBy
                : val.orderBy.map(function (item) {
                    return serializeMetadataQueryOrderByField(item);
                }),
            ['limit']: val.limit,
            ['marker']: val.marker,
            ['fields']: val.fields == void 0
                ? val.fields
                : val.fields.map(function (item) {
                    return item;
                }),
        };
    }

    function deserializeFileFullOrFolderFullOrWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileFullOrFolderFullOrWebLink"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileFull(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderFull(val);
        }
        if (val.type == 'web_link') {
            return deserializeWebLink(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileFullOrFolderFullOrWebLink",
        });
    }

    function deserializeSearchResultsTypeField(val) {
        if (val == 'search_results_items') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SearchResultsTypeField",
        });
    }
    function deserializeSearchResults(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SearchResults"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "SearchResults"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SearchResults"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "SearchResults"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "SearchResults" to be defined',
            });
        }
        const type = deserializeSearchResultsTypeField(val.type);
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SearchResults"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullOrFolderFullOrWebLink(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            type: type,
            entries: entries,
        };
    }

    function deserializeSearchResultWithSharedLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SearchResultWithSharedLink"',
            });
        }
        if (!(val.accessible_via_shared_link == void 0) &&
            !sdIsString(val.accessible_via_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "accessible_via_shared_link" of type "SearchResultWithSharedLink"',
            });
        }
        const accessibleViaSharedLink = val.accessible_via_shared_link == void 0
            ? void 0
            : val.accessible_via_shared_link;
        const item = val.item == void 0
            ? void 0
            : deserializeFileFullOrFolderFullOrWebLink(val.item);
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "SearchResultWithSharedLink"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        return {
            accessibleViaSharedLink: accessibleViaSharedLink,
            item: item,
            type: type,
        };
    }

    function deserializeSearchResultsWithSharedLinksTypeField(val) {
        if (val == 'search_results_with_shared_links') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SearchResultsWithSharedLinksTypeField",
        });
    }
    function deserializeSearchResultsWithSharedLinks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SearchResultsWithSharedLinks"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "SearchResultsWithSharedLinks"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SearchResultsWithSharedLinks"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "SearchResultsWithSharedLinks"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "SearchResultsWithSharedLinks" to be defined',
            });
        }
        const type = deserializeSearchResultsWithSharedLinksTypeField(val.type);
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SearchResultsWithSharedLinks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeSearchResultWithSharedLink(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            type: type,
            entries: entries,
        };
    }

    function deserializeSearchResultsOrSearchResultsWithSharedLinks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SearchResultsOrSearchResultsWithSharedLinks"',
            });
        }
        if (val.type == 'search_results_items') {
            return deserializeSearchResults(val);
        }
        if (val.type == 'search_results_with_shared_links') {
            return deserializeSearchResultsWithSharedLinks(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize SearchResultsOrSearchResultsWithSharedLinks",
        });
    }

    function serializeMetadataFieldFilterDateRange(val) {
        return {
            ['lt']: val.lt == void 0 ? val.lt : dateTimeToString(val.lt),
            ['gt']: val.gt == void 0 ? val.gt : dateTimeToString(val.gt),
        };
    }

    function serializeMetadataFieldFilterFloatRange(val) {
        return { ['lt']: val.lt, ['gt']: val.gt };
    }

    function serializeMetadataFieldFilterDateRangeOrMetadataFieldFilterFloatRangeOrArrayOfStringOrNumberOrString(val) {
        if (sdIsString(val)) {
            return val;
        }
        if (sdIsNumber(val)) {
            return val;
        }
        if (sdIsList(val) && val.every(sdIsString)) {
            return val;
        }
        try {
            return serializeMetadataFieldFilterDateRange(val);
        }
        catch (error) {
        }
        finally {
        }
        try {
            return serializeMetadataFieldFilterFloatRange(val);
        }
        catch (error) {
        }
        finally {
        }
        throw new BoxSdkError({
            message: "Can't serialize MetadataFieldFilterDateRangeOrMetadataFieldFilterFloatRangeOrArrayOfStringOrNumberOrString",
        });
    }

    function serializeMetadataFilterScopeField(val) {
        return val;
    }
    function serializeMetadataFilter(val) {
        return {
            ['scope']: val.scope == void 0
                ? val.scope
                : serializeMetadataFilterScopeField(val.scope),
            ['templateKey']: val.templateKey,
            ['filters']: val.filters == void 0
                ? val.filters
                : Object.fromEntries(Object.entries(val.filters).map(([k, v]) => [
                    k,
                    serializeMetadataFieldFilterDateRangeOrMetadataFieldFilterFloatRangeOrArrayOfStringOrNumberOrString(v),
                ])),
        };
    }

    class SearchByMetadataQueryOptionals {
        constructor(fields) {
            this.headers = new SearchByMetadataQueryHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class SearchByMetadataQueryHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SearchForContentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SearchManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Create a search using SQL-like syntax to return items that match specific
         * metadata.
         *
         * By default, this endpoint returns only the most basic info about the items for
         * which the query matches. To get additional fields for each item, including any
         * of the metadata, use the `fields` attribute in the query.
         * @param {MetadataQuery} requestBody Request body of searchByMetadataQuery method
         * @param {SearchByMetadataQueryOptionalsInput} optionalsInput
         * @returns {Promise<MetadataQueryResults>}
         */
        searchByMetadataQuery(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new SearchByMetadataQueryOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/metadata_queries/execute_read'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeMetadataQuery(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeMetadataQueryResults(response.data)), { rawData: response.data });
            });
        }
        /**
         * Searches for files, folders, web links, and shared files across the
         * users content or across the entire enterprise.
         * @param {SearchForContentQueryParams} queryParams Query parameters of searchForContent method
         * @param {SearchForContentHeadersInput} headersInput Headers of searchForContent method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<SearchResultsOrSearchResultsWithSharedLinks>}
         */
        searchForContent() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new SearchForContentHeaders({}), cancellationToken) {
                const headers = new SearchForContentHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['query']: toString(queryParams.query),
                    ['scope']: toString(queryParams.scope),
                    ['file_extensions']: queryParams.fileExtensions
                        ? queryParams.fileExtensions.map(toString).join(',')
                        : undefined,
                    ['created_at_range']: queryParams.createdAtRange
                        ? queryParams.createdAtRange.map(toString).join(',')
                        : undefined,
                    ['updated_at_range']: queryParams.updatedAtRange
                        ? queryParams.updatedAtRange.map(toString).join(',')
                        : undefined,
                    ['size_range']: queryParams.sizeRange
                        ? queryParams.sizeRange.map(toString).join(',')
                        : undefined,
                    ['owner_user_ids']: queryParams.ownerUserIds
                        ? queryParams.ownerUserIds.map(toString).join(',')
                        : undefined,
                    ['recent_updater_user_ids']: queryParams.recentUpdaterUserIds
                        ? queryParams.recentUpdaterUserIds.map(toString).join(',')
                        : undefined,
                    ['ancestor_folder_ids']: queryParams.ancestorFolderIds
                        ? queryParams.ancestorFolderIds.map(toString).join(',')
                        : undefined,
                    ['content_types']: queryParams.contentTypes
                        ? queryParams.contentTypes.map(toString).join(',')
                        : undefined,
                    ['type']: toString(queryParams.type),
                    ['trash_content']: toString(queryParams.trashContent),
                    ['mdfilters']: queryParams.mdfilters
                        ? sdToJson(queryParams.mdfilters.map(serializeMetadataFilter))
                        : undefined,
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                    ['limit']: toString(queryParams.limit),
                    ['include_recent_shared_links']: toString(queryParams.includeRecentSharedLinks),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['deleted_user_ids']: queryParams.deletedUserIds
                        ? queryParams.deletedUserIds.map(toString).join(',')
                        : undefined,
                    ['deleted_at_range']: queryParams.deletedAtRange
                        ? queryParams.deletedAtRange.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/search'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSearchResultsOrSearchResultsWithSharedLinks(response.data)), { rawData: response.data });
            });
        }
    }

    class GetCollaborationByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetCollaborationByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateCollaborationByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateCollaborationByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCollaborationByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCollaborationByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateCollaborationOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateCollaborationHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateCollaborationByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCollaborationByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCollaborationHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UserCollaborationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves a single collaboration.
           * @param {string} collaborationId The ID of the collaboration.
          Example: "1234"
           * @param {GetCollaborationByIdOptionalsInput} optionalsInput
           * @returns {Promise<Collaboration>}
           */
        getCollaborationById(collaborationId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collaborationId, optionalsInput = {}) {
                const optionals = new GetCollaborationByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations/', toString(collaborationId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaboration(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a collaboration.
           * Can be used to change the owner of an item, or to
           * accept collaboration invites.
           * @param {string} collaborationId The ID of the collaboration.
          Example: "1234"
           * @param {UpdateCollaborationByIdRequestBody} requestBody Request body of updateCollaborationById method
           * @param {UpdateCollaborationByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined | Collaboration>}
           */
        updateCollaborationById(collaborationId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (collaborationId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateCollaborationByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations/', toString(collaborationId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateCollaborationByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                if (toString(response.status) == '204') {
                    return void 0;
                }
                return Object.assign(Object.assign({}, deserializeCollaboration(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a single collaboration.
           * @param {string} collaborationId The ID of the collaboration.
          Example: "1234"
           * @param {DeleteCollaborationByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteCollaborationById(collaborationId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collaborationId, optionalsInput = {}) {
                const optionals = new DeleteCollaborationByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations/', toString(collaborationId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
         * Adds a collaboration for a single user or a single group to a file
         * or folder.
         *
         * Collaborations can be created using email address, user IDs, or a
         * group IDs.
         *
         * If a collaboration is being created with a group, access to
         * this endpoint is dependent on the group's ability to be invited.
         *
         * If collaboration is in `pending` status, the following fields
         * are redacted:
         * - `login` and `name` are hidden if a collaboration was created
         * using `user_id`,
         * -  `name` is hidden if a collaboration was created using `login`.
         * @param {CreateCollaborationRequestBody} requestBody Request body of createCollaboration method
         * @param {CreateCollaborationOptionalsInput} optionalsInput
         * @returns {Promise<Collaboration>}
         */
        createCollaboration(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCollaborationOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['notify']: toString(queryParams.notify),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaborations'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateCollaborationRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaboration(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUpdateCollaborationByIdRequestBodyRoleField(val) {
        return val;
    }
    function serializeUpdateCollaborationByIdRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateCollaborationByIdRequestBody(val) {
        return {
            ['role']: serializeUpdateCollaborationByIdRequestBodyRoleField(val.role),
            ['status']: val.status == void 0
                ? val.status
                : serializeUpdateCollaborationByIdRequestBodyStatusField(val.status),
            ['expires_at']: val.expiresAt == void 0
                ? val.expiresAt
                : dateTimeToString(val.expiresAt),
            ['can_view_path']: val.canViewPath,
        };
    }
    function serializeCreateCollaborationRequestBodyItemTypeField(val) {
        return val;
    }
    function serializeCreateCollaborationRequestBodyItemField(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeCreateCollaborationRequestBodyItemTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateCollaborationRequestBodyAccessibleByTypeField(val) {
        return val;
    }
    function serializeCreateCollaborationRequestBodyAccessibleByField(val) {
        return {
            ['type']: serializeCreateCollaborationRequestBodyAccessibleByTypeField(val.type),
            ['id']: val.id,
            ['login']: val.login,
        };
    }
    function serializeCreateCollaborationRequestBodyRoleField(val) {
        return val;
    }
    function serializeCreateCollaborationRequestBody(val) {
        return {
            ['item']: serializeCreateCollaborationRequestBodyItemField(val.item),
            ['accessible_by']: serializeCreateCollaborationRequestBodyAccessibleByField(val.accessibleBy),
            ['role']: serializeCreateCollaborationRequestBodyRoleField(val.role),
            ['is_access_only']: val.isAccessOnly,
            ['can_view_path']: val.canViewPath,
            ['expires_at']: val.expiresAt == void 0
                ? val.expiresAt
                : dateTimeToString(val.expiresAt),
        };
    }

    class GetTaskAssignmentsOptionals {
        constructor(fields) {
            this.headers = new GetTaskAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateTaskAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateTaskAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTaskAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetTaskAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTaskAssignmentByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateTaskAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTaskAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTaskAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTaskAssignmentsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTaskAssignmentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTaskAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTaskAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTaskAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TaskAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Lists all of the assignments for a given task.
           * @param {string} taskId The ID of the task.
          Example: "12345"
           * @param {GetTaskAssignmentsOptionalsInput} optionalsInput
           * @returns {Promise<TaskAssignments>}
           */
        getTaskAssignments(taskId_1) {
            return __awaiter$1(this, arguments, void 0, function* (taskId, optionalsInput = {}) {
                const optionals = new GetTaskAssignmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/tasks/', toString(taskId), '/assignments'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTaskAssignments(response.data)), { rawData: response.data });
            });
        }
        /**
         * Assigns a task to a user.
         *
         * A task can be assigned to more than one user by creating multiple
         * assignments.
         * @param {CreateTaskAssignmentRequestBody} requestBody Request body of createTaskAssignment method
         * @param {CreateTaskAssignmentOptionalsInput} optionalsInput
         * @returns {Promise<TaskAssignment>}
         */
        createTaskAssignment(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTaskAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTaskAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTaskAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves information about a task assignment.
           * @param {string} taskAssignmentId The ID of the task assignment.
          Example: "12345"
           * @param {GetTaskAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<TaskAssignment>}
           */
        getTaskAssignmentById(taskAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (taskAssignmentId, optionalsInput = {}) {
                const optionals = new GetTaskAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments/', toString(taskAssignmentId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTaskAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a task assignment. This endpoint can be
           * used to update the state of a task assigned to a user.
           * @param {string} taskAssignmentId The ID of the task assignment.
          Example: "12345"
           * @param {UpdateTaskAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<TaskAssignment>}
           */
        updateTaskAssignmentById(taskAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (taskAssignmentId, optionalsInput = {}) {
                const optionals = new UpdateTaskAssignmentByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments/', toString(taskAssignmentId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTaskAssignmentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTaskAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a specific task assignment.
           * @param {string} taskAssignmentId The ID of the task assignment.
          Example: "12345"
           * @param {DeleteTaskAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteTaskAssignmentById(taskAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (taskAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteTaskAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/task_assignments/', toString(taskAssignmentId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateTaskAssignmentRequestBodyTaskTypeField(val) {
        return val;
    }
    function serializeCreateTaskAssignmentRequestBodyTaskField(val) {
        return {
            ['id']: val.id,
            ['type']: serializeCreateTaskAssignmentRequestBodyTaskTypeField(val.type),
        };
    }
    function serializeCreateTaskAssignmentRequestBodyAssignToField(val) {
        return { ['id']: val.id, ['login']: val.login };
    }
    function serializeCreateTaskAssignmentRequestBody(val) {
        return {
            ['task']: serializeCreateTaskAssignmentRequestBodyTaskField(val.task),
            ['assign_to']: serializeCreateTaskAssignmentRequestBodyAssignToField(val.assignTo),
        };
    }
    function serializeUpdateTaskAssignmentByIdRequestBodyResolutionStateField(val) {
        return val;
    }
    function serializeUpdateTaskAssignmentByIdRequestBody(val) {
        return {
            ['message']: val.message,
            ['resolution_state']: val.resolutionState == void 0
                ? val.resolutionState
                : serializeUpdateTaskAssignmentByIdRequestBodyResolutionStateField(val.resolutionState),
        };
    }

    class FindFileForSharedLinkOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSharedLinkForFileOptionals {
        constructor(fields) {
            this.headers = new GetSharedLinkForFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddShareLinkToFileOptionals {
        constructor(fields) {
            this.headers = new AddShareLinkToFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSharedLinkOnFileOptionals {
        constructor(fields) {
            this.headers = new UpdateSharedLinkOnFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RemoveSharedLinkFromFileOptionals {
        constructor(fields) {
            this.headers = new RemoveSharedLinkFromFileHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class FindFileForSharedLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifNoneMatch !== undefined) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSharedLinkForFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddShareLinkToFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSharedLinkOnFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RemoveSharedLinkFromFileHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SharedLinksFilesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns the file represented by a shared link.
         *
         * A shared file can be represented by a shared link,
         * which can originate within the current enterprise or within another.
         *
         * This endpoint allows an application to retrieve information about a
         * shared file when only given a shared link.
         *
         * The `shared_link_permission_options` array field can be returned
         * by requesting it in the `fields` query parameter.
         * @param {FindFileForSharedLinkQueryParams} queryParams Query parameters of findFileForSharedLink method
         * @param {FindFileForSharedLinkHeadersInput} headersInput Headers of findFileForSharedLink method
         * @param {FindFileForSharedLinkOptionalsInput} optionalsInput
         * @returns {Promise<FileFull>}
         */
        findFileForSharedLink() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput, optionalsInput = {}) {
                const headers = new FindFileForSharedLinkHeaders({
                    ifNoneMatch: headersInput.ifNoneMatch,
                    boxapi: headersInput.boxapi,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new FindFileForSharedLinkOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shared_items'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Gets the information for a shared link on a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {GetSharedLinkForFileQueryParams} queryParams Query parameters of getSharedLinkForFile method
           * @param {GetSharedLinkForFileOptionalsInput} optionalsInput
           * @returns {Promise<FileFull>}
           */
        getSharedLinkForFile(fileId_1, queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, queryParams, optionalsInput = {}) {
                const optionals = new GetSharedLinkForFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#get_shared_link'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Adds a shared link to a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {AddShareLinkToFileRequestBody} requestBody Request body of addShareLinkToFile method
           * @param {AddShareLinkToFileQueryParams} queryParams Query parameters of addShareLinkToFile method
           * @param {AddShareLinkToFileOptionalsInput} optionalsInput
           * @returns {Promise<FileFull>}
           */
        addShareLinkToFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new AddShareLinkToFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#add_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeAddShareLinkToFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a shared link on a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {UpdateSharedLinkOnFileRequestBody} requestBody Request body of updateSharedLinkOnFile method
           * @param {UpdateSharedLinkOnFileQueryParams} queryParams Query parameters of updateSharedLinkOnFile method
           * @param {UpdateSharedLinkOnFileOptionalsInput} optionalsInput
           * @returns {Promise<FileFull>}
           */
        updateSharedLinkOnFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new UpdateSharedLinkOnFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#update_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateSharedLinkOnFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes a shared link from a file.
           * @param {string} fileId The unique identifier that represents a file.
          
          The ID for any file can be determined
          by visiting a file in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/files/123`
          the `file_id` is `123`.
          Example: "12345"
           * @param {RemoveSharedLinkFromFileRequestBody} requestBody Request body of removeSharedLinkFromFile method
           * @param {RemoveSharedLinkFromFileQueryParams} queryParams Query parameters of removeSharedLinkFromFile method
           * @param {RemoveSharedLinkFromFileOptionalsInput} optionalsInput
           * @returns {Promise<FileFull>}
           */
        removeSharedLinkFromFile(fileId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new RemoveSharedLinkFromFileOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/files/', toString(fileId), '#remove_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRemoveSharedLinkFromFileRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileFull(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeAddShareLinkToFileRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeAddShareLinkToFileRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload,
            ['can_preview']: val.canPreview,
            ['can_edit']: val.canEdit,
        };
    }
    function serializeAddShareLinkToFileRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeAddShareLinkToFileRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeAddShareLinkToFileRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeAddShareLinkToFileRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeAddShareLinkToFileRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeUpdateSharedLinkOnFileRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateSharedLinkOnFileRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload,
            ['can_preview']: val.canPreview,
            ['can_edit']: val.canEdit,
        };
    }
    function serializeUpdateSharedLinkOnFileRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateSharedLinkOnFileRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeUpdateSharedLinkOnFileRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateSharedLinkOnFileRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeUpdateSharedLinkOnFileRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeRemoveSharedLinkFromFileRequestBodySharedLinkField(val) {
        return {};
    }
    function serializeRemoveSharedLinkFromFileRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeRemoveSharedLinkFromFileRequestBodySharedLinkField(val.sharedLink),
        };
    }

    class FindFolderForSharedLinkOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSharedLinkForFolderOptionals {
        constructor(fields) {
            this.headers = new GetSharedLinkForFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddShareLinkToFolderOptionals {
        constructor(fields) {
            this.headers = new AddShareLinkToFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSharedLinkOnFolderOptionals {
        constructor(fields) {
            this.headers = new UpdateSharedLinkOnFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RemoveSharedLinkFromFolderOptionals {
        constructor(fields) {
            this.headers = new RemoveSharedLinkFromFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class FindFolderForSharedLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifNoneMatch !== undefined) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSharedLinkForFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddShareLinkToFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSharedLinkOnFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RemoveSharedLinkFromFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SharedLinksFoldersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Return the folder represented by a shared link.
         *
         * A shared folder can be represented by a shared link,
         * which can originate within the current enterprise or within another.
         *
         * This endpoint allows an application to retrieve information about a
         * shared folder when only given a shared link.
         * @param {FindFolderForSharedLinkQueryParams} queryParams Query parameters of findFolderForSharedLink method
         * @param {FindFolderForSharedLinkHeadersInput} headersInput Headers of findFolderForSharedLink method
         * @param {FindFolderForSharedLinkOptionalsInput} optionalsInput
         * @returns {Promise<FolderFull>}
         */
        findFolderForSharedLink() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput, optionalsInput = {}) {
                const headers = new FindFolderForSharedLinkHeaders({
                    ifNoneMatch: headersInput.ifNoneMatch,
                    boxapi: headersInput.boxapi,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new FindFolderForSharedLinkOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shared_items#folders'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Gets the information for a shared link on a folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {GetSharedLinkForFolderQueryParams} queryParams Query parameters of getSharedLinkForFolder method
           * @param {GetSharedLinkForFolderOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        getSharedLinkForFolder(folderId_1, queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, queryParams, optionalsInput = {}) {
                const optionals = new GetSharedLinkForFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#get_shared_link'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Adds a shared link to a folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {AddShareLinkToFolderRequestBody} requestBody Request body of addShareLinkToFolder method
           * @param {AddShareLinkToFolderQueryParams} queryParams Query parameters of addShareLinkToFolder method
           * @param {AddShareLinkToFolderOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        addShareLinkToFolder(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new AddShareLinkToFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#add_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeAddShareLinkToFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a shared link on a folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {UpdateSharedLinkOnFolderRequestBody} requestBody Request body of updateSharedLinkOnFolder method
           * @param {UpdateSharedLinkOnFolderQueryParams} queryParams Query parameters of updateSharedLinkOnFolder method
           * @param {UpdateSharedLinkOnFolderOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        updateSharedLinkOnFolder(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new UpdateSharedLinkOnFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#update_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateSharedLinkOnFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes a shared link from a folder.
           * @param {string} folderId The unique identifier that represent a folder.
          
          The ID for any folder can be determined
          by visiting this folder in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/folder/123`
          the `folder_id` is `123`.
          
          The root folder of a Box account is
          always represented by the ID `0`.
          Example: "12345"
           * @param {RemoveSharedLinkFromFolderRequestBody} requestBody Request body of removeSharedLinkFromFolder method
           * @param {RemoveSharedLinkFromFolderQueryParams} queryParams Query parameters of removeSharedLinkFromFolder method
           * @param {RemoveSharedLinkFromFolderOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        removeSharedLinkFromFolder(folderId_1) {
            return __awaiter$1(this, arguments, void 0, function* (folderId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new RemoveSharedLinkFromFolderOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/folders/', toString(folderId), '#remove_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRemoveSharedLinkFromFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeAddShareLinkToFolderRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeAddShareLinkToFolderRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload,
            ['can_preview']: val.canPreview,
            ['can_edit']: val.canEdit,
        };
    }
    function serializeAddShareLinkToFolderRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeAddShareLinkToFolderRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeAddShareLinkToFolderRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeAddShareLinkToFolderRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeAddShareLinkToFolderRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeUpdateSharedLinkOnFolderRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateSharedLinkOnFolderRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload,
            ['can_preview']: val.canPreview,
            ['can_edit']: val.canEdit,
        };
    }
    function serializeUpdateSharedLinkOnFolderRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateSharedLinkOnFolderRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeUpdateSharedLinkOnFolderRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateSharedLinkOnFolderRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeUpdateSharedLinkOnFolderRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeRemoveSharedLinkFromFolderRequestBodySharedLinkField(val) {
        return {};
    }
    function serializeRemoveSharedLinkFromFolderRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeRemoveSharedLinkFromFolderRequestBodySharedLinkField(val.sharedLink),
        };
    }

    class CreateWebLinkOptionals {
        constructor(fields) {
            this.headers = new CreateWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetWebLinkByIdOptionals {
        constructor(fields) {
            this.headers = new GetWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateWebLinkByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteWebLinkByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateWebLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetWebLinkByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateWebLinkByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteWebLinkByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class WebLinksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Creates a web link object within a folder.
         * @param {CreateWebLinkRequestBody} requestBody Request body of createWebLink method
         * @param {CreateWebLinkOptionalsInput} optionalsInput
         * @returns {Promise<WebLink>}
         */
        createWebLink(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieve information about a web link.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {GetWebLinkByIdOptionalsInput} optionalsInput
           * @returns {Promise<WebLink>}
           */
        getWebLinkById(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new GetWebLinkByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['boxapi']: toString(headers.boxapi) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a web link object.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {UpdateWebLinkByIdOptionalsInput} optionalsInput
           * @returns {Promise<WebLink>}
           */
        updateWebLinkById(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new UpdateWebLinkByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateWebLinkByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a web link.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {DeleteWebLinkByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteWebLinkById(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new DeleteWebLinkByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateWebLinkRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateWebLinkRequestBody(val) {
        return {
            ['url']: val.url,
            ['parent']: serializeCreateWebLinkRequestBodyParentField(val.parent),
            ['name']: val.name,
            ['description']: val.description,
        };
    }
    function serializeUpdateWebLinkByIdRequestBodyParentField(val) {
        return { ['id']: val.id, ['user_id']: val.userId };
    }
    function serializeUpdateWebLinkByIdRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateWebLinkByIdRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateWebLinkByIdRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
        };
    }
    function serializeUpdateWebLinkByIdRequestBody(val) {
        return {
            ['url']: val.url,
            ['parent']: val.parent == void 0
                ? val.parent
                : serializeUpdateWebLinkByIdRequestBodyParentField(val.parent),
            ['name']: val.name,
            ['description']: val.description,
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeUpdateWebLinkByIdRequestBodySharedLinkField(val.sharedLink),
        };
    }

    function deserializeTrashWebLinkRestoredTypeField(val) {
        if (val == 'web_link') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkRestoredTypeField",
        });
    }
    function deserializeTrashWebLinkRestoredPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkRestoredPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashWebLinkRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashWebLinkRestoredPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashWebLinkRestoredPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashWebLinkRestoredPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeFolderMini(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashWebLinkRestoredItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkRestoredItemStatusField",
        });
    }
    function deserializeTrashWebLinkRestored(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkRestored"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashWebLinkRestoredTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashWebLinkRestored"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (val.sequence_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "sequence_id" of type "TrashWebLinkRestored" to be defined',
            });
        }
        if (!sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashWebLinkRestored"',
            });
        }
        const sequenceId = val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashWebLinkRestored"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashWebLinkRestored"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "TrashWebLinkRestored"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashWebLinkRestored"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (val.path_collection == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "path_collection" of type "TrashWebLinkRestored" to be defined',
            });
        }
        const pathCollection = deserializeTrashWebLinkRestoredPathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashWebLinkRestored"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashWebLinkRestored"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashWebLinkRestored"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : val.trashed_at;
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashWebLinkRestored"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : val.purged_at;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashWebLinkRestored"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeTrashWebLinkRestoredItemStatusField(val.item_status);
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
            url: url,
            parent: parent,
            description: description,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            itemStatus: itemStatus,
        };
    }

    function deserializeTrashWebLinkTypeField(val) {
        if (val == 'web_link') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrashWebLinkTypeField" });
    }
    function deserializeTrashWebLinkPathCollectionEntriesTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkPathCollectionEntriesTypeField",
        });
    }
    function deserializeTrashWebLinkPathCollectionEntriesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTrashWebLinkPathCollectionEntriesTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashWebLinkPathCollectionEntriesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
        };
    }
    function deserializeTrashWebLinkPathCollectionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TrashWebLinkPathCollectionField"',
            });
        }
        if (val.total_count == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "total_count" of type "TrashWebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TrashWebLinkPathCollectionField"',
            });
        }
        const totalCount = val.total_count;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "TrashWebLinkPathCollectionField" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TrashWebLinkPathCollectionField"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeTrashWebLinkPathCollectionEntriesField(itm);
            })
            : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }
    function deserializeTrashWebLinkItemStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'trashed') {
            return val;
        }
        if (val == 'deleted') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TrashWebLinkItemStatusField",
        });
    }
    function deserializeTrashWebLink(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrashWebLink"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeTrashWebLinkTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TrashWebLink"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.sequence_id == void 0) && !sdIsString(val.sequence_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sequence_id" of type "TrashWebLink"',
            });
        }
        const sequenceId = val.sequence_id == void 0 ? void 0 : val.sequence_id;
        if (!(val.etag == void 0) && !sdIsString(val.etag)) {
            throw new BoxSdkError({
                message: 'Expecting string for "etag" of type "TrashWebLink"',
            });
        }
        const etag = val.etag == void 0 ? void 0 : val.etag;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrashWebLink"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "TrashWebLink"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "TrashWebLink"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const pathCollection = val.path_collection == void 0
            ? void 0
            : deserializeTrashWebLinkPathCollectionField(val.path_collection);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TrashWebLink"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TrashWebLink"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.trashed_at == void 0) && !sdIsString(val.trashed_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "trashed_at" of type "TrashWebLink"',
            });
        }
        const trashedAt = val.trashed_at == void 0 ? void 0 : dateTimeFromString(val.trashed_at);
        if (!(val.purged_at == void 0) && !sdIsString(val.purged_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "purged_at" of type "TrashWebLink"',
            });
        }
        const purgedAt = val.purged_at == void 0 ? void 0 : dateTimeFromString(val.purged_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserMini(val.modified_by);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.shared_link == void 0) && !sdIsString(val.shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "shared_link" of type "TrashWebLink"',
            });
        }
        const sharedLink = val.shared_link == void 0 ? void 0 : val.shared_link;
        const itemStatus = val.item_status == void 0
            ? void 0
            : deserializeTrashWebLinkItemStatusField(val.item_status);
        return {
            type: type,
            id: id,
            sequenceId: sequenceId,
            etag: etag,
            name: name,
            url: url,
            parent: parent,
            description: description,
            pathCollection: pathCollection,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            trashedAt: trashedAt,
            purgedAt: purgedAt,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            ownedBy: ownedBy,
            sharedLink: sharedLink,
            itemStatus: itemStatus,
        };
    }

    class RestoreWeblinkFromTrashOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new RestoreWeblinkFromTrashHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTrashedWebLinkByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetTrashedWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTrashedWebLinkByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTrashedWebLinkByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RestoreWeblinkFromTrashHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTrashedWebLinkByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTrashedWebLinkByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TrashedWebLinksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Restores a web link that has been moved to the trash.
           *
           * An optional new parent ID can be provided to restore the  web link to in case
           * the original folder has been deleted.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {RestoreWeblinkFromTrashOptionalsInput} optionalsInput
           * @returns {Promise<TrashWebLinkRestored>}
           */
        restoreWeblinkFromTrash(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new RestoreWeblinkFromTrashOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId)),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRestoreWeblinkFromTrashRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTrashWebLinkRestored(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a web link that has been moved to the trash.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {GetTrashedWebLinkByIdOptionalsInput} optionalsInput
           * @returns {Promise<TrashWebLink>}
           */
        getTrashedWebLinkById(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new GetTrashedWebLinkByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '/trash'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTrashWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Permanently deletes a web link that is in the trash.
           * This action cannot be undone.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {DeleteTrashedWebLinkByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteTrashedWebLinkById(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, optionalsInput = {}) {
                const optionals = new DeleteTrashedWebLinkByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '/trash'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeRestoreWeblinkFromTrashRequestBodyParentField(val) {
        return { ['id']: val.id };
    }
    function serializeRestoreWeblinkFromTrashRequestBody(val) {
        return {
            ['name']: val.name,
            ['parent']: val.parent == void 0
                ? val.parent
                : serializeRestoreWeblinkFromTrashRequestBodyParentField(val.parent),
        };
    }

    class FindWebLinkForSharedLinkOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSharedLinkForWebLinkOptionals {
        constructor(fields) {
            this.headers = new GetSharedLinkForWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class AddShareLinkToWebLinkOptionals {
        constructor(fields) {
            this.headers = new AddShareLinkToWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSharedLinkOnWebLinkOptionals {
        constructor(fields) {
            this.headers = new UpdateSharedLinkOnWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class RemoveSharedLinkFromWebLinkOptionals {
        constructor(fields) {
            this.headers = new RemoveSharedLinkFromWebLinkHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class FindWebLinkForSharedLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.ifNoneMatch !== undefined) {
                this.ifNoneMatch = fields.ifNoneMatch;
            }
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSharedLinkForWebLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AddShareLinkToWebLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSharedLinkOnWebLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RemoveSharedLinkFromWebLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SharedLinksWebLinksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns the web link represented by a shared link.
         *
         * A shared web link can be represented by a shared link,
         * which can originate within the current enterprise or within another.
         *
         * This endpoint allows an application to retrieve information about a
         * shared web link when only given a shared link.
         * @param {FindWebLinkForSharedLinkQueryParams} queryParams Query parameters of findWebLinkForSharedLink method
         * @param {FindWebLinkForSharedLinkHeadersInput} headersInput Headers of findWebLinkForSharedLink method
         * @param {FindWebLinkForSharedLinkOptionalsInput} optionalsInput
         * @returns {Promise<WebLink>}
         */
        findWebLinkForSharedLink() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput, optionalsInput = {}) {
                const headers = new FindWebLinkForSharedLinkHeaders({
                    ifNoneMatch: headersInput.ifNoneMatch,
                    boxapi: headersInput.boxapi,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new FindWebLinkForSharedLinkOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({
                    ['if-none-match']: toString(headers.ifNoneMatch),
                    ['boxapi']: toString(headers.boxapi),
                }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shared_items#web_links'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Gets the information for a shared link on a web link.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {GetSharedLinkForWebLinkQueryParams} queryParams Query parameters of getSharedLinkForWebLink method
           * @param {GetSharedLinkForWebLinkOptionalsInput} optionalsInput
           * @returns {Promise<WebLink>}
           */
        getSharedLinkForWebLink(webLinkId_1, queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, queryParams, optionalsInput = {}) {
                const optionals = new GetSharedLinkForWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#get_shared_link'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Adds a shared link to a web link.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {AddShareLinkToWebLinkRequestBody} requestBody Request body of addShareLinkToWebLink method
           * @param {AddShareLinkToWebLinkQueryParams} queryParams Query parameters of addShareLinkToWebLink method
           * @param {AddShareLinkToWebLinkOptionalsInput} optionalsInput
           * @returns {Promise<WebLink>}
           */
        addShareLinkToWebLink(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new AddShareLinkToWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#add_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeAddShareLinkToWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a shared link on a web link.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {UpdateSharedLinkOnWebLinkRequestBody} requestBody Request body of updateSharedLinkOnWebLink method
           * @param {UpdateSharedLinkOnWebLinkQueryParams} queryParams Query parameters of updateSharedLinkOnWebLink method
           * @param {UpdateSharedLinkOnWebLinkOptionalsInput} optionalsInput
           * @returns {Promise<WebLink>}
           */
        updateSharedLinkOnWebLink(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new UpdateSharedLinkOnWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#update_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateSharedLinkOnWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes a shared link from a web link.
           * @param {string} webLinkId The ID of the web link.
          Example: "12345"
           * @param {RemoveSharedLinkFromWebLinkRequestBody} requestBody Request body of removeSharedLinkFromWebLink method
           * @param {RemoveSharedLinkFromWebLinkQueryParams} queryParams Query parameters of removeSharedLinkFromWebLink method
           * @param {RemoveSharedLinkFromWebLinkOptionalsInput} optionalsInput
           * @returns {Promise<WebLink>}
           */
        removeSharedLinkFromWebLink(webLinkId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webLinkId, requestBody = {}, queryParams, optionalsInput = {}) {
                const optionals = new RemoveSharedLinkFromWebLinkOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({ ['fields']: toString(queryParams.fields) });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/web_links/', toString(webLinkId), '#remove_shared_link'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeRemoveSharedLinkFromWebLinkRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebLink(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeAddShareLinkToWebLinkRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeAddShareLinkToWebLinkRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload,
            ['can_preview']: val.canPreview,
            ['can_edit']: val.canEdit,
        };
    }
    function serializeAddShareLinkToWebLinkRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeAddShareLinkToWebLinkRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeAddShareLinkToWebLinkRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeAddShareLinkToWebLinkRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeAddShareLinkToWebLinkRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkAccessField(val) {
        return val;
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkPermissionsField(val) {
        return {
            ['can_download']: val.canDownload,
            ['can_preview']: val.canPreview,
            ['can_edit']: val.canEdit,
        };
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkField(val) {
        return {
            ['access']: val.access == void 0
                ? val.access
                : serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkAccessField(val.access),
            ['password']: val.password,
            ['vanity_name']: val.vanityName,
            ['unshared_at']: val.unsharedAt == void 0
                ? val.unsharedAt
                : dateTimeToString(val.unsharedAt),
            ['permissions']: val.permissions == void 0
                ? val.permissions
                : serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkPermissionsField(val.permissions),
        };
    }
    function serializeUpdateSharedLinkOnWebLinkRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeUpdateSharedLinkOnWebLinkRequestBodySharedLinkField(val.sharedLink),
        };
    }
    function serializeRemoveSharedLinkFromWebLinkRequestBodySharedLinkField(val) {
        return {};
    }
    function serializeRemoveSharedLinkFromWebLinkRequestBody(val) {
        return {
            ['shared_link']: val.sharedLink == void 0
                ? val.sharedLink
                : serializeRemoveSharedLinkFromWebLinkRequestBodySharedLinkField(val.sharedLink),
        };
    }

    class FindAppItemForSharedLinkOptionals {
        constructor(fields) {
            this.cancellationToken = void 0;
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class FindAppItemForSharedLinkHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxapi !== undefined) {
                this.boxapi = fields.boxapi;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SharedLinksAppItemsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns the app item represented by a shared link.
         *
         * The link can originate from the current enterprise or another.
         * @param {FindAppItemForSharedLinkHeadersInput} headersInput Headers of findAppItemForSharedLink method
         * @param {FindAppItemForSharedLinkOptionalsInput} optionalsInput
         * @returns {Promise<AppItem>}
         */
        findAppItemForSharedLink(headersInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (headersInput, optionalsInput = {}) {
                const headers = new FindAppItemForSharedLinkHeaders({
                    boxapi: headersInput.boxapi,
                    extraHeaders: headersInput.extraHeaders,
                });
                const optionals = new FindAppItemForSharedLinkOptionals({
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['boxapi']: toString(headers.boxapi) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shared_items#app_items'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAppItem(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeUserStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'inactive') {
            return val;
        }
        if (val == 'cannot_delete_edit') {
            return val;
        }
        if (val == 'cannot_delete_edit_upload') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize UserStatusField" });
    }
    function deserializeUserNotificationEmailField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserNotificationEmailField"',
            });
        }
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "UserNotificationEmailField"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        if (!(val.is_confirmed == void 0) && !sdIsBoolean(val.is_confirmed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_confirmed" of type "UserNotificationEmailField"',
            });
        }
        const isConfirmed = val.is_confirmed == void 0 ? void 0 : val.is_confirmed;
        return {
            email: email,
            isConfirmed: isConfirmed,
        };
    }
    function deserializeUser(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "User"' });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "User"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "User"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.language == void 0) && !sdIsString(val.language)) {
            throw new BoxSdkError({
                message: 'Expecting string for "language" of type "User"',
            });
        }
        const language = val.language == void 0 ? void 0 : val.language;
        if (!(val.timezone == void 0) && !sdIsString(val.timezone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "timezone" of type "User"',
            });
        }
        const timezone = val.timezone == void 0 ? void 0 : val.timezone;
        if (!(val.space_amount == void 0) && !sdIsNumber(val.space_amount)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_amount" of type "User"',
            });
        }
        const spaceAmount = val.space_amount == void 0 ? void 0 : val.space_amount;
        if (!(val.space_used == void 0) && !sdIsNumber(val.space_used)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_used" of type "User"',
            });
        }
        const spaceUsed = val.space_used == void 0 ? void 0 : val.space_used;
        if (!(val.max_upload_size == void 0) && !sdIsNumber(val.max_upload_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "max_upload_size" of type "User"',
            });
        }
        const maxUploadSize = val.max_upload_size == void 0 ? void 0 : val.max_upload_size;
        const status = val.status == void 0 ? void 0 : deserializeUserStatusField(val.status);
        if (!(val.job_title == void 0) && !sdIsString(val.job_title)) {
            throw new BoxSdkError({
                message: 'Expecting string for "job_title" of type "User"',
            });
        }
        const jobTitle = val.job_title == void 0 ? void 0 : val.job_title;
        if (!(val.phone == void 0) && !sdIsString(val.phone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "phone" of type "User"',
            });
        }
        const phone = val.phone == void 0 ? void 0 : val.phone;
        if (!(val.address == void 0) && !sdIsString(val.address)) {
            throw new BoxSdkError({
                message: 'Expecting string for "address" of type "User"',
            });
        }
        const address = val.address == void 0 ? void 0 : val.address;
        if (!(val.avatar_url == void 0) && !sdIsString(val.avatar_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "avatar_url" of type "User"',
            });
        }
        const avatarUrl = val.avatar_url == void 0 ? void 0 : val.avatar_url;
        const notificationEmail = val.notification_email == void 0
            ? void 0
            : deserializeUserNotificationEmailField(val.notification_email);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "User"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "User"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "User" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "User"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "User" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            language: language,
            timezone: timezone,
            spaceAmount: spaceAmount,
            spaceUsed: spaceUsed,
            maxUploadSize: maxUploadSize,
            status: status,
            jobTitle: jobTitle,
            phone: phone,
            address: address,
            avatarUrl: avatarUrl,
            notificationEmail: notificationEmail,
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function serializeTrackingCodeTypeField(val) {
        return val;
    }
    function deserializeTrackingCodeTypeField(val) {
        if (val == 'tracking_code') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize TrackingCodeTypeField" });
    }
    function serializeTrackingCode(val) {
        return {
            ['type']: val.type == void 0 ? val.type : serializeTrackingCodeTypeField(val.type),
            ['name']: val.name,
            ['value']: val.value,
        };
    }
    function deserializeTrackingCode(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TrackingCode"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeTrackingCodeTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TrackingCode"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.value == void 0) && !sdIsString(val.value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "value" of type "TrackingCode"',
            });
        }
        const value = val.value == void 0 ? void 0 : val.value;
        return { type: type, name: name, value: value };
    }

    function deserializeUserFullRoleField(val) {
        if (val == 'admin') {
            return val;
        }
        if (val == 'coadmin') {
            return val;
        }
        if (val == 'user') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize UserFullRoleField" });
    }
    function deserializeUserFullEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UserFullEnterpriseTypeField",
        });
    }
    function deserializeUserFullEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserFullEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserFullEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeUserFullEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserFullEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return { id: id, type: type, name: name };
    }
    function deserializeUserFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserFull"' });
        }
        const role = val.role == void 0 ? void 0 : deserializeUserFullRoleField(val.role);
        if (!(val.tracking_codes == void 0) && !sdIsList(val.tracking_codes)) {
            throw new BoxSdkError({
                message: 'Expecting array for "tracking_codes" of type "UserFull"',
            });
        }
        const trackingCodes = val.tracking_codes == void 0
            ? void 0
            : sdIsList(val.tracking_codes)
                ? val.tracking_codes.map(function (itm) {
                    return deserializeTrackingCode(itm);
                })
                : [];
        if (!(val.can_see_managed_users == void 0) &&
            !sdIsBoolean(val.can_see_managed_users)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_see_managed_users" of type "UserFull"',
            });
        }
        const canSeeManagedUsers = val.can_see_managed_users == void 0 ? void 0 : val.can_see_managed_users;
        if (!(val.is_sync_enabled == void 0) && !sdIsBoolean(val.is_sync_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_sync_enabled" of type "UserFull"',
            });
        }
        const isSyncEnabled = val.is_sync_enabled == void 0 ? void 0 : val.is_sync_enabled;
        if (!(val.is_external_collab_restricted == void 0) &&
            !sdIsBoolean(val.is_external_collab_restricted)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_external_collab_restricted" of type "UserFull"',
            });
        }
        const isExternalCollabRestricted = val.is_external_collab_restricted == void 0
            ? void 0
            : val.is_external_collab_restricted;
        if (!(val.is_exempt_from_device_limits == void 0) &&
            !sdIsBoolean(val.is_exempt_from_device_limits)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_exempt_from_device_limits" of type "UserFull"',
            });
        }
        const isExemptFromDeviceLimits = val.is_exempt_from_device_limits == void 0
            ? void 0
            : val.is_exempt_from_device_limits;
        if (!(val.is_exempt_from_login_verification == void 0) &&
            !sdIsBoolean(val.is_exempt_from_login_verification)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_exempt_from_login_verification" of type "UserFull"',
            });
        }
        const isExemptFromLoginVerification = val.is_exempt_from_login_verification == void 0
            ? void 0
            : val.is_exempt_from_login_verification;
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeUserFullEnterpriseField(val.enterprise);
        if (!(val.my_tags == void 0) && !sdIsList(val.my_tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "my_tags" of type "UserFull"',
            });
        }
        const myTags = val.my_tags == void 0
            ? void 0
            : sdIsList(val.my_tags)
                ? val.my_tags.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "UserFull"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.hostname == void 0) && !sdIsString(val.hostname)) {
            throw new BoxSdkError({
                message: 'Expecting string for "hostname" of type "UserFull"',
            });
        }
        const hostname = val.hostname == void 0 ? void 0 : val.hostname;
        if (!(val.is_platform_access_only == void 0) &&
            !sdIsBoolean(val.is_platform_access_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_platform_access_only" of type "UserFull"',
            });
        }
        const isPlatformAccessOnly = val.is_platform_access_only == void 0
            ? void 0
            : val.is_platform_access_only;
        if (!(val.external_app_user_id == void 0) &&
            !sdIsString(val.external_app_user_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_app_user_id" of type "UserFull"',
            });
        }
        const externalAppUserId = val.external_app_user_id == void 0 ? void 0 : val.external_app_user_id;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "UserFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "UserFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.language == void 0) && !sdIsString(val.language)) {
            throw new BoxSdkError({
                message: 'Expecting string for "language" of type "UserFull"',
            });
        }
        const language = val.language == void 0 ? void 0 : val.language;
        if (!(val.timezone == void 0) && !sdIsString(val.timezone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "timezone" of type "UserFull"',
            });
        }
        const timezone = val.timezone == void 0 ? void 0 : val.timezone;
        if (!(val.space_amount == void 0) && !sdIsNumber(val.space_amount)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_amount" of type "UserFull"',
            });
        }
        const spaceAmount = val.space_amount == void 0 ? void 0 : val.space_amount;
        if (!(val.space_used == void 0) && !sdIsNumber(val.space_used)) {
            throw new BoxSdkError({
                message: 'Expecting number for "space_used" of type "UserFull"',
            });
        }
        const spaceUsed = val.space_used == void 0 ? void 0 : val.space_used;
        if (!(val.max_upload_size == void 0) && !sdIsNumber(val.max_upload_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "max_upload_size" of type "UserFull"',
            });
        }
        const maxUploadSize = val.max_upload_size == void 0 ? void 0 : val.max_upload_size;
        const status = val.status == void 0 ? void 0 : deserializeUserStatusField(val.status);
        if (!(val.job_title == void 0) && !sdIsString(val.job_title)) {
            throw new BoxSdkError({
                message: 'Expecting string for "job_title" of type "UserFull"',
            });
        }
        const jobTitle = val.job_title == void 0 ? void 0 : val.job_title;
        if (!(val.phone == void 0) && !sdIsString(val.phone)) {
            throw new BoxSdkError({
                message: 'Expecting string for "phone" of type "UserFull"',
            });
        }
        const phone = val.phone == void 0 ? void 0 : val.phone;
        if (!(val.address == void 0) && !sdIsString(val.address)) {
            throw new BoxSdkError({
                message: 'Expecting string for "address" of type "UserFull"',
            });
        }
        const address = val.address == void 0 ? void 0 : val.address;
        if (!(val.avatar_url == void 0) && !sdIsString(val.avatar_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "avatar_url" of type "UserFull"',
            });
        }
        const avatarUrl = val.avatar_url == void 0 ? void 0 : val.avatar_url;
        const notificationEmail = val.notification_email == void 0
            ? void 0
            : deserializeUserNotificationEmailField(val.notification_email);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserFull"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserFull"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserFull" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            role: role,
            trackingCodes: trackingCodes,
            canSeeManagedUsers: canSeeManagedUsers,
            isSyncEnabled: isSyncEnabled,
            isExternalCollabRestricted: isExternalCollabRestricted,
            isExemptFromDeviceLimits: isExemptFromDeviceLimits,
            isExemptFromLoginVerification: isExemptFromLoginVerification,
            enterprise: enterprise,
            myTags: myTags,
            hostname: hostname,
            isPlatformAccessOnly: isPlatformAccessOnly,
            externalAppUserId: externalAppUserId,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            language: language,
            timezone: timezone,
            spaceAmount: spaceAmount,
            spaceUsed: spaceUsed,
            maxUploadSize: maxUploadSize,
            status: status,
            jobTitle: jobTitle,
            phone: phone,
            address: address,
            avatarUrl: avatarUrl,
            notificationEmail: notificationEmail,
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function deserializeUsersOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UsersOrderDirectionField",
        });
    }
    function deserializeUsersOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UsersOrderField"' });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "UsersOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeUsersOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeUsers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Users"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Users"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Users"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Users"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Users"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Users"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Users"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeUsersOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Users"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeUserFull(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            totalCount: totalCount,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class CreateUserOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateUserHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateUserByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteUserByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new DeleteUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUsersHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateUserHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetUserMeHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetUserByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateUserByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteUserByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UsersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns a list of all users for the Enterprise along with their `user_id`,
         * `public_name`, and `login`.
         *
         * The application and the authenticated user need to
         * have the permission to look up users in the entire
         * enterprise.
         * @param {GetUsersQueryParams} queryParams Query parameters of getUsers method
         * @param {GetUsersHeadersInput} headersInput Headers of getUsers method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<Users>}
         */
        getUsers() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetUsersHeaders({}), cancellationToken) {
                const headers = new GetUsersHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['filter_term']: toString(queryParams.filterTerm),
                    ['user_type']: toString(queryParams.userType),
                    ['external_app_user_id']: toString(queryParams.externalAppUserId),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                    ['usemarker']: toString(queryParams.usemarker),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUsers(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new managed user in an enterprise. This endpoint
         * is only available to users and applications with the right
         * admin permissions.
         * @param {CreateUserRequestBody} requestBody Request body of createUser method
         * @param {CreateUserOptionalsInput} optionalsInput
         * @returns {Promise<UserFull>}
         */
        createUser(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateUserOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateUserRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUserFull(response.data)), { rawData: response.data });
            });
        }
        /**
         * Retrieves information about the user who is currently authenticated.
         *
         * In the case of a client-side authenticated OAuth 2.0 application
         * this will be the user who authorized the app.
         *
         * In the case of a JWT, server-side authenticated application
         * this will be the service account that belongs to the application
         * by default.
         *
         * Use the `As-User` header to change who this API call is made on behalf of.
         * @param {GetUserMeQueryParams} queryParams Query parameters of getUserMe method
         * @param {GetUserMeHeadersInput} headersInput Headers of getUserMe method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<UserFull>}
         */
        getUserMe() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetUserMeHeaders({}), cancellationToken) {
                const headers = new GetUserMeHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/me'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUserFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves information about a user in the enterprise.
           *
           * The application and the authenticated user need to
           * have the permission to look up users in the entire
           * enterprise.
           *
           * This endpoint also returns a limited set of information
           * for external users who are collaborated on content
           * owned by the enterprise for authenticated users with the
           * right scopes. In this case, disallowed fields will return
           * null instead.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {GetUserByIdOptionalsInput} optionalsInput
           * @returns {Promise<UserFull>}
           */
        getUserById(userId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUserFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a managed or app user in an enterprise. This endpoint
           * is only available to users and applications with the right
           * admin permissions.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {UpdateUserByIdOptionalsInput} optionalsInput
           * @returns {Promise<UserFull>}
           */
        updateUserById(userId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new UpdateUserByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId)),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateUserByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUserFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a user. By default this will fail if the user
           * still owns any content. Move their owned content first
           * before proceeding, or use the `force` field to delete
           * the user and their files.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {DeleteUserByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteUserById(userId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new DeleteUserByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['notify']: toString(queryParams.notify),
                    ['force']: toString(queryParams.force),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId)),
                    method: 'DELETE',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateUserRequestBodyRoleField(val) {
        return val;
    }
    function serializeCreateUserRequestBodyStatusField(val) {
        return val;
    }
    function serializeCreateUserRequestBody(val) {
        return {
            ['name']: val.name,
            ['login']: val.login,
            ['is_platform_access_only']: val.isPlatformAccessOnly,
            ['role']: val.role == void 0
                ? val.role
                : serializeCreateUserRequestBodyRoleField(val.role),
            ['language']: val.language,
            ['is_sync_enabled']: val.isSyncEnabled,
            ['job_title']: val.jobTitle,
            ['phone']: val.phone,
            ['address']: val.address,
            ['space_amount']: val.spaceAmount,
            ['tracking_codes']: val.trackingCodes == void 0
                ? val.trackingCodes
                : val.trackingCodes.map(function (item) {
                    return serializeTrackingCode(item);
                }),
            ['can_see_managed_users']: val.canSeeManagedUsers,
            ['timezone']: val.timezone,
            ['is_external_collab_restricted']: val.isExternalCollabRestricted,
            ['is_exempt_from_device_limits']: val.isExemptFromDeviceLimits,
            ['is_exempt_from_login_verification']: val.isExemptFromLoginVerification,
            ['status']: val.status == void 0
                ? val.status
                : serializeCreateUserRequestBodyStatusField(val.status),
            ['external_app_user_id']: val.externalAppUserId,
        };
    }
    function serializeUpdateUserByIdRequestBodyRoleField(val) {
        return val;
    }
    function serializeUpdateUserByIdRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateUserByIdRequestBodyNotificationEmailField(val) {
        return { ['email']: val.email };
    }
    function serializeUpdateUserByIdRequestBody(val) {
        return {
            ['enterprise']: val.enterprise,
            ['notify']: val.notify,
            ['name']: val.name,
            ['login']: val.login,
            ['role']: val.role == void 0
                ? val.role
                : serializeUpdateUserByIdRequestBodyRoleField(val.role),
            ['language']: val.language,
            ['is_sync_enabled']: val.isSyncEnabled,
            ['job_title']: val.jobTitle,
            ['phone']: val.phone,
            ['address']: val.address,
            ['tracking_codes']: val.trackingCodes == void 0
                ? val.trackingCodes
                : val.trackingCodes.map(function (item) {
                    return serializeTrackingCode(item);
                }),
            ['can_see_managed_users']: val.canSeeManagedUsers,
            ['timezone']: val.timezone,
            ['is_external_collab_restricted']: val.isExternalCollabRestricted,
            ['is_exempt_from_device_limits']: val.isExemptFromDeviceLimits,
            ['is_exempt_from_login_verification']: val.isExemptFromLoginVerification,
            ['is_password_reset_required']: val.isPasswordResetRequired,
            ['status']: val.status == void 0
                ? val.status
                : serializeUpdateUserByIdRequestBodyStatusField(val.status),
            ['space_amount']: val.spaceAmount,
            ['notification_email']: val.notificationEmail == void 0
                ? val.notificationEmail
                : serializeUpdateUserByIdRequestBodyNotificationEmailField(val.notificationEmail),
            ['external_app_user_id']: val.externalAppUserId,
        };
    }

    function deserializeSessionTerminationMessage(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SessionTerminationMessage"',
            });
        }
        if (!(val.message == void 0) && !sdIsString(val.message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "message" of type "SessionTerminationMessage"',
            });
        }
        const message = val.message == void 0 ? void 0 : val.message;
        return { message: message };
    }

    class TerminateUsersSessionsOptionals {
        constructor(fields) {
            this.headers = new TerminateUsersSessionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class TerminateGroupsSessionsOptionals {
        constructor(fields) {
            this.headers = new TerminateGroupsSessionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class TerminateUsersSessionsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TerminateGroupsSessionsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SessionTerminationManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Validates the roles and permissions of the user,
         * and creates asynchronous jobs
         * to terminate the user's sessions.
         * Returns the status for the POST request.
         * @param {TerminateUsersSessionsRequestBody} requestBody Request body of terminateUsersSessions method
         * @param {TerminateUsersSessionsOptionalsInput} optionalsInput
         * @returns {Promise<SessionTerminationMessage>}
         */
        terminateUsersSessions(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new TerminateUsersSessionsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/terminate_sessions'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeTerminateUsersSessionsRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSessionTerminationMessage(response.data)), { rawData: response.data });
            });
        }
        /**
         * Validates the roles and permissions of the group,
         * and creates asynchronous jobs
         * to terminate the group's sessions.
         * Returns the status for the POST request.
         * @param {TerminateGroupsSessionsRequestBody} requestBody Request body of terminateGroupsSessions method
         * @param {TerminateGroupsSessionsOptionalsInput} optionalsInput
         * @returns {Promise<SessionTerminationMessage>}
         */
        terminateGroupsSessions(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new TerminateGroupsSessionsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/terminate_sessions'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeTerminateGroupsSessionsRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSessionTerminationMessage(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeTerminateUsersSessionsRequestBody(val) {
        return {
            ['user_ids']: val.userIds.map(function (item) {
                return item;
            }),
            ['user_logins']: val.userLogins.map(function (item) {
                return item;
            }),
        };
    }
    function serializeTerminateGroupsSessionsRequestBody(val) {
        return {
            ['group_ids']: val.groupIds.map(function (item) {
                return item;
            }),
        };
    }

    function deserializeUserAvatarPicUrlsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserAvatarPicUrlsField"',
            });
        }
        if (!(val.small == void 0) && !sdIsString(val.small)) {
            throw new BoxSdkError({
                message: 'Expecting string for "small" of type "UserAvatarPicUrlsField"',
            });
        }
        const small = val.small == void 0 ? void 0 : val.small;
        if (!(val.large == void 0) && !sdIsString(val.large)) {
            throw new BoxSdkError({
                message: 'Expecting string for "large" of type "UserAvatarPicUrlsField"',
            });
        }
        const large = val.large == void 0 ? void 0 : val.large;
        if (!(val.preview == void 0) && !sdIsString(val.preview)) {
            throw new BoxSdkError({
                message: 'Expecting string for "preview" of type "UserAvatarPicUrlsField"',
            });
        }
        const preview = val.preview == void 0 ? void 0 : val.preview;
        return {
            small: small,
            large: large,
            preview: preview,
        };
    }
    function deserializeUserAvatar(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserAvatar"' });
        }
        const picUrls = val.pic_urls == void 0
            ? void 0
            : deserializeUserAvatarPicUrlsField(val.pic_urls);
        return { picUrls: picUrls };
    }

    class GetUserAvatarOptionals {
        constructor(fields) {
            this.headers = new GetUserAvatarHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateUserAvatarOptionals {
        constructor(fields) {
            this.headers = new CreateUserAvatarHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteUserAvatarOptionals {
        constructor(fields) {
            this.headers = new DeleteUserAvatarHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserAvatarHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateUserAvatarHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteUserAvatarHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AvatarsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves an image of a the user's avatar.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {GetUserAvatarOptionalsInput} optionalsInput
           * @returns {Promise<ByteStream>}
           */
        getUserAvatar(userId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserAvatarOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/avatar'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return response.content;
            });
        }
        /**
           * Adds or updates a user avatar.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {CreateUserAvatarRequestBody} requestBody Request body of createUserAvatar method
           * @param {CreateUserAvatarOptionalsInput} optionalsInput
           * @returns {Promise<UserAvatar>}
           */
        createUserAvatar(userId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, requestBody, optionalsInput = {}) {
                const optionals = new CreateUserAvatarOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/avatar'),
                    method: 'POST',
                    headers: headersMap,
                    multipartData: [
                        {
                            partName: 'pic',
                            fileStream: requestBody.pic,
                            fileName: requestBody.picFileName,
                            contentType: requestBody.picContentType,
                        },
                    ],
                    contentType: 'multipart/form-data',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeUserAvatar(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes an existing user avatar.
           * You cannot reverse this operation.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {DeleteUserAvatarOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteUserAvatar(userId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new DeleteUserAvatarOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/avatar'),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }

    class TransferOwnedFolderOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new TransferOwnedFolderHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class TransferOwnedFolderHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TransferManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Move all of the items (files, folders and workflows) owned by a user into
           * another user's account
           *
           * Only the root folder (`0`) can be transferred.
           *
           * Folders can only be moved across users by users with administrative
           * permissions.
           *
           * All existing shared links and folder-level collaborations are transferred
           * during the operation. Please note that while collaborations at the individual
           * file-level are transferred during the operation, the collaborations are
           * deleted when the original user is deleted.
           *
           * If the user has a large number of items across all folders, the call will
           * be run asynchronously. If the operation is not completed within 10 minutes,
           * the user will receive a 200 OK response, and the operation will continue running.
           *
           * If the destination path has a metadata cascade policy attached to any of
           * the parent folders, a metadata cascade operation will be kicked off
           * asynchronously.
           *
           * There is currently no way to check for when this operation is finished.
           *
           * The destination folder's name will be in the format `{User}'s Files and
           * Folders`, where `{User}` is the display name of the user.
           *
           * To make this API call your application will need to have the "Read and write
           * all files and folders stored in Box" scope enabled.
           *
           * Please make sure the destination user has access to `Relay` or `Relay Lite`,
           * and has access to the files and folders involved in the workflows being
           * transferred.
           *
           * Admins will receive an email when the operation is completed.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {TransferOwnedFolderRequestBody} requestBody Request body of transferOwnedFolder method
           * @param {TransferOwnedFolderOptionalsInput} optionalsInput
           * @returns {Promise<FolderFull>}
           */
        transferOwnedFolder(userId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, requestBody, optionalsInput = {}) {
                const optionals = new TransferOwnedFolderOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['notify']: toString(queryParams.notify),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/folders/0'),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeTransferOwnedFolderRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFolderFull(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeTransferOwnedFolderRequestBodyOwnedByField(val) {
        return { ['id']: val.id };
    }
    function serializeTransferOwnedFolderRequestBody(val) {
        return {
            ['owned_by']: serializeTransferOwnedFolderRequestBodyOwnedByField(val.ownedBy),
        };
    }

    function deserializeEmailAliasTypeField(val) {
        if (val == 'email_alias') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize EmailAliasTypeField" });
    }
    function deserializeEmailAlias(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EmailAlias"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "EmailAlias"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeEmailAliasTypeField(val.type);
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "EmailAlias"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        if (!(val.is_confirmed == void 0) && !sdIsBoolean(val.is_confirmed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_confirmed" of type "EmailAlias"',
            });
        }
        const isConfirmed = val.is_confirmed == void 0 ? void 0 : val.is_confirmed;
        return {
            id: id,
            type: type,
            email: email,
            isConfirmed: isConfirmed,
        };
    }

    function deserializeEmailAliases(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EmailAliases"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "EmailAliases"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "EmailAliases"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeEmailAlias(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    class GetUserEmailAliasesOptionals {
        constructor(fields) {
            this.headers = new GetUserEmailAliasesHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateUserEmailAliasOptionals {
        constructor(fields) {
            this.headers = new CreateUserEmailAliasHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteUserEmailAliasByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteUserEmailAliasByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserEmailAliasesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateUserEmailAliasHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteUserEmailAliasByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class EmailAliasesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves all email aliases for a user. The collection
           * does not include the primary login for the user.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {GetUserEmailAliasesOptionalsInput} optionalsInput
           * @returns {Promise<EmailAliases>}
           */
        getUserEmailAliases(userId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserEmailAliasesOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/email_aliases'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeEmailAliases(response.data)), { rawData: response.data });
            });
        }
        /**
           * Adds a new email alias to a user account..
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {CreateUserEmailAliasRequestBody} requestBody Request body of createUserEmailAlias method
           * @param {CreateUserEmailAliasOptionalsInput} optionalsInput
           * @returns {Promise<EmailAlias>}
           */
        createUserEmailAlias(userId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, requestBody, optionalsInput = {}) {
                const optionals = new CreateUserEmailAliasOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/email_aliases'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateUserEmailAliasRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeEmailAlias(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes an email alias from a user.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {string} emailAliasId The ID of the email alias.
          Example: "23432"
           * @param {DeleteUserEmailAliasByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteUserEmailAliasById(userId_1, emailAliasId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, emailAliasId, optionalsInput = {}) {
                const optionals = new DeleteUserEmailAliasByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/email_aliases/', toString(emailAliasId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateUserEmailAliasRequestBody(val) {
        return { ['email']: val.email };
    }

    function deserializeGroupMembershipTypeField(val) {
        if (val == 'group_membership') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMembershipTypeField",
        });
    }
    function deserializeGroupMembershipRoleField(val) {
        if (val == 'member') {
            return val;
        }
        if (val == 'admin') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMembershipRoleField",
        });
    }
    function deserializeGroupMembership(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "GroupMembership"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupMembership"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeGroupMembershipTypeField(val.type);
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        const group = val.group == void 0 ? void 0 : deserializeGroupMini(val.group);
        const role = val.role == void 0 ? void 0 : deserializeGroupMembershipRoleField(val.role);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "GroupMembership"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "GroupMembership"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            user: user,
            group: group,
            role: role,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    function deserializeGroupMembershipsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMembershipsOrderDirectionField",
        });
    }
    function deserializeGroupMembershipsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupMembershipsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "GroupMembershipsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeGroupMembershipsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeGroupMemberships(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupMemberships"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "GroupMemberships"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "GroupMemberships"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "GroupMemberships"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "GroupMemberships"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeGroupMembershipsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "GroupMemberships"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeGroupMembership(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetUserMembershipsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetUserMembershipsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupMembershipsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupMembershipsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateGroupMembershipOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateGroupMembershipHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupMembershipByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupMembershipByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateGroupMembershipByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateGroupMembershipByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteGroupMembershipByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteGroupMembershipByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetUserMembershipsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupMembershipsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateGroupMembershipHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupMembershipByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateGroupMembershipByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteGroupMembershipByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class MembershipsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves all the groups for a user. Only members of this
           * group or users with admin-level permissions will be able to
           * use this API.
           * @param {string} userId The ID of the user.
          Example: "12345"
           * @param {GetUserMembershipsOptionalsInput} optionalsInput
           * @returns {Promise<GroupMemberships>}
           */
        getUserMemberships(userId_1) {
            return __awaiter$1(this, arguments, void 0, function* (userId, optionalsInput = {}) {
                const optionals = new GetUserMembershipsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/users/', toString(userId), '/memberships'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupMemberships(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves all the members for a group. Only members of this
           * group or users with admin-level permissions will be able to
           * use this API.
           * @param {string} groupId The ID of the group.
          Example: "57645"
           * @param {GetGroupMembershipsOptionalsInput} optionalsInput
           * @returns {Promise<GroupMemberships>}
           */
        getGroupMemberships(groupId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new GetGroupMembershipsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId), '/memberships'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupMemberships(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a group membership. Only users with
         * admin-level permissions will be able to use this API.
         * @param {CreateGroupMembershipRequestBody} requestBody Request body of createGroupMembership method
         * @param {CreateGroupMembershipOptionalsInput} optionalsInput
         * @returns {Promise<GroupMembership>}
         */
        createGroupMembership(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateGroupMembershipOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateGroupMembershipRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupMembership(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a specific group membership. Only admins of this
           * group or users with admin-level permissions will be able to
           * use this API.
           * @param {string} groupMembershipId The ID of the group membership.
          Example: "434534"
           * @param {GetGroupMembershipByIdOptionalsInput} optionalsInput
           * @returns {Promise<GroupMembership>}
           */
        getGroupMembershipById(groupMembershipId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupMembershipId, optionalsInput = {}) {
                const optionals = new GetGroupMembershipByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships/', toString(groupMembershipId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupMembership(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a user's group membership. Only admins of this
           * group or users with admin-level permissions will be able to
           * use this API.
           * @param {string} groupMembershipId The ID of the group membership.
          Example: "434534"
           * @param {UpdateGroupMembershipByIdOptionalsInput} optionalsInput
           * @returns {Promise<GroupMembership>}
           */
        updateGroupMembershipById(groupMembershipId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupMembershipId, optionalsInput = {}) {
                const optionals = new UpdateGroupMembershipByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships/', toString(groupMembershipId)),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateGroupMembershipByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupMembership(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a specific group membership. Only admins of this
           * group or users with admin-level permissions will be able to
           * use this API.
           * @param {string} groupMembershipId The ID of the group membership.
          Example: "434534"
           * @param {DeleteGroupMembershipByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteGroupMembershipById(groupMembershipId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupMembershipId, optionalsInput = {}) {
                const optionals = new DeleteGroupMembershipByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/group_memberships/', toString(groupMembershipId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateGroupMembershipRequestBodyUserField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateGroupMembershipRequestBodyGroupField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateGroupMembershipRequestBodyRoleField(val) {
        return val;
    }
    function serializeCreateGroupMembershipRequestBody(val) {
        return {
            ['user']: serializeCreateGroupMembershipRequestBodyUserField(val.user),
            ['group']: serializeCreateGroupMembershipRequestBodyGroupField(val.group),
            ['role']: val.role == void 0
                ? val.role
                : serializeCreateGroupMembershipRequestBodyRoleField(val.role),
            ['configurable_permissions']: val.configurablePermissions == void 0
                ? val.configurablePermissions
                : val.configurablePermissions,
        };
    }
    function serializeUpdateGroupMembershipByIdRequestBodyRoleField(val) {
        return val;
    }
    function serializeUpdateGroupMembershipByIdRequestBody(val) {
        return {
            ['role']: val.role == void 0
                ? val.role
                : serializeUpdateGroupMembershipByIdRequestBodyRoleField(val.role),
            ['configurable_permissions']: val.configurablePermissions == void 0
                ? val.configurablePermissions
                : val.configurablePermissions,
        };
    }

    function deserializeInviteTypeField(val) {
        if (val == 'invite') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize InviteTypeField" });
    }
    function deserializeInviteInvitedToTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize InviteInvitedToTypeField",
        });
    }
    function deserializeInviteInvitedToField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "InviteInvitedToField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "InviteInvitedToField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeInviteInvitedToTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "InviteInvitedToField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return { id: id, type: type, name: name };
    }
    function deserializeInvite(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Invite"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "Invite" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Invite"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "Invite" to be defined',
            });
        }
        const type = deserializeInviteTypeField(val.type);
        const invitedTo = val.invited_to == void 0
            ? void 0
            : deserializeInviteInvitedToField(val.invited_to);
        const actionableBy = val.actionable_by == void 0
            ? void 0
            : deserializeUserMini(val.actionable_by);
        const invitedBy = val.invited_by == void 0 ? void 0 : deserializeUserMini(val.invited_by);
        if (!(val.status == void 0) && !sdIsString(val.status)) {
            throw new BoxSdkError({
                message: 'Expecting string for "status" of type "Invite"',
            });
        }
        const status = val.status == void 0 ? void 0 : val.status;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Invite"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "Invite"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            invitedTo: invitedTo,
            actionableBy: actionableBy,
            invitedBy: invitedBy,
            status: status,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    class CreateInviteOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateInviteHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetInviteByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetInviteByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateInviteHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetInviteByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class InvitesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Invites an existing external user to join an enterprise.
         *
         * The existing user can not be part of another enterprise and
         * must already have a Box account. Once invited, the user will receive an
         * email and are prompted to accept the invitation within the
         * Box web application.
         *
         * This method requires the "Manage An Enterprise" scope enabled for
         * the application, which can be enabled within the developer console.
         * @param {CreateInviteRequestBody} requestBody Request body of createInvite method
         * @param {CreateInviteOptionalsInput} optionalsInput
         * @returns {Promise<Invite>}
         */
        createInvite(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateInviteOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/invites'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateInviteRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeInvite(response.data)), { rawData: response.data });
            });
        }
        /**
           * Returns the status of a user invite.
           * @param {string} inviteId The ID of an invite.
          Example: "213723"
           * @param {GetInviteByIdOptionalsInput} optionalsInput
           * @returns {Promise<Invite>}
           */
        getInviteById(inviteId_1) {
            return __awaiter$1(this, arguments, void 0, function* (inviteId, optionalsInput = {}) {
                const optionals = new GetInviteByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/invites/', toString(inviteId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeInvite(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeCreateInviteRequestBodyEnterpriseField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateInviteRequestBodyActionableByField(val) {
        return { ['login']: val.login };
    }
    function serializeCreateInviteRequestBody(val) {
        return {
            ['enterprise']: serializeCreateInviteRequestBodyEnterpriseField(val.enterprise),
            ['actionable_by']: serializeCreateInviteRequestBodyActionableByField(val.actionableBy),
        };
    }

    function deserializeGroupFullInvitabilityLevelField(val) {
        if (val == 'admins_only') {
            return val;
        }
        if (val == 'admins_and_members') {
            return val;
        }
        if (val == 'all_managed_users') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupFullInvitabilityLevelField",
        });
    }
    function deserializeGroupFullMemberViewabilityLevelField(val) {
        if (val == 'admins_only') {
            return val;
        }
        if (val == 'admins_and_members') {
            return val;
        }
        if (val == 'all_managed_users') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupFullMemberViewabilityLevelField",
        });
    }
    function deserializeGroupFullPermissionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupFullPermissionsField"',
            });
        }
        if (!(val.can_invite_as_collaborator == void 0) &&
            !sdIsBoolean(val.can_invite_as_collaborator)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_invite_as_collaborator" of type "GroupFullPermissionsField"',
            });
        }
        const canInviteAsCollaborator = val.can_invite_as_collaborator == void 0
            ? void 0
            : val.can_invite_as_collaborator;
        return {
            canInviteAsCollaborator: canInviteAsCollaborator,
        };
    }
    function deserializeGroupFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "GroupFull"' });
        }
        if (!(val.provenance == void 0) && !sdIsString(val.provenance)) {
            throw new BoxSdkError({
                message: 'Expecting string for "provenance" of type "GroupFull"',
            });
        }
        const provenance = val.provenance == void 0 ? void 0 : val.provenance;
        if (!(val.external_sync_identifier == void 0) &&
            !sdIsString(val.external_sync_identifier)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_sync_identifier" of type "GroupFull"',
            });
        }
        const externalSyncIdentifier = val.external_sync_identifier == void 0
            ? void 0
            : val.external_sync_identifier;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "GroupFull"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const invitabilityLevel = val.invitability_level == void 0
            ? void 0
            : deserializeGroupFullInvitabilityLevelField(val.invitability_level);
        const memberViewabilityLevel = val.member_viewability_level == void 0
            ? void 0
            : deserializeGroupFullMemberViewabilityLevelField(val.member_viewability_level);
        const permissions = val.permissions == void 0
            ? void 0
            : deserializeGroupFullPermissionsField(val.permissions);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "GroupFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "GroupFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "GroupFull"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const groupType = val.group_type == void 0
            ? void 0
            : deserializeGroupMiniGroupTypeField(val.group_type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "GroupFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupFull"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "GroupFull" to be defined',
            });
        }
        const type = deserializeGroupBaseTypeField(val.type);
        return {
            provenance: provenance,
            externalSyncIdentifier: externalSyncIdentifier,
            description: description,
            invitabilityLevel: invitabilityLevel,
            memberViewabilityLevel: memberViewabilityLevel,
            permissions: permissions,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            name: name,
            groupType: groupType,
            id: id,
            type: type,
        };
    }

    function deserializeGroupsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupsOrderDirectionField",
        });
    }
    function deserializeGroupsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "GroupsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeGroupsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeGroups(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Groups"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Groups"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Groups"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Groups"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Groups"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeGroupsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Groups"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeGroupFull(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class CreateGroupOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new CreateGroupHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetGroupByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateGroupByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.queryParams = {};
            this.headers = new UpdateGroupByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteGroupByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteGroupByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetGroupsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateGroupHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetGroupByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateGroupByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteGroupByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GroupsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all of the groups for a given enterprise. The user
         * must have admin permissions to inspect enterprise's groups.
         * @param {GetGroupsQueryParams} queryParams Query parameters of getGroups method
         * @param {GetGroupsHeadersInput} headersInput Headers of getGroups method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<Groups>}
         */
        getGroups() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetGroupsHeaders({}), cancellationToken) {
                const headers = new GetGroupsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['filter_term']: toString(queryParams.filterTerm),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['offset']: toString(queryParams.offset),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroups(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new group of users in an enterprise. Only users with admin
         * permissions can create new groups.
         * @param {CreateGroupRequestBody} requestBody Request body of createGroup method
         * @param {CreateGroupOptionalsInput} optionalsInput
         * @returns {Promise<GroupFull>}
         */
        createGroup(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateGroupOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups'),
                    method: 'POST',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeCreateGroupRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves information about a group. Only members of this
           * group or users with admin-level permissions will be able to
           * use this API.
           * @param {string} groupId The ID of the group.
          Example: "57645"
           * @param {GetGroupByIdOptionalsInput} optionalsInput
           * @returns {Promise<GroupFull>}
           */
        getGroupById(groupId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new GetGroupByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a specific group. Only admins of this
           * group or users with admin-level permissions will be able to
           * use this API.
           * @param {string} groupId The ID of the group.
          Example: "57645"
           * @param {UpdateGroupByIdOptionalsInput} optionalsInput
           * @returns {Promise<GroupFull>}
           */
        updateGroupById(groupId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new UpdateGroupByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId)),
                    method: 'PUT',
                    params: queryParamsMap,
                    headers: headersMap,
                    data: serializeUpdateGroupByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeGroupFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Permanently deletes a group. Only users with
           * admin-level permissions will be able to use this API.
           * @param {string} groupId The ID of the group.
          Example: "57645"
           * @param {DeleteGroupByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteGroupById(groupId_1) {
            return __awaiter$1(this, arguments, void 0, function* (groupId, optionalsInput = {}) {
                const optionals = new DeleteGroupByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/groups/', toString(groupId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateGroupRequestBodyInvitabilityLevelField(val) {
        return val;
    }
    function serializeCreateGroupRequestBodyMemberViewabilityLevelField(val) {
        return val;
    }
    function serializeCreateGroupRequestBody(val) {
        return {
            ['name']: val.name,
            ['provenance']: val.provenance,
            ['external_sync_identifier']: val.externalSyncIdentifier,
            ['description']: val.description,
            ['invitability_level']: val.invitabilityLevel == void 0
                ? val.invitabilityLevel
                : serializeCreateGroupRequestBodyInvitabilityLevelField(val.invitabilityLevel),
            ['member_viewability_level']: val.memberViewabilityLevel == void 0
                ? val.memberViewabilityLevel
                : serializeCreateGroupRequestBodyMemberViewabilityLevelField(val.memberViewabilityLevel),
        };
    }
    function serializeUpdateGroupByIdRequestBodyInvitabilityLevelField(val) {
        return val;
    }
    function serializeUpdateGroupByIdRequestBodyMemberViewabilityLevelField(val) {
        return val;
    }
    function serializeUpdateGroupByIdRequestBody(val) {
        return {
            ['name']: val.name,
            ['provenance']: val.provenance,
            ['external_sync_identifier']: val.externalSyncIdentifier,
            ['description']: val.description,
            ['invitability_level']: val.invitabilityLevel == void 0
                ? val.invitabilityLevel
                : serializeUpdateGroupByIdRequestBodyInvitabilityLevelField(val.invitabilityLevel),
            ['member_viewability_level']: val.memberViewabilityLevel == void 0
                ? val.memberViewabilityLevel
                : serializeUpdateGroupByIdRequestBodyMemberViewabilityLevelField(val.memberViewabilityLevel),
        };
    }

    function deserializeWebhookMiniTypeField(val) {
        if (val == 'webhook') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WebhookMiniTypeField" });
    }
    function deserializeWebhookMiniTargetTypeField(val) {
        if (val == 'file') {
            return val;
        }
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WebhookMiniTargetTypeField",
        });
    }
    function deserializeWebhookMiniTargetField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WebhookMiniTargetField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WebhookMiniTargetField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeWebhookMiniTargetTypeField(val.type);
        return { id: id, type: type };
    }
    function deserializeWebhookMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "WebhookMini"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WebhookMini"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWebhookMiniTypeField(val.type);
        const target = val.target == void 0
            ? void 0
            : deserializeWebhookMiniTargetField(val.target);
        return { id: id, type: type, target: target };
    }

    function deserializeWebhooks(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Webhooks"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Webhooks"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Webhooks"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Webhooks"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Webhooks"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeWebhookMini(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function deserializeWebhookTriggersField(val) {
        if (val == 'FILE.UPLOADED') {
            return val;
        }
        if (val == 'FILE.PREVIEWED') {
            return val;
        }
        if (val == 'FILE.DOWNLOADED') {
            return val;
        }
        if (val == 'FILE.TRASHED') {
            return val;
        }
        if (val == 'FILE.DELETED') {
            return val;
        }
        if (val == 'FILE.RESTORED') {
            return val;
        }
        if (val == 'FILE.COPIED') {
            return val;
        }
        if (val == 'FILE.MOVED') {
            return val;
        }
        if (val == 'FILE.LOCKED') {
            return val;
        }
        if (val == 'FILE.UNLOCKED') {
            return val;
        }
        if (val == 'FILE.RENAMED') {
            return val;
        }
        if (val == 'COMMENT.CREATED') {
            return val;
        }
        if (val == 'COMMENT.UPDATED') {
            return val;
        }
        if (val == 'COMMENT.DELETED') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT.CREATED') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT.UPDATED') {
            return val;
        }
        if (val == 'METADATA_INSTANCE.CREATED') {
            return val;
        }
        if (val == 'METADATA_INSTANCE.UPDATED') {
            return val;
        }
        if (val == 'METADATA_INSTANCE.DELETED') {
            return val;
        }
        if (val == 'FOLDER.CREATED') {
            return val;
        }
        if (val == 'FOLDER.RENAMED') {
            return val;
        }
        if (val == 'FOLDER.DOWNLOADED') {
            return val;
        }
        if (val == 'FOLDER.RESTORED') {
            return val;
        }
        if (val == 'FOLDER.DELETED') {
            return val;
        }
        if (val == 'FOLDER.COPIED') {
            return val;
        }
        if (val == 'FOLDER.MOVED') {
            return val;
        }
        if (val == 'FOLDER.TRASHED') {
            return val;
        }
        if (val == 'WEBHOOK.DELETED') {
            return val;
        }
        if (val == 'COLLABORATION.CREATED') {
            return val;
        }
        if (val == 'COLLABORATION.ACCEPTED') {
            return val;
        }
        if (val == 'COLLABORATION.REJECTED') {
            return val;
        }
        if (val == 'COLLABORATION.REMOVED') {
            return val;
        }
        if (val == 'COLLABORATION.UPDATED') {
            return val;
        }
        if (val == 'SHARED_LINK.DELETED') {
            return val;
        }
        if (val == 'SHARED_LINK.CREATED') {
            return val;
        }
        if (val == 'SHARED_LINK.UPDATED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.COMPLETED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.DECLINED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.EXPIRED') {
            return val;
        }
        if (val == 'SIGN_REQUEST.SIGNER_EMAIL_BOUNCED') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WebhookTriggersField" });
    }
    function deserializeWebhook(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Webhook"' });
        }
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Webhook"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.address == void 0) && !sdIsString(val.address)) {
            throw new BoxSdkError({
                message: 'Expecting string for "address" of type "Webhook"',
            });
        }
        const address = val.address == void 0 ? void 0 : val.address;
        if (!(val.triggers == void 0) && !sdIsList(val.triggers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "triggers" of type "Webhook"',
            });
        }
        const triggers = val.triggers == void 0
            ? void 0
            : sdIsList(val.triggers)
                ? val.triggers.map(function (itm) {
                    return deserializeWebhookTriggersField(itm);
                })
                : [];
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Webhook"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWebhookMiniTypeField(val.type);
        const target = val.target == void 0
            ? void 0
            : deserializeWebhookMiniTargetField(val.target);
        return {
            createdBy: createdBy,
            createdAt: createdAt,
            address: address,
            triggers: triggers,
            id: id,
            type: type,
            target: target,
        };
    }

    class CreateWebhookOptionals {
        constructor(fields) {
            this.headers = new CreateWebhookHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetWebhookByIdOptionals {
        constructor(fields) {
            this.headers = new GetWebhookByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateWebhookByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateWebhookByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteWebhookByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteWebhookByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class ValidateMessageOptionals {
        constructor(fields) {
            this.secondaryKey = void 0;
            this.maxAge = 600;
            if (fields.secondaryKey !== undefined) {
                this.secondaryKey = fields.secondaryKey;
            }
            if (fields.maxAge !== undefined) {
                this.maxAge = fields.maxAge;
            }
        }
    }
    class GetWebhooksHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateWebhookHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetWebhookByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateWebhookByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteWebhookByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class WebhooksManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns all defined webhooks for the requesting application.
         *
         * This API only returns webhooks that are applied to files or folders that are
         * owned by the authenticated user. This means that an admin can not see webhooks
         * created by a service account unless the admin has access to those folders, and
         * vice versa.
         * @param {GetWebhooksQueryParams} queryParams Query parameters of getWebhooks method
         * @param {GetWebhooksHeadersInput} headersInput Headers of getWebhooks method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<Webhooks>}
         */
        getWebhooks() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetWebhooksHeaders({}), cancellationToken) {
                const headers = new GetWebhooksHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebhooks(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a webhook.
         * @param {CreateWebhookRequestBody} requestBody Request body of createWebhook method
         * @param {CreateWebhookOptionalsInput} optionalsInput
         * @returns {Promise<Webhook>}
         */
        createWebhook(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateWebhookOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateWebhookRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebhook(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a specific webhook.
           * @param {string} webhookId The ID of the webhook.
          Example: "3321123"
           * @param {GetWebhookByIdOptionalsInput} optionalsInput
           * @returns {Promise<Webhook>}
           */
        getWebhookById(webhookId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webhookId, optionalsInput = {}) {
                const optionals = new GetWebhookByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks/', toString(webhookId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebhook(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a webhook.
           * @param {string} webhookId The ID of the webhook.
          Example: "3321123"
           * @param {UpdateWebhookByIdOptionalsInput} optionalsInput
           * @returns {Promise<Webhook>}
           */
        updateWebhookById(webhookId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webhookId, optionalsInput = {}) {
                const optionals = new UpdateWebhookByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks/', toString(webhookId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateWebhookByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWebhook(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a webhook.
           * @param {string} webhookId The ID of the webhook.
          Example: "3321123"
           * @param {DeleteWebhookByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteWebhookById(webhookId_1) {
            return __awaiter$1(this, arguments, void 0, function* (webhookId, optionalsInput = {}) {
                const optionals = new DeleteWebhookByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/webhooks/', toString(webhookId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Validate a webhook message by verifying the signature and the delivery timestamp
           * @param {string} body The request body of the webhook message
           * @param {{
              readonly [key: string]: string;
          }} headers The headers of the webhook message
           * @param {string} primaryKey The primary signature to verify the message with
           * @param {ValidateMessageOptionalsInput} optionalsInput
           * @returns {Promise<boolean>}
           */
        static validateMessage(body_1, headers_1, primaryKey_1) {
            return __awaiter$1(this, arguments, void 0, function* (body, headers, primaryKey, optionalsInput = {}) {
                const optionals = new ValidateMessageOptionals({
                    secondaryKey: optionalsInput.secondaryKey,
                    maxAge: optionalsInput.maxAge,
                });
                const secondaryKey = optionals.secondaryKey;
                const maxAge = optionals.maxAge;
                const deliveryTimestamp = dateTimeFromString(headers['box-delivery-timestamp']);
                const currentEpoch = getEpochTimeInSeconds();
                if (currentEpoch - maxAge > dateTimeToEpochSeconds(deliveryTimestamp) ||
                    dateTimeToEpochSeconds(deliveryTimestamp) > currentEpoch) {
                    return false;
                }
                if (!(primaryKey == void 0) &&
                    !(headers['box-signature-primary'] == void 0) &&
                    (yield compareSignatures(yield computeWebhookSignature(body, headers, primaryKey, false), headers['box-signature-primary']))) {
                    return true;
                }
                if (!(primaryKey == void 0) &&
                    !(headers['box-signature-primary'] == void 0) &&
                    (yield compareSignatures(yield computeWebhookSignature(body, headers, primaryKey, true), headers['box-signature-primary']))) {
                    return true;
                }
                if (!(secondaryKey == void 0) &&
                    !(headers['box-signature-secondary'] == void 0) &&
                    (yield compareSignatures(yield computeWebhookSignature(body, headers, secondaryKey, false), headers['box-signature-secondary']))) {
                    return true;
                }
                if (!(secondaryKey == void 0) &&
                    !(headers['box-signature-secondary'] == void 0) &&
                    (yield compareSignatures(yield computeWebhookSignature(body, headers, secondaryKey, true), headers['box-signature-secondary']))) {
                    return true;
                }
                return false;
            });
        }
    }
    function serializeCreateWebhookRequestBodyTargetTypeField(val) {
        return val;
    }
    function serializeCreateWebhookRequestBodyTargetField(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeCreateWebhookRequestBodyTargetTypeField(val.type),
        };
    }
    function serializeCreateWebhookRequestBodyTriggersField(val) {
        return val;
    }
    function serializeCreateWebhookRequestBody(val) {
        return {
            ['target']: serializeCreateWebhookRequestBodyTargetField(val.target),
            ['address']: val.address,
            ['triggers']: val.triggers.map(function (item) {
                return serializeCreateWebhookRequestBodyTriggersField(item);
            }),
        };
    }
    function serializeUpdateWebhookByIdRequestBodyTargetTypeField(val) {
        return val;
    }
    function serializeUpdateWebhookByIdRequestBodyTargetField(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeUpdateWebhookByIdRequestBodyTargetTypeField(val.type),
        };
    }
    function serializeUpdateWebhookByIdRequestBodyTriggersField(val) {
        return val;
    }
    function serializeUpdateWebhookByIdRequestBody(val) {
        return {
            ['target']: val.target == void 0
                ? val.target
                : serializeUpdateWebhookByIdRequestBodyTargetField(val.target),
            ['address']: val.address,
            ['triggers']: val.triggers == void 0
                ? val.triggers
                : val.triggers.map(function (item) {
                    return serializeUpdateWebhookByIdRequestBodyTriggersField(item);
                }),
        };
    }

    function deserializeRealtimeServer(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RealtimeServer"' });
        }
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "RealtimeServer"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "RealtimeServer"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.ttl == void 0) && !sdIsString(val.ttl)) {
            throw new BoxSdkError({
                message: 'Expecting string for "ttl" of type "RealtimeServer"',
            });
        }
        const ttl = val.ttl == void 0 ? void 0 : val.ttl;
        if (!(val.max_retries == void 0) && !sdIsString(val.max_retries)) {
            throw new BoxSdkError({
                message: 'Expecting string for "max_retries" of type "RealtimeServer"',
            });
        }
        const maxRetries = val.max_retries == void 0 ? void 0 : val.max_retries;
        if (!(val.retry_timeout == void 0) && !sdIsNumber(val.retry_timeout)) {
            throw new BoxSdkError({
                message: 'Expecting number for "retry_timeout" of type "RealtimeServer"',
            });
        }
        const retryTimeout = val.retry_timeout == void 0 ? void 0 : val.retry_timeout;
        return {
            type: type,
            url: url,
            ttl: ttl,
            maxRetries: maxRetries,
            retryTimeout: retryTimeout,
        };
    }

    function deserializeRealtimeServers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RealtimeServers"' });
        }
        if (!(val.chunk_size == void 0) && !sdIsNumber(val.chunk_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "chunk_size" of type "RealtimeServers"',
            });
        }
        const chunkSize = val.chunk_size == void 0 ? void 0 : val.chunk_size;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RealtimeServers"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRealtimeServer(itm);
                })
                : [];
        return { chunkSize: chunkSize, entries: entries };
    }

    function deserializeAppItemEventSourceTypeField(val) {
        if (val == 'app_item') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AppItemEventSourceTypeField",
        });
    }
    function deserializeAppItemEventSource(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemEventSource"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "AppItemEventSource" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AppItemEventSource"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AppItemEventSource" to be defined',
            });
        }
        const type = deserializeAppItemEventSourceTypeField(val.type);
        if (val.app_item_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "app_item_type" of type "AppItemEventSource" to be defined',
            });
        }
        if (!sdIsString(val.app_item_type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "app_item_type" of type "AppItemEventSource"',
            });
        }
        const appItemType = val.app_item_type;
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        const group = val.group == void 0 ? void 0 : deserializeGroupMini(val.group);
        return {
            id: id,
            type: type,
            appItemType: appItemType,
            user: user,
            group: group,
        };
    }

    function deserializeEventSourceItemTypeField(val) {
        if (val == 'file') {
            return val;
        }
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize EventSourceItemTypeField",
        });
    }
    function deserializeEventSourceClassificationField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "EventSourceClassificationField"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "EventSourceClassificationField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return { name: name };
    }
    function deserializeEventSource(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EventSource"' });
        }
        if (val.item_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_type" of type "EventSource" to be defined',
            });
        }
        const itemType = deserializeEventSourceItemTypeField(val.item_type);
        if (val.item_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_id" of type "EventSource" to be defined',
            });
        }
        if (!sdIsString(val.item_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "item_id" of type "EventSource"',
            });
        }
        const itemId = val.item_id;
        if (val.item_name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "item_name" of type "EventSource" to be defined',
            });
        }
        if (!sdIsString(val.item_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "item_name" of type "EventSource"',
            });
        }
        const itemName = val.item_name;
        const classification = val.classification == void 0
            ? void 0
            : deserializeEventSourceClassificationField(val.classification);
        const parent = val.parent == void 0 ? void 0 : deserializeFolderMini(val.parent);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        return {
            itemType: itemType,
            itemId: itemId,
            itemName: itemName,
            classification: classification,
            parent: parent,
            ownedBy: ownedBy,
        };
    }

    function deserializeGenericSource(val) {
        return sdIsMap(val)
            ? Object.fromEntries(Object.entries(val).map(([k, v]) => [
                k,
                (function (v) {
                    return v;
                })(v),
            ]))
            : {};
    }

    function deserializeAppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser"',
            });
        }
        if (val.type == 'app_item') {
            return deserializeAppItemEventSource(val);
        }
        if (val.type == 'file') {
            return deserializeFile(val);
        }
        if (val.type == 'folder') {
            return deserializeFolder(val);
        }
        if (val.type == 'user') {
            return deserializeUser(val);
        }
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser"',
            });
        }
        if (val.item_type == 'file') {
            return deserializeEventSource(val);
        }
        if (val.item_type == 'folder') {
            return deserializeEventSource(val);
        }
        try {
            return deserializeGenericSource(val);
        }
        catch (error) {
        }
        finally {
        }
        throw new BoxSdkError({
            message: "Can't deserialize AppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser",
        });
    }

    function deserializeEventEventTypeField(val) {
        if (val == 'ACCESS_GRANTED') {
            return val;
        }
        if (val == 'ACCESS_REVOKED') {
            return val;
        }
        if (val == 'ADD_DEVICE_ASSOCIATION') {
            return val;
        }
        if (val == 'ADD_LOGIN_ACTIVITY_DEVICE') {
            return val;
        }
        if (val == 'ADMIN_LOGIN') {
            return val;
        }
        if (val == 'APPLICATION_CREATED') {
            return val;
        }
        if (val == 'APPLICATION_PUBLIC_KEY_ADDED') {
            return val;
        }
        if (val == 'APPLICATION_PUBLIC_KEY_DELETED') {
            return val;
        }
        if (val == 'CHANGE_ADMIN_ROLE') {
            return val;
        }
        if (val == 'CHANGE_FOLDER_PERMISSION') {
            return val;
        }
        if (val == 'COLLABORATION_ACCEPT') {
            return val;
        }
        if (val == 'COLLABORATION_EXPIRATION') {
            return val;
        }
        if (val == 'COLLABORATION_INVITE') {
            return val;
        }
        if (val == 'COLLABORATION_REMOVE') {
            return val;
        }
        if (val == 'COLLABORATION_ROLE_CHANGE') {
            return val;
        }
        if (val == 'COLLAB_ADD_COLLABORATOR') {
            return val;
        }
        if (val == 'COLLAB_INVITE_COLLABORATOR') {
            return val;
        }
        if (val == 'COLLAB_REMOVE_COLLABORATOR') {
            return val;
        }
        if (val == 'COLLAB_ROLE_CHANGE') {
            return val;
        }
        if (val == 'COMMENT_CREATE') {
            return val;
        }
        if (val == 'COMMENT_DELETE') {
            return val;
        }
        if (val == 'CONTENT_ACCESS') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_ABNORMAL_DOWNLOAD_ACTIVITY') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_AUTOMATION_ADD') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_AUTOMATION_DELETE') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_POLICY_ADD') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_SHARING_POLICY_VIOLATION') {
            return val;
        }
        if (val == 'CONTENT_WORKFLOW_UPLOAD_POLICY_VIOLATION') {
            return val;
        }
        if (val == 'COPY') {
            return val;
        }
        if (val == 'DATA_RETENTION_CREATE_RETENTION') {
            return val;
        }
        if (val == 'DATA_RETENTION_REMOVE_RETENTION') {
            return val;
        }
        if (val == 'DELETE') {
            return val;
        }
        if (val == 'DELETE_USER') {
            return val;
        }
        if (val == 'DEVICE_TRUST_CHECK_FAILED') {
            return val;
        }
        if (val == 'DOWNLOAD') {
            return val;
        }
        if (val == 'EDIT') {
            return val;
        }
        if (val == 'EDIT_USER') {
            return val;
        }
        if (val == 'EDR_CROWDSTRIKE_DEVICE_DETECTED') {
            return val;
        }
        if (val == 'EDR_CROWDSTRIKE_NO_BOX_TOOLS') {
            return val;
        }
        if (val == 'EDR_CROWDSTRIKE_BOX_TOOLS_OUTDATED') {
            return val;
        }
        if (val == 'EDR_CROWDSTRIKE_DRIVE_OUTDATED') {
            return val;
        }
        if (val == 'EDR_CROWDSTRIKE_ACCESS_ALLOWED_NO_CROWDSTRIKE_DEVICE') {
            return val;
        }
        if (val == 'EDR_CROWDSTRIKE_ACCESS_REVOKED') {
            return val;
        }
        if (val == 'EMAIL_ALIAS_CONFIRM') {
            return val;
        }
        if (val == 'EMAIL_ALIAS_REMOVE') {
            return val;
        }
        if (val == 'ENABLE_TWO_FACTOR_AUTH') {
            return val;
        }
        if (val == 'ENTERPRISE_APP_AUTHORIZATION_UPDATE') {
            return val;
        }
        if (val == 'FAILED_LOGIN') {
            return val;
        }
        if (val == 'FILE_MARKED_MALICIOUS') {
            return val;
        }
        if (val == 'FILE_WATERMARKED_DOWNLOAD') {
            return val;
        }
        if (val == 'GROUP_ADD_ITEM') {
            return val;
        }
        if (val == 'GROUP_ADD_USER') {
            return val;
        }
        if (val == 'GROUP_CREATION') {
            return val;
        }
        if (val == 'GROUP_DELETION') {
            return val;
        }
        if (val == 'GROUP_EDITED') {
            return val;
        }
        if (val == 'GROUP_REMOVE_ITEM') {
            return val;
        }
        if (val == 'GROUP_REMOVE_USER') {
            return val;
        }
        if (val == 'ITEM_COPY') {
            return val;
        }
        if (val == 'ITEM_CREATE') {
            return val;
        }
        if (val == 'ITEM_DOWNLOAD') {
            return val;
        }
        if (val == 'ITEM_EMAIL_SEND') {
            return val;
        }
        if (val == 'ITEM_MAKE_CURRENT_VERSION') {
            return val;
        }
        if (val == 'ITEM_MODIFY') {
            return val;
        }
        if (val == 'ITEM_MOVE') {
            return val;
        }
        if (val == 'ITEM_OPEN') {
            return val;
        }
        if (val == 'ITEM_PREVIEW') {
            return val;
        }
        if (val == 'ITEM_RENAME') {
            return val;
        }
        if (val == 'ITEM_SHARED') {
            return val;
        }
        if (val == 'ITEM_SHARED_CREATE') {
            return val;
        }
        if (val == 'ITEM_SHARED_UNSHARE') {
            return val;
        }
        if (val == 'ITEM_SHARED_UPDATE') {
            return val;
        }
        if (val == 'ITEM_SYNC') {
            return val;
        }
        if (val == 'ITEM_TRASH') {
            return val;
        }
        if (val == 'ITEM_UNDELETE_VIA_TRASH') {
            return val;
        }
        if (val == 'ITEM_UNSYNC') {
            return val;
        }
        if (val == 'ITEM_UPLOAD') {
            return val;
        }
        if (val == 'LEGAL_HOLD_ASSIGNMENT_CREATE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_ASSIGNMENT_DELETE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_POLICY_CREATE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_POLICY_DELETE') {
            return val;
        }
        if (val == 'LEGAL_HOLD_POLICY_UPDATE') {
            return val;
        }
        if (val == 'LOCK') {
            return val;
        }
        if (val == 'LOCK_CREATE') {
            return val;
        }
        if (val == 'LOCK_DESTROY') {
            return val;
        }
        if (val == 'LOGIN') {
            return val;
        }
        if (val == 'MASTER_INVITE_ACCEPT') {
            return val;
        }
        if (val == 'MASTER_INVITE_REJECT') {
            return val;
        }
        if (val == 'METADATA_INSTANCE_CREATE') {
            return val;
        }
        if (val == 'METADATA_INSTANCE_DELETE') {
            return val;
        }
        if (val == 'METADATA_INSTANCE_UPDATE') {
            return val;
        }
        if (val == 'METADATA_TEMPLATE_CREATE') {
            return val;
        }
        if (val == 'METADATA_TEMPLATE_DELETE') {
            return val;
        }
        if (val == 'METADATA_TEMPLATE_UPDATE') {
            return val;
        }
        if (val == 'MOVE') {
            return val;
        }
        if (val == 'NEW_USER') {
            return val;
        }
        if (val == 'PREVIEW') {
            return val;
        }
        if (val == 'REMOVE_DEVICE_ASSOCIATION') {
            return val;
        }
        if (val == 'REMOVE_LOGIN_ACTIVITY_DEVICE') {
            return val;
        }
        if (val == 'RENAME') {
            return val;
        }
        if (val == 'RETENTION_POLICY_ASSIGNMENT_ADD') {
            return val;
        }
        if (val == 'SHARE') {
            return val;
        }
        if (val == 'SHARED_LINK_SEND') {
            return val;
        }
        if (val == 'SHARE_EXPIRATION') {
            return val;
        }
        if (val == 'SHIELD_ALERT') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED_MISSING_JUSTIFICATION') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED') {
            return val;
        }
        if (val == 'SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED_MISSING_JUSTIFICATION') {
            return val;
        }
        if (val == 'SHIELD_JUSTIFICATION_APPROVAL') {
            return val;
        }
        if (val == 'SHIELD_SHARED_LINK_ACCESS_BLOCKED') {
            return val;
        }
        if (val == 'SHIELD_SHARED_LINK_STATUS_RESTRICTED_ON_CREATE') {
            return val;
        }
        if (val == 'SHIELD_SHARED_LINK_STATUS_RESTRICTED_ON_UPDATE') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_ASSIGNED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_CANCELLED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_COMPLETED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_CONVERTED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_CREATED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_DECLINED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_EXPIRED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_SIGNED') {
            return val;
        }
        if (val == 'SIGN_DOCUMENT_VIEWED_BY_SIGNED') {
            return val;
        }
        if (val == 'SIGNER_DOWNLOADED') {
            return val;
        }
        if (val == 'SIGNER_FORWARDED') {
            return val;
        }
        if (val == 'STORAGE_EXPIRATION') {
            return val;
        }
        if (val == 'TAG_ITEM_CREATE') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT_CREATE') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT_DELETE') {
            return val;
        }
        if (val == 'TASK_ASSIGNMENT_UPDATE') {
            return val;
        }
        if (val == 'TASK_CREATE') {
            return val;
        }
        if (val == 'TASK_UPDATE') {
            return val;
        }
        if (val == 'TERMS_OF_SERVICE_ACCEPT') {
            return val;
        }
        if (val == 'TERMS_OF_SERVICE_REJECT') {
            return val;
        }
        if (val == 'UNDELETE') {
            return val;
        }
        if (val == 'UNLOCK') {
            return val;
        }
        if (val == 'UNSHARE') {
            return val;
        }
        if (val == 'UPDATE_COLLABORATION_EXPIRATION') {
            return val;
        }
        if (val == 'UPDATE_SHARE_EXPIRATION') {
            return val;
        }
        if (val == 'UPLOAD') {
            return val;
        }
        if (val == 'USER_AUTHENTICATE_OAUTH2_ACCESS_TOKEN_CREATE') {
            return val;
        }
        if (val == 'WATERMARK_LABEL_CREATE') {
            return val;
        }
        if (val == 'WATERMARK_LABEL_DELETE') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize EventEventTypeField" });
    }
    function deserializeEventAdditionalDetailsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "EventAdditionalDetailsField"',
            });
        }
        return {};
    }
    function deserializeEvent(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Event"' });
        }
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "Event"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "Event"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.recorded_at == void 0) && !sdIsString(val.recorded_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "recorded_at" of type "Event"',
            });
        }
        const recordedAt = val.recorded_at == void 0 ? void 0 : dateTimeFromString(val.recorded_at);
        if (!(val.event_id == void 0) && !sdIsString(val.event_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "event_id" of type "Event"',
            });
        }
        const eventId = val.event_id == void 0 ? void 0 : val.event_id;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        const eventType = val.event_type == void 0
            ? void 0
            : deserializeEventEventTypeField(val.event_type);
        if (!(val.session_id == void 0) && !sdIsString(val.session_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "session_id" of type "Event"',
            });
        }
        const sessionId = val.session_id == void 0 ? void 0 : val.session_id;
        const source = val.source == void 0
            ? void 0
            : deserializeAppItemEventSourceOrEventSourceOrFileOrFolderOrGenericSourceOrUser(val.source);
        const additionalDetails = val.additional_details == void 0
            ? void 0
            : deserializeEventAdditionalDetailsField(val.additional_details);
        return {
            type: type,
            createdAt: createdAt,
            recordedAt: recordedAt,
            eventId: eventId,
            createdBy: createdBy,
            eventType: eventType,
            sessionId: sessionId,
            source: source,
            additionalDetails: additionalDetails,
        };
    }

    function deserializeEventsNextStreamPositionField(val) {
        if (sdIsString(val)) {
            return val;
        }
        if (sdIsNumber(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize EventsNextStreamPositionField",
        });
    }
    function deserializeEvents(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Events"' });
        }
        if (!(val.chunk_size == void 0) && !sdIsNumber(val.chunk_size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "chunk_size" of type "Events"',
            });
        }
        const chunkSize = val.chunk_size == void 0 ? void 0 : val.chunk_size;
        const nextStreamPosition = val.next_stream_position == void 0
            ? void 0
            : deserializeEventsNextStreamPositionField(val.next_stream_position);
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Events"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeEvent(itm);
                })
                : [];
        return {
            chunkSize: chunkSize,
            nextStreamPosition: nextStreamPosition,
            entries: entries,
        };
    }

    class GetEventsWithLongPollingHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetEventsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class EventsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns a list of real-time servers that can be used for long-polling updates
         * to the [event stream](#get-events).
         *
         * Long polling is the concept where a HTTP request is kept open until the
         * server sends a response, then repeating the process over and over to receive
         * updated responses.
         *
         * Long polling the event stream can only be used for user events, not for
         * enterprise events.
         *
         * To use long polling, first use this endpoint to retrieve a list of long poll
         * URLs. Next, make a long poll request to any of the provided URLs.
         *
         * When an event occurs in monitored account a response with the value
         * `new_change` will be sent. The response contains no other details as
         * it only serves as a prompt to take further action such as sending a
         * request to the [events endpoint](#get-events) with the last known
         * `stream_position`.
         *
         * After the server sends this response it closes the connection. You must now
         * repeat the long poll process to begin listening for events again.
         *
         * If no events occur for a while and the connection times out you will
         * receive a response with the value `reconnect`. When you receive this response
         * you’ll make another call to this endpoint to restart the process.
         *
         * If you receive no events in `retry_timeout` seconds then you will need to
         * make another request to the real-time server (one of the URLs in the response
         * for this endpoint). This might be necessary due to network errors.
         *
         * Finally, if you receive a `max_retries` error when making a request to the
         * real-time server, you should start over by making a call to this endpoint
         * first.
         * @param {GetEventsWithLongPollingHeadersInput} headersInput Headers of getEventsWithLongPolling method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<RealtimeServers>}
         */
        getEventsWithLongPolling() {
            return __awaiter$1(this, arguments, void 0, function* (headersInput = new GetEventsWithLongPollingHeaders({}), cancellationToken) {
                const headers = new GetEventsWithLongPollingHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/events'),
                    method: 'OPTIONS',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRealtimeServers(response.data)), { rawData: response.data });
            });
        }
        /**
         * Returns up to a year of past events for a given user
         * or for the entire enterprise.
         *
         * By default this returns events for the authenticated user. To retrieve events
         * for the entire enterprise, set the `stream_type` to `admin_logs_streaming`
         * for live monitoring of new events, or `admin_logs` for querying across
         * historical events. The user making the API call will
         * need to have admin privileges, and the application will need to have the
         * scope `manage enterprise properties` checked.
         * @param {GetEventsQueryParams} queryParams Query parameters of getEvents method
         * @param {GetEventsHeadersInput} headersInput Headers of getEvents method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<Events>}
         */
        getEvents() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetEventsHeaders({}), cancellationToken) {
                const headers = new GetEventsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['stream_type']: toString(queryParams.streamType),
                    ['stream_position']: toString(queryParams.streamPosition),
                    ['limit']: toString(queryParams.limit),
                    ['event_type']: queryParams.eventType
                        ? queryParams.eventType.map(toString).join(',')
                        : undefined,
                    ['created_after']: queryParams.createdAfter
                        ? dateTimeToString(queryParams.createdAfter)
                        : undefined,
                    ['created_before']: queryParams.createdBefore
                        ? dateTimeToString(queryParams.createdBefore)
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/events'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeEvents(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeCollectionTypeField(val) {
        if (val == 'collection') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize CollectionTypeField" });
    }
    function deserializeCollectionNameField(val) {
        if (val == 'Favorites') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize CollectionNameField" });
    }
    function deserializeCollectionCollectionTypeField(val) {
        if (val == 'favorites') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollectionCollectionTypeField",
        });
    }
    function deserializeCollection(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collection"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Collection"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeCollectionTypeField(val.type);
        const name = val.name == void 0 ? void 0 : deserializeCollectionNameField(val.name);
        const collectionType = val.collection_type == void 0
            ? void 0
            : deserializeCollectionCollectionTypeField(val.collection_type);
        return {
            id: id,
            type: type,
            name: name,
            collectionType: collectionType,
        };
    }

    function deserializeCollectionsOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollectionsOrderDirectionField",
        });
    }
    function deserializeCollectionsOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollectionsOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "CollectionsOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeCollectionsOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeCollections(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Collections"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "Collections"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Collections"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "Collections"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "Collections"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeCollectionsOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Collections"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollection(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    function deserializeItemsOffsetPaginatedOrderDirectionField(val) {
        if (val == 'ASC') {
            return val;
        }
        if (val == 'DESC') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ItemsOffsetPaginatedOrderDirectionField",
        });
    }
    function deserializeItemsOffsetPaginatedOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ItemsOffsetPaginatedOrderField"',
            });
        }
        if (!(val.by == void 0) && !sdIsString(val.by)) {
            throw new BoxSdkError({
                message: 'Expecting string for "by" of type "ItemsOffsetPaginatedOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : val.by;
        const direction = val.direction == void 0
            ? void 0
            : deserializeItemsOffsetPaginatedOrderDirectionField(val.direction);
        return {
            by: by,
            direction: direction,
        };
    }
    function deserializeItemsOffsetPaginated(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ItemsOffsetPaginated"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "ItemsOffsetPaginated"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ItemsOffsetPaginated"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.offset == void 0) && !sdIsNumber(val.offset)) {
            throw new BoxSdkError({
                message: 'Expecting number for "offset" of type "ItemsOffsetPaginated"',
            });
        }
        const offset = val.offset == void 0 ? void 0 : val.offset;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "ItemsOffsetPaginated"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeItemsOffsetPaginatedOrderField(itm);
                })
                : [];
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ItemsOffsetPaginated"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileFullOrFolderMiniOrWebLink(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            limit: limit,
            offset: offset,
            order: order,
            entries: entries,
        };
    }

    class GetCollectionItemsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetCollectionItemsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollectionByIdOptionals {
        constructor(fields) {
            this.headers = new GetCollectionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollectionsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollectionItemsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollectionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CollectionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all collections for a given user.
         *
         * Currently, only the `favorites` collection
         * is supported.
         * @param {GetCollectionsQueryParams} queryParams Query parameters of getCollections method
         * @param {GetCollectionsHeadersInput} headersInput Headers of getCollections method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<Collections>}
         */
        getCollections() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetCollectionsHeaders({}), cancellationToken) {
                const headers = new GetCollectionsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collections'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollections(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves the files and/or folders contained within
           * this collection.
           * @param {string} collectionId The ID of the collection.
          Example: "926489"
           * @param {GetCollectionItemsOptionalsInput} optionalsInput
           * @returns {Promise<ItemsOffsetPaginated>}
           */
        getCollectionItems(collectionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collectionId, optionalsInput = {}) {
                const optionals = new GetCollectionItemsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['offset']: toString(queryParams.offset),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collections/', toString(collectionId), '/items'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeItemsOffsetPaginated(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a collection by its ID.
           * @param {string} collectionId The ID of the collection.
          Example: "926489"
           * @param {GetCollectionByIdOptionalsInput} optionalsInput
           * @returns {Promise<Collection>}
           */
        getCollectionById(collectionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collectionId, optionalsInput = {}) {
                const optionals = new GetCollectionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collections/', toString(collectionId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollection(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeRecentItemInteractionTypeField(val) {
        if (val == 'item_preview') {
            return val;
        }
        if (val == 'item_upload') {
            return val;
        }
        if (val == 'item_comment') {
            return val;
        }
        if (val == 'item_open') {
            return val;
        }
        if (val == 'item_modify') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RecentItemInteractionTypeField",
        });
    }
    function deserializeRecentItem(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RecentItem"' });
        }
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "RecentItem"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        const item = val.item == void 0
            ? void 0
            : deserializeFileFullOrFolderFullOrWebLink(val.item);
        const interactionType = val.interaction_type == void 0
            ? void 0
            : deserializeRecentItemInteractionTypeField(val.interaction_type);
        if (!(val.interacted_at == void 0) && !sdIsString(val.interacted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "interacted_at" of type "RecentItem"',
            });
        }
        const interactedAt = val.interacted_at == void 0
            ? void 0
            : dateTimeFromString(val.interacted_at);
        if (!(val.interaction_shared_link == void 0) &&
            !sdIsString(val.interaction_shared_link)) {
            throw new BoxSdkError({
                message: 'Expecting string for "interaction_shared_link" of type "RecentItem"',
            });
        }
        const interactionSharedLink = val.interaction_shared_link == void 0
            ? void 0
            : val.interaction_shared_link;
        return {
            type: type,
            item: item,
            interactionType: interactionType,
            interactedAt: interactedAt,
            interactionSharedLink: interactionSharedLink,
        };
    }

    function deserializeRecentItems(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RecentItems"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "RecentItems"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "RecentItems"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "RecentItems"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RecentItems"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRecentItem(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetRecentItemsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RecentItemsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns information about the recent items accessed
         * by a user, either in the last 90 days or up to the last
         * 1000 items accessed.
         * @param {GetRecentItemsQueryParams} queryParams Query parameters of getRecentItems method
         * @param {GetRecentItemsHeadersInput} headersInput Headers of getRecentItems method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<RecentItems>}
         */
        getRecentItems() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetRecentItemsHeaders({}), cancellationToken) {
                const headers = new GetRecentItemsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/recent_items'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRecentItems(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeRetentionPolicyBaseTypeField(val) {
        if (val == 'retention_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyBaseTypeField",
        });
    }

    function deserializeRetentionPolicyMiniDispositionActionField(val) {
        if (val == 'permanently_delete') {
            return val;
        }
        if (val == 'remove_retention') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyMiniDispositionActionField",
        });
    }
    function deserializeRetentionPolicyMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyMini"',
            });
        }
        if (!(val.policy_name == void 0) && !sdIsString(val.policy_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "policy_name" of type "RetentionPolicyMini"',
            });
        }
        const policyName = val.policy_name == void 0 ? void 0 : val.policy_name;
        if (!(val.retention_length == void 0) && !sdIsString(val.retention_length)) {
            throw new BoxSdkError({
                message: 'Expecting string for "retention_length" of type "RetentionPolicyMini"',
            });
        }
        const retentionLength = val.retention_length == void 0 ? void 0 : val.retention_length;
        const dispositionAction = val.disposition_action == void 0
            ? void 0
            : deserializeRetentionPolicyMiniDispositionActionField(val.disposition_action);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "RetentionPolicyMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicyMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "RetentionPolicyMini" to be defined',
            });
        }
        const type = deserializeRetentionPolicyBaseTypeField(val.type);
        return {
            policyName: policyName,
            retentionLength: retentionLength,
            dispositionAction: dispositionAction,
            id: id,
            type: type,
        };
    }

    function deserializeRetentionPolicyPolicyTypeField(val) {
        if (val == 'finite') {
            return val;
        }
        if (val == 'indefinite') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyPolicyTypeField",
        });
    }
    function deserializeRetentionPolicyRetentionTypeField(val) {
        if (val == 'modifiable') {
            return val;
        }
        if (val == 'non_modifiable') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyRetentionTypeField",
        });
    }
    function deserializeRetentionPolicyStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'retired') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyStatusField",
        });
    }
    function deserializeRetentionPolicyAssignmentCountsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignmentCountsField"',
            });
        }
        if (!(val.enterprise == void 0) && !sdIsNumber(val.enterprise)) {
            throw new BoxSdkError({
                message: 'Expecting number for "enterprise" of type "RetentionPolicyAssignmentCountsField"',
            });
        }
        const enterprise = val.enterprise == void 0 ? void 0 : val.enterprise;
        if (!(val.folder == void 0) && !sdIsNumber(val.folder)) {
            throw new BoxSdkError({
                message: 'Expecting number for "folder" of type "RetentionPolicyAssignmentCountsField"',
            });
        }
        const folder = val.folder == void 0 ? void 0 : val.folder;
        if (!(val.metadata_template == void 0) &&
            !sdIsNumber(val.metadata_template)) {
            throw new BoxSdkError({
                message: 'Expecting number for "metadata_template" of type "RetentionPolicyAssignmentCountsField"',
            });
        }
        const metadataTemplate = val.metadata_template == void 0 ? void 0 : val.metadata_template;
        return {
            enterprise: enterprise,
            folder: folder,
            metadataTemplate: metadataTemplate,
        };
    }
    function deserializeRetentionPolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "RetentionPolicy"' });
        }
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "RetentionPolicy"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const policyType = val.policy_type == void 0
            ? void 0
            : deserializeRetentionPolicyPolicyTypeField(val.policy_type);
        const retentionType = val.retention_type == void 0
            ? void 0
            : deserializeRetentionPolicyRetentionTypeField(val.retention_type);
        const status = val.status == void 0
            ? void 0
            : deserializeRetentionPolicyStatusField(val.status);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "RetentionPolicy"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "RetentionPolicy"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.can_owner_extend_retention == void 0) &&
            !sdIsBoolean(val.can_owner_extend_retention)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_owner_extend_retention" of type "RetentionPolicy"',
            });
        }
        const canOwnerExtendRetention = val.can_owner_extend_retention == void 0
            ? void 0
            : val.can_owner_extend_retention;
        if (!(val.are_owners_notified == void 0) &&
            !sdIsBoolean(val.are_owners_notified)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_owners_notified" of type "RetentionPolicy"',
            });
        }
        const areOwnersNotified = val.are_owners_notified == void 0 ? void 0 : val.are_owners_notified;
        if (!(val.custom_notification_recipients == void 0) &&
            !sdIsList(val.custom_notification_recipients)) {
            throw new BoxSdkError({
                message: 'Expecting array for "custom_notification_recipients" of type "RetentionPolicy"',
            });
        }
        const customNotificationRecipients = val.custom_notification_recipients == void 0
            ? void 0
            : sdIsList(val.custom_notification_recipients)
                ? val.custom_notification_recipients.map(function (itm) {
                    return deserializeUserMini(itm);
                })
                : [];
        const assignmentCounts = val.assignment_counts == void 0
            ? void 0
            : deserializeRetentionPolicyAssignmentCountsField(val.assignment_counts);
        if (!(val.policy_name == void 0) && !sdIsString(val.policy_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "policy_name" of type "RetentionPolicy"',
            });
        }
        const policyName = val.policy_name == void 0 ? void 0 : val.policy_name;
        if (!(val.retention_length == void 0) && !sdIsString(val.retention_length)) {
            throw new BoxSdkError({
                message: 'Expecting string for "retention_length" of type "RetentionPolicy"',
            });
        }
        const retentionLength = val.retention_length == void 0 ? void 0 : val.retention_length;
        const dispositionAction = val.disposition_action == void 0
            ? void 0
            : deserializeRetentionPolicyMiniDispositionActionField(val.disposition_action);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "RetentionPolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "RetentionPolicy" to be defined',
            });
        }
        const type = deserializeRetentionPolicyBaseTypeField(val.type);
        return {
            description: description,
            policyType: policyType,
            retentionType: retentionType,
            status: status,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            canOwnerExtendRetention: canOwnerExtendRetention,
            areOwnersNotified: areOwnersNotified,
            customNotificationRecipients: customNotificationRecipients,
            assignmentCounts: assignmentCounts,
            policyName: policyName,
            retentionLength: retentionLength,
            dispositionAction: dispositionAction,
            id: id,
            type: type,
        };
    }

    function deserializeRetentionPolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicies"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RetentionPolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRetentionPolicy(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "RetentionPolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "RetentionPolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    class CreateRetentionPolicyOptionals {
        constructor(fields) {
            this.headers = new CreateRetentionPolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPolicyByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetRetentionPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateRetentionPolicyByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateRetentionPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteRetentionPolicyByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteRetentionPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPoliciesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateRetentionPolicyHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetRetentionPolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateRetentionPolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteRetentionPolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RetentionPoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all of the retention policies for an enterprise.
         * @param {GetRetentionPoliciesQueryParams} queryParams Query parameters of getRetentionPolicies method
         * @param {GetRetentionPoliciesHeadersInput} headersInput Headers of getRetentionPolicies method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<RetentionPolicies>}
         */
        getRetentionPolicies() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetRetentionPoliciesHeaders({}), cancellationToken) {
                const headers = new GetRetentionPoliciesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['policy_name']: toString(queryParams.policyName),
                    ['policy_type']: toString(queryParams.policyType),
                    ['created_by_user_id']: toString(queryParams.createdByUserId),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRetentionPolicies(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a retention policy.
         * @param {CreateRetentionPolicyRequestBody} requestBody Request body of createRetentionPolicy method
         * @param {CreateRetentionPolicyOptionalsInput} optionalsInput
         * @returns {Promise<RetentionPolicy>}
         */
        createRetentionPolicy(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateRetentionPolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateRetentionPolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRetentionPolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a retention policy.
           * @param {string} retentionPolicyId The ID of the retention policy.
          Example: "982312"
           * @param {GetRetentionPolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<RetentionPolicy>}
           */
        getRetentionPolicyById(retentionPolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new GetRetentionPolicyByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRetentionPolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a retention policy.
           * @param {string} retentionPolicyId The ID of the retention policy.
          Example: "982312"
           * @param {UpdateRetentionPolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<RetentionPolicy>}
           */
        updateRetentionPolicyById(retentionPolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new UpdateRetentionPolicyByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateRetentionPolicyByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRetentionPolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Permanently deletes a retention policy.
           * @param {string} retentionPolicyId The ID of the retention policy.
          Example: "982312"
           * @param {DeleteRetentionPolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteRetentionPolicyById(retentionPolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new DeleteRetentionPolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateRetentionPolicyRequestBodyPolicyTypeField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyRequestBodyDispositionActionField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyRequestBodyRetentionTypeField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyRequestBody(val) {
        return {
            ['policy_name']: val.policyName,
            ['description']: val.description,
            ['policy_type']: serializeCreateRetentionPolicyRequestBodyPolicyTypeField(val.policyType),
            ['disposition_action']: serializeCreateRetentionPolicyRequestBodyDispositionActionField(val.dispositionAction),
            ['retention_length']: val.retentionLength,
            ['retention_type']: val.retentionType == void 0
                ? val.retentionType
                : serializeCreateRetentionPolicyRequestBodyRetentionTypeField(val.retentionType),
            ['can_owner_extend_retention']: val.canOwnerExtendRetention,
            ['are_owners_notified']: val.areOwnersNotified,
            ['custom_notification_recipients']: val.customNotificationRecipients == void 0
                ? val.customNotificationRecipients
                : val.customNotificationRecipients.map(function (item) {
                    return serializeUserMini(item);
                }),
        };
    }
    function serializeUpdateRetentionPolicyByIdRequestBody(val) {
        return {
            ['policy_name']: val.policyName,
            ['description']: val.description,
            ['disposition_action']: val.dispositionAction,
            ['retention_type']: val.retentionType,
            ['retention_length']: val.retentionLength,
            ['status']: val.status,
            ['can_owner_extend_retention']: val.canOwnerExtendRetention,
            ['are_owners_notified']: val.areOwnersNotified,
            ['custom_notification_recipients']: val.customNotificationRecipients == void 0
                ? val.customNotificationRecipients
                : val.customNotificationRecipients.map(function (item) {
                    return serializeUserBase(item);
                }),
        };
    }

    function deserializeRetentionPolicyAssignmentTypeField(val) {
        if (val == 'retention_policy_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyAssignmentTypeField",
        });
    }
    function deserializeRetentionPolicyAssignmentAssignedToTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        if (val == 'enterprise') {
            return val;
        }
        if (val == 'metadata_template') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize RetentionPolicyAssignmentAssignedToTypeField",
        });
    }
    function deserializeRetentionPolicyAssignmentAssignedToField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignmentAssignedToField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicyAssignmentAssignedToField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeRetentionPolicyAssignmentAssignedToTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }
    function deserializeRetentionPolicyAssignmentFilterFieldsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignmentFilterFieldsField"',
            });
        }
        if (!(val.field == void 0) && !sdIsString(val.field)) {
            throw new BoxSdkError({
                message: 'Expecting string for "field" of type "RetentionPolicyAssignmentFilterFieldsField"',
            });
        }
        const field = val.field == void 0 ? void 0 : val.field;
        if (!(val.value == void 0) && !sdIsString(val.value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "value" of type "RetentionPolicyAssignmentFilterFieldsField"',
            });
        }
        const value = val.value == void 0 ? void 0 : val.value;
        return {
            field: field,
            value: value,
        };
    }
    function deserializeRetentionPolicyAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignment"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "RetentionPolicyAssignment" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "RetentionPolicyAssignment"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "RetentionPolicyAssignment" to be defined',
            });
        }
        const type = deserializeRetentionPolicyAssignmentTypeField(val.type);
        const retentionPolicy = val.retention_policy == void 0
            ? void 0
            : deserializeRetentionPolicyMini(val.retention_policy);
        const assignedTo = val.assigned_to == void 0
            ? void 0
            : deserializeRetentionPolicyAssignmentAssignedToField(val.assigned_to);
        if (!(val.filter_fields == void 0) && !sdIsList(val.filter_fields)) {
            throw new BoxSdkError({
                message: 'Expecting array for "filter_fields" of type "RetentionPolicyAssignment"',
            });
        }
        const filterFields = val.filter_fields == void 0
            ? void 0
            : sdIsList(val.filter_fields)
                ? val.filter_fields.map(function (itm) {
                    return deserializeRetentionPolicyAssignmentFilterFieldsField(itm);
                })
                : [];
        const assignedBy = val.assigned_by == void 0 ? void 0 : deserializeUserMini(val.assigned_by);
        if (!(val.assigned_at == void 0) && !sdIsString(val.assigned_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "assigned_at" of type "RetentionPolicyAssignment"',
            });
        }
        const assignedAt = val.assigned_at == void 0 ? void 0 : dateTimeFromString(val.assigned_at);
        if (!(val.start_date_field == void 0) && !sdIsString(val.start_date_field)) {
            throw new BoxSdkError({
                message: 'Expecting string for "start_date_field" of type "RetentionPolicyAssignment"',
            });
        }
        const startDateField = val.start_date_field == void 0 ? void 0 : val.start_date_field;
        return {
            id: id,
            type: type,
            retentionPolicy: retentionPolicy,
            assignedTo: assignedTo,
            filterFields: filterFields,
            assignedBy: assignedBy,
            assignedAt: assignedAt,
            startDateField: startDateField,
        };
    }

    function deserializeRetentionPolicyAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "RetentionPolicyAssignments"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "RetentionPolicyAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeRetentionPolicyAssignment(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "RetentionPolicyAssignments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "RetentionPolicyAssignments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    function deserializeFilesUnderRetention(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FilesUnderRetention"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FilesUnderRetention"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FilesUnderRetention"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FilesUnderRetention"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FilesUnderRetention"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetRetentionPolicyAssignmentsOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetRetentionPolicyAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateRetentionPolicyAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateRetentionPolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetRetentionPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteRetentionPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteRetentionPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFilesUnderRetentionPolicyAssignmentOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetFilesUnderRetentionPolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetRetentionPolicyAssignmentsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateRetentionPolicyAssignmentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetRetentionPolicyAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteRetentionPolicyAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFilesUnderRetentionPolicyAssignmentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class RetentionPolicyAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Returns a list of all retention policy assignments associated with a specified
           * retention policy.
           * @param {string} retentionPolicyId The ID of the retention policy.
          Example: "982312"
           * @param {GetRetentionPolicyAssignmentsOptionalsInput} optionalsInput
           * @returns {Promise<RetentionPolicyAssignments>}
           */
        getRetentionPolicyAssignments(retentionPolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (retentionPolicyId, optionalsInput = {}) {
                const optionals = new GetRetentionPolicyAssignmentsOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['type']: toString(queryParams.type),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policies/', toString(retentionPolicyId), '/assignments'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRetentionPolicyAssignments(response.data)), { rawData: response.data });
            });
        }
        /**
         * Assigns a retention policy to an item.
         * @param {CreateRetentionPolicyAssignmentRequestBody} requestBody Request body of createRetentionPolicyAssignment method
         * @param {CreateRetentionPolicyAssignmentOptionalsInput} optionalsInput
         * @returns {Promise<RetentionPolicyAssignment>}
         */
        createRetentionPolicyAssignment(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateRetentionPolicyAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateRetentionPolicyAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRetentionPolicyAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a retention policy assignment.
           * @param {string} retentionPolicyAssignmentId The ID of the retention policy assignment.
          Example: "1233123"
           * @param {GetRetentionPolicyAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<RetentionPolicyAssignment>}
           */
        getRetentionPolicyAssignmentById(retentionPolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (retentionPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetRetentionPolicyAssignmentByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments/', toString(retentionPolicyAssignmentId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeRetentionPolicyAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes a retention policy assignment
           * applied to content.
           * @param {string} retentionPolicyAssignmentId The ID of the retention policy assignment.
          Example: "1233123"
           * @param {DeleteRetentionPolicyAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteRetentionPolicyAssignmentById(retentionPolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (retentionPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteRetentionPolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments/', toString(retentionPolicyAssignmentId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Returns a list of files under retention for a retention policy assignment.
           * @param {string} retentionPolicyAssignmentId The ID of the retention policy assignment.
          Example: "1233123"
           * @param {GetFilesUnderRetentionPolicyAssignmentOptionalsInput} optionalsInput
           * @returns {Promise<FilesUnderRetention>}
           */
        getFilesUnderRetentionPolicyAssignment(retentionPolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (retentionPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetFilesUnderRetentionPolicyAssignmentOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/retention_policy_assignments/', toString(retentionPolicyAssignmentId), '/files_under_retention'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFilesUnderRetention(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeCreateRetentionPolicyAssignmentRequestBodyAssignToTypeField(val) {
        return val;
    }
    function serializeCreateRetentionPolicyAssignmentRequestBodyAssignToField(val) {
        return {
            ['type']: serializeCreateRetentionPolicyAssignmentRequestBodyAssignToTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateRetentionPolicyAssignmentRequestBodyFilterFieldsField(val) {
        return { ['field']: val.field, ['value']: val.value };
    }
    function serializeCreateRetentionPolicyAssignmentRequestBody(val) {
        return {
            ['policy_id']: val.policyId,
            ['assign_to']: serializeCreateRetentionPolicyAssignmentRequestBodyAssignToField(val.assignTo),
            ['filter_fields']: val.filterFields == void 0
                ? val.filterFields
                : val.filterFields.map(function (item) {
                    return serializeCreateRetentionPolicyAssignmentRequestBodyFilterFieldsField(item);
                }),
            ['start_date_field']: val.startDateField,
        };
    }

    function deserializeLegalHoldPolicyMiniTypeField(val) {
        if (val == 'legal_hold_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize LegalHoldPolicyMiniTypeField",
        });
    }
    function deserializeLegalHoldPolicyMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyMini"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "LegalHoldPolicyMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "LegalHoldPolicyMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "LegalHoldPolicyMini" to be defined',
            });
        }
        const type = deserializeLegalHoldPolicyMiniTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeLegalHoldPolicyStatusField(val) {
        if (val == 'active') {
            return val;
        }
        if (val == 'applying') {
            return val;
        }
        if (val == 'releasing') {
            return val;
        }
        if (val == 'released') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize LegalHoldPolicyStatusField",
        });
    }
    function deserializeLegalHoldPolicyAssignmentCountsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        if (!(val.user == void 0) && !sdIsNumber(val.user)) {
            throw new BoxSdkError({
                message: 'Expecting number for "user" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const user = val.user == void 0 ? void 0 : val.user;
        if (!(val.folder == void 0) && !sdIsNumber(val.folder)) {
            throw new BoxSdkError({
                message: 'Expecting number for "folder" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const folder = val.folder == void 0 ? void 0 : val.folder;
        if (!(val.file == void 0) && !sdIsNumber(val.file)) {
            throw new BoxSdkError({
                message: 'Expecting number for "file" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const file = val.file == void 0 ? void 0 : val.file;
        if (!(val.file_version == void 0) && !sdIsNumber(val.file_version)) {
            throw new BoxSdkError({
                message: 'Expecting number for "file_version" of type "LegalHoldPolicyAssignmentCountsField"',
            });
        }
        const fileVersion = val.file_version == void 0 ? void 0 : val.file_version;
        return {
            user: user,
            folder: folder,
            file: file,
            fileVersion: fileVersion,
        };
    }
    function deserializeLegalHoldPolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "LegalHoldPolicy"' });
        }
        if (!(val.policy_name == void 0) && !sdIsString(val.policy_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "policy_name" of type "LegalHoldPolicy"',
            });
        }
        const policyName = val.policy_name == void 0 ? void 0 : val.policy_name;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "LegalHoldPolicy"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        const status = val.status == void 0
            ? void 0
            : deserializeLegalHoldPolicyStatusField(val.status);
        const assignmentCounts = val.assignment_counts == void 0
            ? void 0
            : deserializeLegalHoldPolicyAssignmentCountsField(val.assignment_counts);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserMini(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "LegalHoldPolicy"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "LegalHoldPolicy"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.deleted_at == void 0) && !sdIsString(val.deleted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "deleted_at" of type "LegalHoldPolicy"',
            });
        }
        const deletedAt = val.deleted_at == void 0 ? void 0 : dateTimeFromString(val.deleted_at);
        if (!(val.filter_started_at == void 0) &&
            !sdIsString(val.filter_started_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "filter_started_at" of type "LegalHoldPolicy"',
            });
        }
        const filterStartedAt = val.filter_started_at == void 0
            ? void 0
            : dateTimeFromString(val.filter_started_at);
        if (!(val.filter_ended_at == void 0) && !sdIsString(val.filter_ended_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "filter_ended_at" of type "LegalHoldPolicy"',
            });
        }
        const filterEndedAt = val.filter_ended_at == void 0
            ? void 0
            : dateTimeFromString(val.filter_ended_at);
        if (!(val.release_notes == void 0) && !sdIsString(val.release_notes)) {
            throw new BoxSdkError({
                message: 'Expecting string for "release_notes" of type "LegalHoldPolicy"',
            });
        }
        const releaseNotes = val.release_notes == void 0 ? void 0 : val.release_notes;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "LegalHoldPolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "LegalHoldPolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "LegalHoldPolicy" to be defined',
            });
        }
        const type = deserializeLegalHoldPolicyMiniTypeField(val.type);
        return {
            policyName: policyName,
            description: description,
            status: status,
            assignmentCounts: assignmentCounts,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            deletedAt: deletedAt,
            filterStartedAt: filterStartedAt,
            filterEndedAt: filterEndedAt,
            releaseNotes: releaseNotes,
            id: id,
            type: type,
        };
    }

    function deserializeLegalHoldPolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicies"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "LegalHoldPolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "LegalHoldPolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "LegalHoldPolicies"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "LegalHoldPolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeLegalHoldPolicy(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class CreateLegalHoldPolicyOptionals {
        constructor(fields) {
            this.headers = new CreateLegalHoldPolicyHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyByIdOptionals {
        constructor(fields) {
            this.headers = new GetLegalHoldPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateLegalHoldPolicyByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateLegalHoldPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteLegalHoldPolicyByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteLegalHoldPolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPoliciesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateLegalHoldPolicyHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetLegalHoldPolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateLegalHoldPolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteLegalHoldPolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class LegalHoldPoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves a list of legal hold policies that belong to
         * an enterprise.
         * @param {GetLegalHoldPoliciesQueryParams} queryParams Query parameters of getLegalHoldPolicies method
         * @param {GetLegalHoldPoliciesHeadersInput} headersInput Headers of getLegalHoldPolicies method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<LegalHoldPolicies>}
         */
        getLegalHoldPolicies() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetLegalHoldPoliciesHeaders({}), cancellationToken) {
                const headers = new GetLegalHoldPoliciesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['policy_name']: toString(queryParams.policyName),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeLegalHoldPolicies(response.data)), { rawData: response.data });
            });
        }
        /**
         * Create a new legal hold policy.
         * @param {CreateLegalHoldPolicyRequestBody} requestBody Request body of createLegalHoldPolicy method
         * @param {CreateLegalHoldPolicyOptionalsInput} optionalsInput
         * @returns {Promise<LegalHoldPolicy>}
         */
        createLegalHoldPolicy(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateLegalHoldPolicyOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateLegalHoldPolicyRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeLegalHoldPolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieve a legal hold policy.
           * @param {string} legalHoldPolicyId The ID of the legal hold policy.
          Example: "324432"
           * @param {GetLegalHoldPolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<LegalHoldPolicy>}
           */
        getLegalHoldPolicyById(legalHoldPolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (legalHoldPolicyId, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies/', toString(legalHoldPolicyId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeLegalHoldPolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Update legal hold policy.
           * @param {string} legalHoldPolicyId The ID of the legal hold policy.
          Example: "324432"
           * @param {UpdateLegalHoldPolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<LegalHoldPolicy>}
           */
        updateLegalHoldPolicyById(legalHoldPolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (legalHoldPolicyId, optionalsInput = {}) {
                const optionals = new UpdateLegalHoldPolicyByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies/', toString(legalHoldPolicyId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateLegalHoldPolicyByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeLegalHoldPolicy(response.data)), { rawData: response.data });
            });
        }
        /**
           * Delete an existing legal hold policy.
           *
           * This is an asynchronous process. The policy will not be
           * fully deleted yet when the response returns.
           * @param {string} legalHoldPolicyId The ID of the legal hold policy.
          Example: "324432"
           * @param {DeleteLegalHoldPolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteLegalHoldPolicyById(legalHoldPolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (legalHoldPolicyId, optionalsInput = {}) {
                const optionals = new DeleteLegalHoldPolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policies/', toString(legalHoldPolicyId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateLegalHoldPolicyRequestBody(val) {
        return {
            ['policy_name']: val.policyName,
            ['description']: val.description,
            ['filter_started_at']: val.filterStartedAt == void 0
                ? val.filterStartedAt
                : dateTimeToString(val.filterStartedAt),
            ['filter_ended_at']: val.filterEndedAt == void 0
                ? val.filterEndedAt
                : dateTimeToString(val.filterEndedAt),
            ['is_ongoing']: val.isOngoing,
        };
    }
    function serializeUpdateLegalHoldPolicyByIdRequestBody(val) {
        return {
            ['policy_name']: val.policyName,
            ['description']: val.description,
            ['release_notes']: val.releaseNotes,
        };
    }

    function deserializeLegalHoldPolicyAssignmentBaseTypeField(val) {
        if (val == 'legal_hold_policy_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize LegalHoldPolicyAssignmentBaseTypeField",
        });
    }

    function deserializeLegalHoldPolicyAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyAssignment"',
            });
        }
        const legalHoldPolicy = val.legal_hold_policy == void 0
            ? void 0
            : deserializeLegalHoldPolicyMini(val.legal_hold_policy);
        const assignedTo = val.assigned_to == void 0
            ? void 0
            : deserializeFileOrFolderOrWebLink(val.assigned_to);
        const assignedBy = val.assigned_by == void 0 ? void 0 : deserializeUserMini(val.assigned_by);
        if (!(val.assigned_at == void 0) && !sdIsString(val.assigned_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "assigned_at" of type "LegalHoldPolicyAssignment"',
            });
        }
        const assignedAt = val.assigned_at == void 0 ? void 0 : dateTimeFromString(val.assigned_at);
        if (!(val.deleted_at == void 0) && !sdIsString(val.deleted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "deleted_at" of type "LegalHoldPolicyAssignment"',
            });
        }
        const deletedAt = val.deleted_at == void 0 ? void 0 : dateTimeFromString(val.deleted_at);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "LegalHoldPolicyAssignment"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeLegalHoldPolicyAssignmentBaseTypeField(val.type);
        return {
            legalHoldPolicy: legalHoldPolicy,
            assignedTo: assignedTo,
            assignedBy: assignedBy,
            assignedAt: assignedAt,
            deletedAt: deletedAt,
            id: id,
            type: type,
        };
    }

    function deserializeLegalHoldPolicyAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "LegalHoldPolicyAssignments"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "LegalHoldPolicyAssignments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "LegalHoldPolicyAssignments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "LegalHoldPolicyAssignments"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "LegalHoldPolicyAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeLegalHoldPolicyAssignment(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function deserializeFilesOnHold(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FilesOnHold"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FilesOnHold"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FilesOnHold"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FilesOnHold"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FilesOnHold"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetLegalHoldPolicyAssignmentsOptionals {
        constructor(fields) {
            this.headers = new GetLegalHoldPolicyAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateLegalHoldPolicyAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateLegalHoldPolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetLegalHoldPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteLegalHoldPolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteLegalHoldPolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentFileOnHoldOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetLegalHoldPolicyAssignmentFileOnHoldHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateLegalHoldPolicyAssignmentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteLegalHoldPolicyAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetLegalHoldPolicyAssignmentFileOnHoldHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class LegalHoldPolicyAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves a list of items a legal hold policy has been assigned to.
         * @param {GetLegalHoldPolicyAssignmentsQueryParams} queryParams Query parameters of getLegalHoldPolicyAssignments method
         * @param {GetLegalHoldPolicyAssignmentsOptionalsInput} optionalsInput
         * @returns {Promise<LegalHoldPolicyAssignments>}
         */
        getLegalHoldPolicyAssignments(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyAssignmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['policy_id']: toString(queryParams.policyId),
                    ['assign_to_type']: toString(queryParams.assignToType),
                    ['assign_to_id']: toString(queryParams.assignToId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeLegalHoldPolicyAssignments(response.data)), { rawData: response.data });
            });
        }
        /**
         * Assign a legal hold to a file, file version, folder, or user.
         * @param {CreateLegalHoldPolicyAssignmentRequestBody} requestBody Request body of createLegalHoldPolicyAssignment method
         * @param {CreateLegalHoldPolicyAssignmentOptionalsInput} optionalsInput
         * @returns {Promise<LegalHoldPolicyAssignment>}
         */
        createLegalHoldPolicyAssignment(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateLegalHoldPolicyAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateLegalHoldPolicyAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeLegalHoldPolicyAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieve a legal hold policy assignment.
           * @param {string} legalHoldPolicyAssignmentId The ID of the legal hold policy assignment.
          Example: "753465"
           * @param {GetLegalHoldPolicyAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<LegalHoldPolicyAssignment>}
           */
        getLegalHoldPolicyAssignmentById(legalHoldPolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (legalHoldPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments/', toString(legalHoldPolicyAssignmentId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeLegalHoldPolicyAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Remove a legal hold from an item.
           *
           * This is an asynchronous process. The policy will not be
           * fully removed yet when the response returns.
           * @param {string} legalHoldPolicyAssignmentId The ID of the legal hold policy assignment.
          Example: "753465"
           * @param {DeleteLegalHoldPolicyAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteLegalHoldPolicyAssignmentById(legalHoldPolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (legalHoldPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteLegalHoldPolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments/', toString(legalHoldPolicyAssignmentId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Get a list of files with current file versions for a legal hold
           * assignment.
           *
           * In some cases you may want to get previous file versions instead. In these
           * cases, use the `GET  /legal_hold_policy_assignments/:id/file_versions_on_hold`
           * API instead to return any previous versions of a file for this legal hold
           * policy assignment.
           *
           * Due to ongoing re-architecture efforts this API might not return all file
           * versions held for this policy ID. Instead, this API will only return the
           * latest file version held in the newly developed architecture. The `GET
           * /file_version_legal_holds` API can be used to fetch current and past versions
           * of files held within the legacy architecture.
           *
           * This endpoint does not support returning any content that is on hold due to
           * a Custodian collaborating on a Hub.
           *
           * The `GET /legal_hold_policy_assignments?policy_id={id}` API can be used to
           * find a list of policy assignments for a given policy ID.
           * @param {string} legalHoldPolicyAssignmentId The ID of the legal hold policy assignment.
          Example: "753465"
           * @param {GetLegalHoldPolicyAssignmentFileOnHoldOptionalsInput} optionalsInput
           * @returns {Promise<FilesOnHold>}
           */
        getLegalHoldPolicyAssignmentFileOnHold(legalHoldPolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (legalHoldPolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetLegalHoldPolicyAssignmentFileOnHoldOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/legal_hold_policy_assignments/', toString(legalHoldPolicyAssignmentId), '/files_on_hold'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFilesOnHold(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToTypeField(val) {
        return val;
    }
    function serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToField(val) {
        return {
            ['type']: serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateLegalHoldPolicyAssignmentRequestBody(val) {
        return {
            ['policy_id']: val.policyId,
            ['assign_to']: serializeCreateLegalHoldPolicyAssignmentRequestBodyAssignToField(val.assignTo),
        };
    }

    function deserializeFileVersionRetentionTypeField(val) {
        if (val == 'file_version_retention') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionRetentionTypeField",
        });
    }
    function deserializeFileVersionRetention(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionRetention"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionRetention"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeFileVersionRetentionTypeField(val.type);
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        const file = val.file == void 0 ? void 0 : deserializeFileMini(val.file);
        if (!(val.applied_at == void 0) && !sdIsString(val.applied_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "applied_at" of type "FileVersionRetention"',
            });
        }
        const appliedAt = val.applied_at == void 0 ? void 0 : dateTimeFromString(val.applied_at);
        if (!(val.disposition_at == void 0) && !sdIsString(val.disposition_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "disposition_at" of type "FileVersionRetention"',
            });
        }
        const dispositionAt = val.disposition_at == void 0
            ? void 0
            : dateTimeFromString(val.disposition_at);
        const winningRetentionPolicy = val.winning_retention_policy == void 0
            ? void 0
            : deserializeRetentionPolicyMini(val.winning_retention_policy);
        return {
            id: id,
            type: type,
            fileVersion: fileVersion,
            file: file,
            appliedAt: appliedAt,
            dispositionAt: dispositionAt,
            winningRetentionPolicy: winningRetentionPolicy,
        };
    }

    function deserializeFileVersionRetentions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionRetentions"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FileVersionRetentions"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FileVersionRetentions"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FileVersionRetentions"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileVersionRetentions"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileVersionRetention(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetFileVersionRetentionByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileVersionRetentionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionRetentionsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileVersionRetentionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileVersionRetentionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all file version retentions for the given enterprise.
         *
         * **Note**:
         * File retention API is now **deprecated**.
         * To get information about files and file versions under retention,
         * see [files under retention](e://get-retention-policy-assignments-id-files-under-retention) or [file versions under retention](e://get-retention-policy-assignments-id-file-versions-under-retention) endpoints.
         * @param {GetFileVersionRetentionsQueryParams} queryParams Query parameters of getFileVersionRetentions method
         * @param {GetFileVersionRetentionsHeadersInput} headersInput Headers of getFileVersionRetentions method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<FileVersionRetentions>}
         */
        getFileVersionRetentions() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetFileVersionRetentionsHeaders({}), cancellationToken) {
                const headers = new GetFileVersionRetentionsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['file_id']: toString(queryParams.fileId),
                    ['file_version_id']: toString(queryParams.fileVersionId),
                    ['policy_id']: toString(queryParams.policyId),
                    ['disposition_action']: toString(queryParams.dispositionAction),
                    ['disposition_before']: toString(queryParams.dispositionBefore),
                    ['disposition_after']: toString(queryParams.dispositionAfter),
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_retentions'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersionRetentions(response.data)), { rawData: response.data });
            });
        }
        /**
           * Returns information about a file version retention.
           *
           * **Note**:
           * File retention API is now **deprecated**.
           * To get information about files and file versions under retention,
           * see [files under retention](e://get-retention-policy-assignments-id-files-under-retention) or [file versions under retention](e://get-retention-policy-assignments-id-file-versions-under-retention) endpoints.
           * @param {string} fileVersionRetentionId The ID of the file version retention.
          Example: "3424234"
           * @param {GetFileVersionRetentionByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileVersionRetention>}
           */
        getFileVersionRetentionById(fileVersionRetentionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileVersionRetentionId, optionalsInput = {}) {
                const optionals = new GetFileVersionRetentionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_retentions/', toString(fileVersionRetentionId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersionRetention(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeFileVersionLegalHoldTypeField(val) {
        if (val == 'file_version_legal_hold') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionLegalHoldTypeField",
        });
    }
    function deserializeFileVersionLegalHold(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionLegalHold"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionLegalHold"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeFileVersionLegalHoldTypeField(val.type);
        const fileVersion = val.file_version == void 0
            ? void 0
            : deserializeFileVersionMini(val.file_version);
        const file = val.file == void 0 ? void 0 : deserializeFileMini(val.file);
        if (!(val.legal_hold_policy_assignments == void 0) &&
            !sdIsList(val.legal_hold_policy_assignments)) {
            throw new BoxSdkError({
                message: 'Expecting array for "legal_hold_policy_assignments" of type "FileVersionLegalHold"',
            });
        }
        const legalHoldPolicyAssignments = val.legal_hold_policy_assignments == void 0
            ? void 0
            : sdIsList(val.legal_hold_policy_assignments)
                ? val.legal_hold_policy_assignments.map(function (itm) {
                    return deserializeLegalHoldPolicyAssignment(itm);
                })
                : [];
        if (!(val.deleted_at == void 0) && !sdIsString(val.deleted_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "deleted_at" of type "FileVersionLegalHold"',
            });
        }
        const deletedAt = val.deleted_at == void 0 ? void 0 : dateTimeFromString(val.deleted_at);
        return {
            id: id,
            type: type,
            fileVersion: fileVersion,
            file: file,
            legalHoldPolicyAssignments: legalHoldPolicyAssignments,
            deletedAt: deletedAt,
        };
    }

    function deserializeFileVersionLegalHolds(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionLegalHolds"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "FileVersionLegalHolds"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "FileVersionLegalHolds"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "FileVersionLegalHolds"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "FileVersionLegalHolds"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeFileVersionLegalHold(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetFileVersionLegalHoldByIdOptionals {
        constructor(fields) {
            this.headers = new GetFileVersionLegalHoldByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionLegalHoldsOptionals {
        constructor(fields) {
            this.headers = new GetFileVersionLegalHoldsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetFileVersionLegalHoldByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetFileVersionLegalHoldsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class FileVersionLegalHoldsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves information about the legal hold policies
           * assigned to a file version.
           * @param {string} fileVersionLegalHoldId The ID of the file version legal hold.
          Example: "2348213"
           * @param {GetFileVersionLegalHoldByIdOptionalsInput} optionalsInput
           * @returns {Promise<FileVersionLegalHold>}
           */
        getFileVersionLegalHoldById(fileVersionLegalHoldId_1) {
            return __awaiter$1(this, arguments, void 0, function* (fileVersionLegalHoldId, optionalsInput = {}) {
                const optionals = new GetFileVersionLegalHoldByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_legal_holds/', toString(fileVersionLegalHoldId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersionLegalHold(response.data)), { rawData: response.data });
            });
        }
        /**
         * Get a list of file versions on legal hold for a legal hold
         * assignment.
         *
         * Due to ongoing re-architecture efforts this API might not return all file
         * versions for this policy ID.
         *
         * Instead, this API will only return file versions held in the legacy
         * architecture. Two new endpoints will available to request any file versions
         * held in the new architecture.
         *
         * For file versions held in the new architecture, the `GET
         * /legal_hold_policy_assignments/:id/file_versions_on_hold` API can be used to
         * return all past file versions available for this policy assignment, and the
         * `GET /legal_hold_policy_assignments/:id/files_on_hold` API can be used to
         * return any current (latest) versions of a file under legal hold.
         *
         * The `GET /legal_hold_policy_assignments?policy_id={id}` API can be used to
         * find a list of policy assignments for a given policy ID.
         *
         * Once the re-architecture is completed this API will be deprecated.
         * @param {GetFileVersionLegalHoldsQueryParams} queryParams Query parameters of getFileVersionLegalHolds method
         * @param {GetFileVersionLegalHoldsOptionalsInput} optionalsInput
         * @returns {Promise<FileVersionLegalHolds>}
         */
        getFileVersionLegalHolds(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetFileVersionLegalHoldsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['policy_id']: toString(queryParams.policyId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/file_version_legal_holds'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeFileVersionLegalHolds(response.data)), { rawData: response.data });
            });
        }
    }

    function serializeEnterpriseBaseTypeField(val) {
        return val;
    }
    function deserializeEnterpriseBaseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize EnterpriseBaseTypeField",
        });
    }
    function serializeEnterpriseBase(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeEnterpriseBaseTypeField(val.type),
        };
    }
    function deserializeEnterpriseBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "EnterpriseBase"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "EnterpriseBase"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeEnterpriseBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeShieldInformationBarrierTypeField(val) {
        if (val == 'shield_information_barrier') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierTypeField",
        });
    }
    function deserializeShieldInformationBarrierStatusField(val) {
        if (val == 'draft') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (val == 'disabled') {
            return val;
        }
        if (val == 'enabled') {
            return val;
        }
        if (val == 'invalid') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierStatusField",
        });
    }
    function deserializeShieldInformationBarrier(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrier"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrier"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierTypeField(val.type);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeEnterpriseBase(val.enterprise);
        const status = val.status == void 0
            ? void 0
            : deserializeShieldInformationBarrierStatusField(val.status);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrier"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrier"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        if (!(val.enabled_at == void 0) && !sdIsString(val.enabled_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "enabled_at" of type "ShieldInformationBarrier"',
            });
        }
        const enabledAt = val.enabled_at == void 0 ? void 0 : dateTimeFromString(val.enabled_at);
        const enabledBy = val.enabled_by == void 0 ? void 0 : deserializeUserBase(val.enabled_by);
        return {
            id: id,
            type: type,
            enterprise: enterprise,
            status: status,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
            enabledAt: enabledAt,
            enabledBy: enabledBy,
        };
    }

    function deserializeShieldInformationBarriers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarriers"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarriers"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarriers"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarriers"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrier(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateShieldInformationBarrierStatusOptionals {
        constructor(fields) {
            this.headers = new UpdateShieldInformationBarrierStatusHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateShieldInformationBarrierStatusHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarriersHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarriersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Get shield information barrier based on provided ID.
           * @param {string} shieldInformationBarrierId The ID of the shield information barrier.
          Example: "1910967"
           * @param {GetShieldInformationBarrierByIdOptionalsInput} optionalsInput
           * @returns {Promise<ShieldInformationBarrier>}
           */
        getShieldInformationBarrierById(shieldInformationBarrierId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers/', toString(shieldInformationBarrierId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrier(response.data)), { rawData: response.data });
            });
        }
        /**
         * Change status of shield information barrier with the specified ID.
         * @param {UpdateShieldInformationBarrierStatusRequestBody} requestBody Request body of updateShieldInformationBarrierStatus method
         * @param {UpdateShieldInformationBarrierStatusOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrier>}
         */
        updateShieldInformationBarrierStatus(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new UpdateShieldInformationBarrierStatusOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers/change_status'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeUpdateShieldInformationBarrierStatusRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrier(response.data)), { rawData: response.data });
            });
        }
        /**
         * Retrieves a list of shield information barrier objects
         * for the enterprise of JWT.
         * @param {GetShieldInformationBarriersQueryParams} queryParams Query parameters of getShieldInformationBarriers method
         * @param {GetShieldInformationBarriersHeadersInput} headersInput Headers of getShieldInformationBarriers method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<ShieldInformationBarriers>}
         */
        getShieldInformationBarriers() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetShieldInformationBarriersHeaders({}), cancellationToken) {
                const headers = new GetShieldInformationBarriersHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarriers(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a shield information barrier to
         * separate individuals/groups within the same
         * firm and prevents confidential information passing between them.
         * @param {CreateShieldInformationBarrierRequestBody} requestBody Request body of createShieldInformationBarrier method
         * @param {CreateShieldInformationBarrierOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrier>}
         */
        createShieldInformationBarrier(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barriers'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrier(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUpdateShieldInformationBarrierStatusRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateShieldInformationBarrierStatusRequestBody(val) {
        return {
            ['id']: val.id,
            ['status']: serializeUpdateShieldInformationBarrierStatusRequestBodyStatusField(val.status),
        };
    }
    function serializeCreateShieldInformationBarrierRequestBody(val) {
        return { ['enterprise']: serializeEnterpriseBase(val.enterprise) };
    }

    function deserializeShieldInformationBarrierReportBaseTypeField(val) {
        if (val == 'shield_information_barrier_report') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierReportBaseTypeField",
        });
    }

    function serializeShieldInformationBarrierBaseTypeField(val) {
        return val;
    }
    function deserializeShieldInformationBarrierBaseTypeField(val) {
        if (val == 'shield_information_barrier') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierBaseTypeField",
        });
    }
    function serializeShieldInformationBarrierBase(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeShieldInformationBarrierBaseTypeField(val.type),
        };
    }
    function deserializeShieldInformationBarrierBase(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierBase"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierBase"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierBaseTypeField(val.type);
        return { id: id, type: type };
    }

    function serializeShieldInformationBarrierReference(val) {
        return {
            ['shield_information_barrier']: val.shieldInformationBarrier == void 0
                ? val.shieldInformationBarrier
                : serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
        };
    }
    function deserializeShieldInformationBarrierReference(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReference"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        return {
            shieldInformationBarrier: shieldInformationBarrier,
        };
    }

    function deserializeShieldInformationBarrierReportDetailsDetailsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReportDetailsDetailsField"',
            });
        }
        if (!(val.folder_id == void 0) && !sdIsString(val.folder_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_id" of type "ShieldInformationBarrierReportDetailsDetailsField"',
            });
        }
        const folderId = val.folder_id == void 0 ? void 0 : val.folder_id;
        return {
            folderId: folderId,
        };
    }
    function deserializeShieldInformationBarrierReportDetails(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReportDetails"',
            });
        }
        const details = val.details == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportDetailsDetailsField(val.details);
        return { details: details };
    }

    function deserializeShieldInformationBarrierReportStatusField(val) {
        if (val == 'pending') {
            return val;
        }
        if (val == 'error') {
            return val;
        }
        if (val == 'done') {
            return val;
        }
        if (val == 'cancelled') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierReportStatusField",
        });
    }
    function deserializeShieldInformationBarrierReport(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReport"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierReference(val.shield_information_barrier);
        const status = val.status == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportStatusField(val.status);
        const details = val.details == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportDetails(val.details);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierReport"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierReport"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierReport"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierReportBaseTypeField(val.type);
        return {
            shieldInformationBarrier: shieldInformationBarrier,
            status: status,
            details: details,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            id: id,
            type: type,
        };
    }

    function deserializeShieldInformationBarrierReports(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierReports"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierReports"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierReports"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierReports"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierReport(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierReportsOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierReportsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierReportOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierReportHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierReportByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierReportByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierReportsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierReportHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierReportByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierReportsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Lists shield information barrier reports.
         * @param {GetShieldInformationBarrierReportsQueryParams} queryParams Query parameters of getShieldInformationBarrierReports method
         * @param {GetShieldInformationBarrierReportsOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierReports>}
         */
        getShieldInformationBarrierReports(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierReportsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_id']: toString(queryParams.shieldInformationBarrierId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_reports'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierReports(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a shield information barrier report for a given barrier.
         * @param {ShieldInformationBarrierReference} requestBody Request body of createShieldInformationBarrierReport method
         * @param {CreateShieldInformationBarrierReportOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierReport>}
         */
        createShieldInformationBarrierReport(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierReportOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_reports'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeShieldInformationBarrierReference(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierReport(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a shield information barrier report by its ID.
           * @param {string} shieldInformationBarrierReportId The ID of the shield information barrier Report.
          Example: "3423"
           * @param {GetShieldInformationBarrierReportByIdOptionalsInput} optionalsInput
           * @returns {Promise<ShieldInformationBarrierReport>}
           */
        getShieldInformationBarrierReportById(shieldInformationBarrierReportId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierReportId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierReportByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_reports/', toString(shieldInformationBarrierReportId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierReport(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeShieldInformationBarrierSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegment"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegment"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentTypeField(val.type);
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "ShieldInformationBarrierSegment"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "ShieldInformationBarrierSegment"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierSegment"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierSegment"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        return {
            id: id,
            type: type,
            shieldInformationBarrier: shieldInformationBarrier,
            name: name,
            description: description,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
        };
    }

    function deserializeShieldInformationBarrierSegments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegments"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierSegments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierSegments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierSegments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierSegment(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierSegmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteShieldInformationBarrierSegmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateShieldInformationBarrierSegmentByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateShieldInformationBarrierSegmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentsOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierSegmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateShieldInformationBarrierSegmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierSegmentsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierSegmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves shield information barrier segment based on provided ID..
           * @param {string} shieldInformationBarrierSegmentId The ID of the shield information barrier segment.
          Example: "3423"
           * @param {GetShieldInformationBarrierSegmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<ShieldInformationBarrierSegment>}
           */
        getShieldInformationBarrierSegmentById(shieldInformationBarrierSegmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierSegmentId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments/', toString(shieldInformationBarrierSegmentId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes the shield information barrier segment
           * based on provided ID.
           * @param {string} shieldInformationBarrierSegmentId The ID of the shield information barrier segment.
          Example: "3423"
           * @param {DeleteShieldInformationBarrierSegmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteShieldInformationBarrierSegmentById(shieldInformationBarrierSegmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierSegmentId, optionalsInput = {}) {
                const optionals = new DeleteShieldInformationBarrierSegmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments/', toString(shieldInformationBarrierSegmentId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Updates the shield information barrier segment based on provided ID..
           * @param {string} shieldInformationBarrierSegmentId The ID of the shield information barrier segment.
          Example: "3423"
           * @param {UpdateShieldInformationBarrierSegmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<ShieldInformationBarrierSegment>}
           */
        updateShieldInformationBarrierSegmentById(shieldInformationBarrierSegmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierSegmentId, optionalsInput = {}) {
                const optionals = new UpdateShieldInformationBarrierSegmentByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments/', toString(shieldInformationBarrierSegmentId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateShieldInformationBarrierSegmentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegment(response.data)), { rawData: response.data });
            });
        }
        /**
         * Retrieves a list of shield information barrier segment objects
         * for the specified Information Barrier ID.
         * @param {GetShieldInformationBarrierSegmentsQueryParams} queryParams Query parameters of getShieldInformationBarrierSegments method
         * @param {GetShieldInformationBarrierSegmentsOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierSegments>}
         */
        getShieldInformationBarrierSegments(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_id']: toString(queryParams.shieldInformationBarrierId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegments(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a shield information barrier segment.
         * @param {CreateShieldInformationBarrierSegmentRequestBody} requestBody Request body of createShieldInformationBarrierSegment method
         * @param {CreateShieldInformationBarrierSegmentOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierSegment>}
         */
        createShieldInformationBarrierSegment(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierSegmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segments'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierSegmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegment(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeUpdateShieldInformationBarrierSegmentByIdRequestBody(val) {
        return { ['name']: val.name, ['description']: val.description };
    }
    function serializeCreateShieldInformationBarrierSegmentRequestBody(val) {
        return {
            ['shield_information_barrier']: serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
            ['name']: val.name,
            ['description']: val.description,
        };
    }

    function deserializeShieldInformationBarrierSegmentMemberBaseTypeField(val) {
        if (val == 'shield_information_barrier_segment_member') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentMemberBaseTypeField",
        });
    }

    function deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }
    function deserializeShieldInformationBarrierSegmentMember(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentMember"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        const shieldInformationBarrierSegment = val.shield_information_barrier_segment == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentMemberShieldInformationBarrierSegmentField(val.shield_information_barrier_segment);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierSegmentMember"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierSegmentMember"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        const user = val.user == void 0 ? void 0 : deserializeUserBase(val.user);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentMember"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentMemberBaseTypeField(val.type);
        return {
            shieldInformationBarrier: shieldInformationBarrier,
            shieldInformationBarrierSegment: shieldInformationBarrierSegment,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
            user: user,
            id: id,
            type: type,
        };
    }

    function deserializeShieldInformationBarrierSegmentMembers(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentMembers"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierSegmentMembers"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierSegmentMembers"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierSegmentMembers"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierSegmentMember(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierSegmentMemberByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentMemberByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentMemberByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteShieldInformationBarrierSegmentMemberByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentMembersOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentMembersHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentMemberOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierSegmentMemberHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentMemberByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentMemberByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierSegmentMembersHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentMemberHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierSegmentMembersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves a shield information barrier
           * segment member by its ID.
           * @param {string} shieldInformationBarrierSegmentMemberId The ID of the shield information barrier segment Member.
          Example: "7815"
           * @param {GetShieldInformationBarrierSegmentMemberByIdOptionalsInput} optionalsInput
           * @returns {Promise<ShieldInformationBarrierSegmentMember>}
           */
        getShieldInformationBarrierSegmentMemberById(shieldInformationBarrierSegmentMemberId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierSegmentMemberId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentMemberByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members/', toString(shieldInformationBarrierSegmentMemberId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegmentMember(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a shield information barrier
           * segment member based on provided ID.
           * @param {string} shieldInformationBarrierSegmentMemberId The ID of the shield information barrier segment Member.
          Example: "7815"
           * @param {DeleteShieldInformationBarrierSegmentMemberByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteShieldInformationBarrierSegmentMemberById(shieldInformationBarrierSegmentMemberId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierSegmentMemberId, optionalsInput = {}) {
                const optionals = new DeleteShieldInformationBarrierSegmentMemberByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members/', toString(shieldInformationBarrierSegmentMemberId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
         * Lists shield information barrier segment members
         * based on provided segment IDs.
         * @param {GetShieldInformationBarrierSegmentMembersQueryParams} queryParams Query parameters of getShieldInformationBarrierSegmentMembers method
         * @param {GetShieldInformationBarrierSegmentMembersOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierSegmentMembers>}
         */
        getShieldInformationBarrierSegmentMembers(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentMembersOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_segment_id']: toString(queryParams.shieldInformationBarrierSegmentId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegmentMembers(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new shield information barrier segment member.
         * @param {CreateShieldInformationBarrierSegmentMemberRequestBody} requestBody Request body of createShieldInformationBarrierSegmentMember method
         * @param {CreateShieldInformationBarrierSegmentMemberOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierSegmentMember>}
         */
        createShieldInformationBarrierSegmentMember(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldInformationBarrierSegmentMemberOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_members'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierSegmentMemberRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegmentMember(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBodyTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentField(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentTypeField(val.type),
        };
    }
    function serializeCreateShieldInformationBarrierSegmentMemberRequestBody(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeCreateShieldInformationBarrierSegmentMemberRequestBodyTypeField(val.type),
            ['shield_information_barrier']: val.shieldInformationBarrier == void 0
                ? val.shieldInformationBarrier
                : serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
            ['shield_information_barrier_segment']: serializeCreateShieldInformationBarrierSegmentMemberRequestBodyShieldInformationBarrierSegmentField(val.shieldInformationBarrierSegment),
            ['user']: serializeUserBase(val.user),
        };
    }

    function deserializeShieldInformationBarrierSegmentRestrictionBaseTypeField(val) {
        if (val == 'shield_information_barrier_segment_restriction') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentRestrictionBaseTypeField",
        });
    }

    function deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }
    function deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentTypeField(val) {
        if (val == 'shield_information_barrier_segment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentTypeField",
        });
    }
    function deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentTypeField(val.type);
        return {
            id: id,
            type: type,
        };
    }

    function deserializeShieldInformationBarrierSegmentRestriction(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const shieldInformationBarrier = val.shield_information_barrier == void 0
            ? void 0
            : deserializeShieldInformationBarrierBase(val.shield_information_barrier);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const updatedBy = val.updated_by == void 0 ? void 0 : deserializeUserBase(val.updated_by);
        if (val.shield_information_barrier_segment == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "shield_information_barrier_segment" of type "ShieldInformationBarrierSegmentRestriction" to be defined',
            });
        }
        const shieldInformationBarrierSegment = deserializeShieldInformationBarrierSegmentRestrictionMiniShieldInformationBarrierSegmentField(val.shield_information_barrier_segment);
        if (val.restricted_segment == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "restricted_segment" of type "ShieldInformationBarrierSegmentRestriction" to be defined',
            });
        }
        const restrictedSegment = deserializeShieldInformationBarrierSegmentRestrictionMiniRestrictedSegmentField(val.restricted_segment);
        const type = val.type == void 0
            ? void 0
            : deserializeShieldInformationBarrierSegmentRestrictionBaseTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldInformationBarrierSegmentRestriction"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return {
            shieldInformationBarrier: shieldInformationBarrier,
            createdAt: createdAt,
            createdBy: createdBy,
            updatedAt: updatedAt,
            updatedBy: updatedBy,
            shieldInformationBarrierSegment: shieldInformationBarrierSegment,
            restrictedSegment: restrictedSegment,
            type: type,
            id: id,
        };
    }

    function deserializeShieldInformationBarrierSegmentRestrictions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldInformationBarrierSegmentRestrictions"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldInformationBarrierSegmentRestriction(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    class GetShieldInformationBarrierSegmentRestrictionByIdOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentRestrictionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentRestrictionByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteShieldInformationBarrierSegmentRestrictionByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentRestrictionsOptionals {
        constructor(fields) {
            this.headers = new GetShieldInformationBarrierSegmentRestrictionsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentRestrictionOptionals {
        constructor(fields) {
            this.headers = new CreateShieldInformationBarrierSegmentRestrictionHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldInformationBarrierSegmentRestrictionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteShieldInformationBarrierSegmentRestrictionByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldInformationBarrierSegmentRestrictionsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentRestrictionRequestBody {
        constructor(fields) {
            /**
             * The type of the shield barrier segment
             * restriction for this member. */
            this.type = 'shield_information_barrier_segment_restriction';
            if (fields.type !== undefined) {
                this.type = fields.type;
            }
            if (fields.shieldInformationBarrier !== undefined) {
                this.shieldInformationBarrier = fields.shieldInformationBarrier;
            }
            if (fields.shieldInformationBarrierSegment !== undefined) {
                this.shieldInformationBarrierSegment =
                    fields.shieldInformationBarrierSegment;
            }
            if (fields.restrictedSegment !== undefined) {
                this.restrictedSegment = fields.restrictedSegment;
            }
            if (fields.rawData !== undefined) {
                this.rawData = fields.rawData;
            }
        }
    }
    class CreateShieldInformationBarrierSegmentRestrictionHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldInformationBarrierSegmentRestrictionsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves a shield information barrier segment
           * restriction based on provided ID.
           * @param {string} shieldInformationBarrierSegmentRestrictionId The ID of the shield information barrier segment Restriction.
          Example: "4563"
           * @param {GetShieldInformationBarrierSegmentRestrictionByIdOptionalsInput} optionalsInput
           * @returns {Promise<ShieldInformationBarrierSegmentRestriction>}
           */
        getShieldInformationBarrierSegmentRestrictionById(shieldInformationBarrierSegmentRestrictionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierSegmentRestrictionId, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentRestrictionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions/', toString(shieldInformationBarrierSegmentRestrictionId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegmentRestriction(response.data)), { rawData: response.data });
            });
        }
        /**
           * Delete shield information barrier segment restriction
           * based on provided ID.
           * @param {string} shieldInformationBarrierSegmentRestrictionId The ID of the shield information barrier segment Restriction.
          Example: "4563"
           * @param {DeleteShieldInformationBarrierSegmentRestrictionByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteShieldInformationBarrierSegmentRestrictionById(shieldInformationBarrierSegmentRestrictionId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldInformationBarrierSegmentRestrictionId, optionalsInput = {}) {
                const optionals = new DeleteShieldInformationBarrierSegmentRestrictionByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions/', toString(shieldInformationBarrierSegmentRestrictionId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
         * Lists shield information barrier segment restrictions
         * based on provided segment ID.
         * @param {GetShieldInformationBarrierSegmentRestrictionsQueryParams} queryParams Query parameters of getShieldInformationBarrierSegmentRestrictions method
         * @param {GetShieldInformationBarrierSegmentRestrictionsOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierSegmentRestrictions>}
         */
        getShieldInformationBarrierSegmentRestrictions(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetShieldInformationBarrierSegmentRestrictionsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['shield_information_barrier_segment_id']: toString(queryParams.shieldInformationBarrierSegmentId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegmentRestrictions(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a shield information barrier
         * segment restriction object.
         * @param {CreateShieldInformationBarrierSegmentRestrictionRequestBodyInput} requestBodyInput Request body of createShieldInformationBarrierSegmentRestriction method
         * @param {CreateShieldInformationBarrierSegmentRestrictionOptionalsInput} optionalsInput
         * @returns {Promise<ShieldInformationBarrierSegmentRestriction>}
         */
        createShieldInformationBarrierSegmentRestriction(requestBodyInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBodyInput, optionalsInput = {}) {
                const requestBody = new CreateShieldInformationBarrierSegmentRestrictionRequestBody({
                    type: requestBodyInput.type,
                    shieldInformationBarrier: requestBodyInput.shieldInformationBarrier,
                    shieldInformationBarrierSegment: requestBodyInput.shieldInformationBarrierSegment,
                    restrictedSegment: requestBodyInput.restrictedSegment,
                });
                const optionals = new CreateShieldInformationBarrierSegmentRestrictionOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_information_barrier_segment_restrictions'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldInformationBarrierSegmentRestriction(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentField(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentTypeField(val.type),
        };
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentTypeField(val) {
        return val;
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentField(val) {
        return {
            ['id']: val.id,
            ['type']: val.type == void 0
                ? val.type
                : serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentTypeField(val.type),
        };
    }
    function serializeCreateShieldInformationBarrierSegmentRestrictionRequestBody(val) {
        return {
            ['type']: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyTypeField(val.type),
            ['shield_information_barrier']: val.shieldInformationBarrier == void 0
                ? val.shieldInformationBarrier
                : serializeShieldInformationBarrierBase(val.shieldInformationBarrier),
            ['shield_information_barrier_segment']: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyShieldInformationBarrierSegmentField(val.shieldInformationBarrierSegment),
            ['restricted_segment']: serializeCreateShieldInformationBarrierSegmentRestrictionRequestBodyRestrictedSegmentField(val.restrictedSegment),
        };
    }

    function deserializeDevicePinnerTypeField(val) {
        if (val == 'device_pinner') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize DevicePinnerTypeField" });
    }
    function deserializeDevicePinner(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "DevicePinner"' });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "DevicePinner"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeDevicePinnerTypeField(val.type);
        const ownedBy = val.owned_by == void 0 ? void 0 : deserializeUserMini(val.owned_by);
        if (!(val.product_name == void 0) && !sdIsString(val.product_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "product_name" of type "DevicePinner"',
            });
        }
        const productName = val.product_name == void 0 ? void 0 : val.product_name;
        return {
            id: id,
            type: type,
            ownedBy: ownedBy,
            productName: productName,
        };
    }

    function deserializeDevicePinnersOrderByField(val) {
        if (val == 'id') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DevicePinnersOrderByField",
        });
    }
    function deserializeDevicePinnersOrderDirectionField(val) {
        if (val == 'asc') {
            return val;
        }
        if (val == 'desc') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DevicePinnersOrderDirectionField",
        });
    }
    function deserializeDevicePinnersOrderField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DevicePinnersOrderField"',
            });
        }
        const by = val.by == void 0 ? void 0 : deserializeDevicePinnersOrderByField(val.by);
        const direction = val.direction == void 0
            ? void 0
            : deserializeDevicePinnersOrderDirectionField(val.direction);
        return { by: by, direction: direction };
    }
    function deserializeDevicePinners(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "DevicePinners"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "DevicePinners"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeDevicePinner(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "DevicePinners"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsNumber(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting number for "next_marker" of type "DevicePinners"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.order == void 0) && !sdIsList(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting array for "order" of type "DevicePinners"',
            });
        }
        const order = val.order == void 0
            ? void 0
            : sdIsList(val.order)
                ? val.order.map(function (itm) {
                    return deserializeDevicePinnersOrderField(itm);
                })
                : [];
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
            order: order,
        };
    }

    class GetDevicePinnerByIdOptionals {
        constructor(fields) {
            this.headers = new GetDevicePinnerByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteDevicePinnerByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteDevicePinnerByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetEnterpriseDevicePinnersOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetEnterpriseDevicePinnersHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDevicePinnerByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteDevicePinnerByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetEnterpriseDevicePinnersHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DevicePinnersManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Retrieves information about an individual device pin.
           * @param {string} devicePinnerId The ID of the device pin.
          Example: "2324234"
           * @param {GetDevicePinnerByIdOptionalsInput} optionalsInput
           * @returns {Promise<DevicePinner>}
           */
        getDevicePinnerById(devicePinnerId_1) {
            return __awaiter$1(this, arguments, void 0, function* (devicePinnerId, optionalsInput = {}) {
                const optionals = new GetDevicePinnerByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/device_pinners/', toString(devicePinnerId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDevicePinner(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes an individual device pin.
           * @param {string} devicePinnerId The ID of the device pin.
          Example: "2324234"
           * @param {DeleteDevicePinnerByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteDevicePinnerById(devicePinnerId_1) {
            return __awaiter$1(this, arguments, void 0, function* (devicePinnerId, optionalsInput = {}) {
                const optionals = new DeleteDevicePinnerByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/device_pinners/', toString(devicePinnerId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Retrieves all the device pins within an enterprise.
           *
           * The user must have admin privileges, and the application
           * needs the "manage enterprise" scope to make this call.
           * @param {string} enterpriseId The ID of the enterprise.
          Example: "3442311"
           * @param {GetEnterpriseDevicePinnersOptionalsInput} optionalsInput
           * @returns {Promise<DevicePinners>}
           */
        getEnterpriseDevicePinners(enterpriseId_1) {
            return __awaiter$1(this, arguments, void 0, function* (enterpriseId, optionalsInput = {}) {
                const optionals = new GetEnterpriseDevicePinnersOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['direction']: toString(queryParams.direction),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/enterprises/', toString(enterpriseId), '/device_pinners'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDevicePinners(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeTermsOfServiceStatusField(val) {
        if (val == 'enabled') {
            return val;
        }
        if (val == 'disabled') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceStatusField",
        });
    }
    function deserializeTermsOfServiceEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceEnterpriseTypeField",
        });
    }
    function deserializeTermsOfServiceEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfServiceEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeTermsOfServiceEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "TermsOfServiceEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            id: id,
            type: type,
            name: name,
        };
    }
    function deserializeTermsOfServiceTosTypeField(val) {
        if (val == 'managed') {
            return val;
        }
        if (val == 'external') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceTosTypeField",
        });
    }
    function deserializeTermsOfService(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TermsOfService"' });
        }
        const status = val.status == void 0
            ? void 0
            : deserializeTermsOfServiceStatusField(val.status);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeTermsOfServiceEnterpriseField(val.enterprise);
        const tosType = val.tos_type == void 0
            ? void 0
            : deserializeTermsOfServiceTosTypeField(val.tos_type);
        if (!(val.text == void 0) && !sdIsString(val.text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text" of type "TermsOfService"',
            });
        }
        const text = val.text == void 0 ? void 0 : val.text;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TermsOfService"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TermsOfService"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TermsOfService" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfService"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TermsOfService" to be defined',
            });
        }
        const type = deserializeTermsOfServiceBaseTypeField(val.type);
        return {
            status: status,
            enterprise: enterprise,
            tosType: tosType,
            text: text,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            id: id,
            type: type,
        };
    }

    function deserializeTermsOfServices(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TermsOfServices"' });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TermsOfServices"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TermsOfServices"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTermsOfService(itm);
                })
                : [];
        return { totalCount: totalCount, entries: entries };
    }

    class CreateTermsOfServiceOptionals {
        constructor(fields) {
            this.headers = new CreateTermsOfServiceHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTermsOfServiceByIdOptionals {
        constructor(fields) {
            this.headers = new GetTermsOfServiceByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTermsOfServiceByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateTermsOfServiceByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTermsOfServiceHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTermsOfServiceHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTermsOfServiceByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTermsOfServiceByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TermsOfServicesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns the current terms of service text and settings
         * for the enterprise.
         * @param {GetTermsOfServiceQueryParams} queryParams Query parameters of getTermsOfService method
         * @param {GetTermsOfServiceHeadersInput} headersInput Headers of getTermsOfService method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<TermsOfServices>}
         */
        getTermsOfService() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetTermsOfServiceHeaders({}), cancellationToken) {
                const headers = new GetTermsOfServiceHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['tos_type']: toString(queryParams.tosType),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTermsOfServices(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a terms of service for a given enterprise
         * and type of user.
         * @param {CreateTermsOfServiceRequestBody} requestBody Request body of createTermsOfService method
         * @param {CreateTermsOfServiceOptionalsInput} optionalsInput
         * @returns {Promise<TermsOfService>}
         */
        createTermsOfService(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTermsOfServiceOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTermsOfServiceRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTermsOfService(response.data)), { rawData: response.data });
            });
        }
        /**
           * Fetches a specific terms of service.
           * @param {string} termsOfServiceId The ID of the terms of service.
          Example: "324234"
           * @param {GetTermsOfServiceByIdOptionalsInput} optionalsInput
           * @returns {Promise<TermsOfService>}
           */
        getTermsOfServiceById(termsOfServiceId_1) {
            return __awaiter$1(this, arguments, void 0, function* (termsOfServiceId, optionalsInput = {}) {
                const optionals = new GetTermsOfServiceByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services/', toString(termsOfServiceId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTermsOfService(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a specific terms of service.
           * @param {string} termsOfServiceId The ID of the terms of service.
          Example: "324234"
           * @param {UpdateTermsOfServiceByIdRequestBody} requestBody Request body of updateTermsOfServiceById method
           * @param {UpdateTermsOfServiceByIdOptionalsInput} optionalsInput
           * @returns {Promise<TermsOfService>}
           */
        updateTermsOfServiceById(termsOfServiceId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (termsOfServiceId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateTermsOfServiceByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_services/', toString(termsOfServiceId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTermsOfServiceByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTermsOfService(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeCreateTermsOfServiceRequestBodyStatusField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceRequestBodyTosTypeField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceRequestBody(val) {
        return {
            ['status']: serializeCreateTermsOfServiceRequestBodyStatusField(val.status),
            ['tos_type']: val.tosType == void 0
                ? val.tosType
                : serializeCreateTermsOfServiceRequestBodyTosTypeField(val.tosType),
            ['text']: val.text,
        };
    }
    function serializeUpdateTermsOfServiceByIdRequestBodyStatusField(val) {
        return val;
    }
    function serializeUpdateTermsOfServiceByIdRequestBody(val) {
        return {
            ['status']: serializeUpdateTermsOfServiceByIdRequestBodyStatusField(val.status),
            ['text']: val.text,
        };
    }

    function deserializeTermsOfServiceUserStatusTypeField(val) {
        if (val == 'terms_of_service_user_status') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceUserStatusTypeField",
        });
    }
    function deserializeTermsOfServiceUserStatus(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceUserStatus"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TermsOfServiceUserStatus" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfServiceUserStatus"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TermsOfServiceUserStatus" to be defined',
            });
        }
        const type = deserializeTermsOfServiceUserStatusTypeField(val.type);
        const tos = val.tos == void 0 ? void 0 : deserializeTermsOfServiceBase(val.tos);
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        if (!(val.is_accepted == void 0) && !sdIsBoolean(val.is_accepted)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accepted" of type "TermsOfServiceUserStatus"',
            });
        }
        const isAccepted = val.is_accepted == void 0 ? void 0 : val.is_accepted;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "TermsOfServiceUserStatus"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "TermsOfServiceUserStatus"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            tos: tos,
            user: user,
            isAccepted: isAccepted,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    function deserializeTermsOfServiceUserStatuses(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceUserStatuses"',
            });
        }
        if (!(val.total_count == void 0) && !sdIsNumber(val.total_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_count" of type "TermsOfServiceUserStatuses"',
            });
        }
        const totalCount = val.total_count == void 0 ? void 0 : val.total_count;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "TermsOfServiceUserStatuses"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeTermsOfServiceUserStatus(itm);
                })
                : [];
        return {
            totalCount: totalCount,
            entries: entries,
        };
    }

    class GetTermsOfServiceUserStatusesOptionals {
        constructor(fields) {
            this.headers = new GetTermsOfServiceUserStatusesHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateTermsOfServiceStatusForUserOptionals {
        constructor(fields) {
            this.headers = new CreateTermsOfServiceStatusForUserHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTermsOfServiceStatusForUserByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateTermsOfServiceStatusForUserByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetTermsOfServiceUserStatusesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTermsOfServiceStatusForUserHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTermsOfServiceStatusForUserByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class TermsOfServiceUserStatusesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves an overview of users and their status for a
         * terms of service, including Whether they have accepted
         * the terms and when.
         * @param {GetTermsOfServiceUserStatusesQueryParams} queryParams Query parameters of getTermsOfServiceUserStatuses method
         * @param {GetTermsOfServiceUserStatusesOptionalsInput} optionalsInput
         * @returns {Promise<TermsOfServiceUserStatuses>}
         */
        getTermsOfServiceUserStatuses(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetTermsOfServiceUserStatusesOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['tos_id']: toString(queryParams.tosId),
                    ['user_id']: toString(queryParams.userId),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_service_user_statuses'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTermsOfServiceUserStatuses(response.data)), { rawData: response.data });
            });
        }
        /**
         * Sets the status for a terms of service for a user.
         * @param {CreateTermsOfServiceStatusForUserRequestBody} requestBody Request body of createTermsOfServiceStatusForUser method
         * @param {CreateTermsOfServiceStatusForUserOptionalsInput} optionalsInput
         * @returns {Promise<TermsOfServiceUserStatus>}
         */
        createTermsOfServiceStatusForUser(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTermsOfServiceStatusForUserOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_service_user_statuses'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateTermsOfServiceStatusForUserRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTermsOfServiceUserStatus(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates the status for a terms of service for a user.
           * @param {string} termsOfServiceUserStatusId The ID of the terms of service status.
          Example: "324234"
           * @param {UpdateTermsOfServiceStatusForUserByIdRequestBody} requestBody Request body of updateTermsOfServiceStatusForUserById method
           * @param {UpdateTermsOfServiceStatusForUserByIdOptionalsInput} optionalsInput
           * @returns {Promise<TermsOfServiceUserStatus>}
           */
        updateTermsOfServiceStatusForUserById(termsOfServiceUserStatusId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (termsOfServiceUserStatusId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateTermsOfServiceStatusForUserByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/terms_of_service_user_statuses/', toString(termsOfServiceUserStatusId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTermsOfServiceStatusForUserByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeTermsOfServiceUserStatus(response.data)), { rawData: response.data });
            });
        }
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyTosTypeField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyTosField(val) {
        return {
            ['type']: serializeCreateTermsOfServiceStatusForUserRequestBodyTosTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyUserTypeField(val) {
        return val;
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBodyUserField(val) {
        return {
            ['type']: serializeCreateTermsOfServiceStatusForUserRequestBodyUserTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateTermsOfServiceStatusForUserRequestBody(val) {
        return {
            ['tos']: serializeCreateTermsOfServiceStatusForUserRequestBodyTosField(val.tos),
            ['user']: serializeCreateTermsOfServiceStatusForUserRequestBodyUserField(val.user),
            ['is_accepted']: val.isAccepted,
        };
    }
    function serializeUpdateTermsOfServiceStatusForUserByIdRequestBody(val) {
        return { ['is_accepted']: val.isAccepted };
    }

    function deserializeCollaborationAllowlistEntryTypeField(val) {
        if (val == 'collaboration_whitelist_entry') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistEntryTypeField",
        });
    }
    function deserializeCollaborationAllowlistEntryDirectionField(val) {
        if (val == 'inbound') {
            return val;
        }
        if (val == 'outbound') {
            return val;
        }
        if (val == 'both') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistEntryDirectionField",
        });
    }
    function deserializeCollaborationAllowlistEntryEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistEntryEnterpriseTypeField",
        });
    }
    function deserializeCollaborationAllowlistEntryEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistEntryEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistEntryEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "CollaborationAllowlistEntryEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            id: id,
            type: type,
            name: name,
        };
    }
    function deserializeCollaborationAllowlistEntry(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistEntry"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistEntry"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryTypeField(val.type);
        if (!(val.domain == void 0) && !sdIsString(val.domain)) {
            throw new BoxSdkError({
                message: 'Expecting string for "domain" of type "CollaborationAllowlistEntry"',
            });
        }
        const domain = val.domain == void 0 ? void 0 : val.domain;
        const direction = val.direction == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryDirectionField(val.direction);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeCollaborationAllowlistEntryEnterpriseField(val.enterprise);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "CollaborationAllowlistEntry"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        return {
            id: id,
            type: type,
            domain: domain,
            direction: direction,
            enterprise: enterprise,
            createdAt: createdAt,
        };
    }

    function deserializeCollaborationAllowlistEntries(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistEntries"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "CollaborationAllowlistEntries"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "CollaborationAllowlistEntries"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "CollaborationAllowlistEntries"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "CollaborationAllowlistEntries"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollaborationAllowlistEntry(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class CreateCollaborationWhitelistEntryOptionals {
        constructor(fields) {
            this.headers = new CreateCollaborationWhitelistEntryHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistEntryByIdOptionals {
        constructor(fields) {
            this.headers = new GetCollaborationWhitelistEntryByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCollaborationWhitelistEntryByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCollaborationWhitelistEntryByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistEntriesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCollaborationWhitelistEntryHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollaborationWhitelistEntryByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCollaborationWhitelistEntryByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CollaborationAllowlistEntriesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns the list domains that have been deemed safe to create collaborations
         * for within the current enterprise.
         * @param {GetCollaborationWhitelistEntriesQueryParams} queryParams Query parameters of getCollaborationWhitelistEntries method
         * @param {GetCollaborationWhitelistEntriesHeadersInput} headersInput Headers of getCollaborationWhitelistEntries method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<CollaborationAllowlistEntries>}
         */
        getCollaborationWhitelistEntries() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetCollaborationWhitelistEntriesHeaders({}), cancellationToken) {
                const headers = new GetCollaborationWhitelistEntriesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationAllowlistEntries(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new entry in the list of allowed domains to allow
         * collaboration for.
         * @param {CreateCollaborationWhitelistEntryRequestBody} requestBody Request body of createCollaborationWhitelistEntry method
         * @param {CreateCollaborationWhitelistEntryOptionalsInput} optionalsInput
         * @returns {Promise<CollaborationAllowlistEntry>}
         */
        createCollaborationWhitelistEntry(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCollaborationWhitelistEntryOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateCollaborationWhitelistEntryRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationAllowlistEntry(response.data)), { rawData: response.data });
            });
        }
        /**
           * Returns a domain that has been deemed safe to create collaborations
           * for within the current enterprise.
           * @param {string} collaborationWhitelistEntryId The ID of the entry in the list.
          Example: "213123"
           * @param {GetCollaborationWhitelistEntryByIdOptionalsInput} optionalsInput
           * @returns {Promise<CollaborationAllowlistEntry>}
           */
        getCollaborationWhitelistEntryById(collaborationWhitelistEntryId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collaborationWhitelistEntryId, optionalsInput = {}) {
                const optionals = new GetCollaborationWhitelistEntryByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries/', toString(collaborationWhitelistEntryId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationAllowlistEntry(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes a domain from the list of domains that have been deemed safe to create
           * collaborations for within the current enterprise.
           * @param {string} collaborationWhitelistEntryId The ID of the entry in the list.
          Example: "213123"
           * @param {DeleteCollaborationWhitelistEntryByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteCollaborationWhitelistEntryById(collaborationWhitelistEntryId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collaborationWhitelistEntryId, optionalsInput = {}) {
                const optionals = new DeleteCollaborationWhitelistEntryByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_entries/', toString(collaborationWhitelistEntryId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateCollaborationWhitelistEntryRequestBodyDirectionField(val) {
        return val;
    }
    function serializeCreateCollaborationWhitelistEntryRequestBody(val) {
        return {
            ['domain']: val.domain,
            ['direction']: serializeCreateCollaborationWhitelistEntryRequestBodyDirectionField(val.direction),
        };
    }

    function deserializeCollaborationAllowlistExemptTargetTypeField(val) {
        if (val == 'collaboration_whitelist_exempt_target') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistExemptTargetTypeField",
        });
    }
    function deserializeCollaborationAllowlistExemptTargetEnterpriseTypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize CollaborationAllowlistExemptTargetEnterpriseTypeField",
        });
    }
    function deserializeCollaborationAllowlistExemptTargetEnterpriseField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistExemptTargetEnterpriseField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistExemptTargetEnterpriseField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistExemptTargetEnterpriseTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "CollaborationAllowlistExemptTargetEnterpriseField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            id: id,
            type: type,
            name: name,
        };
    }
    function deserializeCollaborationAllowlistExemptTarget(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistExemptTarget"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "CollaborationAllowlistExemptTarget"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeCollaborationAllowlistExemptTargetTypeField(val.type);
        const enterprise = val.enterprise == void 0
            ? void 0
            : deserializeCollaborationAllowlistExemptTargetEnterpriseField(val.enterprise);
        const user = val.user == void 0 ? void 0 : deserializeUserMini(val.user);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "CollaborationAllowlistExemptTarget"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "CollaborationAllowlistExemptTarget"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        return {
            id: id,
            type: type,
            enterprise: enterprise,
            user: user,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
        };
    }

    function deserializeCollaborationAllowlistExemptTargets(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "CollaborationAllowlistExemptTargets"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "CollaborationAllowlistExemptTargets"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeCollaborationAllowlistExemptTarget(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class CreateCollaborationWhitelistExemptTargetOptionals {
        constructor(fields) {
            this.headers = new CreateCollaborationWhitelistExemptTargetHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistExemptTargetByIdOptionals {
        constructor(fields) {
            this.headers = new GetCollaborationWhitelistExemptTargetByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteCollaborationWhitelistExemptTargetByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteCollaborationWhitelistExemptTargetByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetCollaborationWhitelistExemptTargetsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateCollaborationWhitelistExemptTargetHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetCollaborationWhitelistExemptTargetByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteCollaborationWhitelistExemptTargetByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CollaborationAllowlistExemptTargetsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns a list of users who have been exempt from the collaboration
         * domain restrictions.
         * @param {GetCollaborationWhitelistExemptTargetsQueryParams} queryParams Query parameters of getCollaborationWhitelistExemptTargets method
         * @param {GetCollaborationWhitelistExemptTargetsHeadersInput} headersInput Headers of getCollaborationWhitelistExemptTargets method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<CollaborationAllowlistExemptTargets>}
         */
        getCollaborationWhitelistExemptTargets() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetCollaborationWhitelistExemptTargetsHeaders({}), cancellationToken) {
                const headers = new GetCollaborationWhitelistExemptTargetsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationAllowlistExemptTargets(response.data)), { rawData: response.data });
            });
        }
        /**
         * Exempts a user from the restrictions set out by the allowed list of domains
         * for collaborations.
         * @param {CreateCollaborationWhitelistExemptTargetRequestBody} requestBody Request body of createCollaborationWhitelistExemptTarget method
         * @param {CreateCollaborationWhitelistExemptTargetOptionalsInput} optionalsInput
         * @returns {Promise<CollaborationAllowlistExemptTarget>}
         */
        createCollaborationWhitelistExemptTarget(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateCollaborationWhitelistExemptTargetOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateCollaborationWhitelistExemptTargetRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationAllowlistExemptTarget(response.data)), { rawData: response.data });
            });
        }
        /**
           * Returns a users who has been exempt from the collaboration
           * domain restrictions.
           * @param {string} collaborationWhitelistExemptTargetId The ID of the exemption to the list.
          Example: "984923"
           * @param {GetCollaborationWhitelistExemptTargetByIdOptionalsInput} optionalsInput
           * @returns {Promise<CollaborationAllowlistExemptTarget>}
           */
        getCollaborationWhitelistExemptTargetById(collaborationWhitelistExemptTargetId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collaborationWhitelistExemptTargetId, optionalsInput = {}) {
                const optionals = new GetCollaborationWhitelistExemptTargetByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets/', toString(collaborationWhitelistExemptTargetId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeCollaborationAllowlistExemptTarget(response.data)), { rawData: response.data });
            });
        }
        /**
           * Removes a user's exemption from the restrictions set out by the allowed list
           * of domains for collaborations.
           * @param {string} collaborationWhitelistExemptTargetId The ID of the exemption to the list.
          Example: "984923"
           * @param {DeleteCollaborationWhitelistExemptTargetByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteCollaborationWhitelistExemptTargetById(collaborationWhitelistExemptTargetId_1) {
            return __awaiter$1(this, arguments, void 0, function* (collaborationWhitelistExemptTargetId, optionalsInput = {}) {
                const optionals = new DeleteCollaborationWhitelistExemptTargetByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/collaboration_whitelist_exempt_targets/', toString(collaborationWhitelistExemptTargetId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateCollaborationWhitelistExemptTargetRequestBodyUserField(val) {
        return { ['id']: val.id };
    }
    function serializeCreateCollaborationWhitelistExemptTargetRequestBody(val) {
        return {
            ['user']: serializeCreateCollaborationWhitelistExemptTargetRequestBodyUserField(val.user),
        };
    }

    function deserializeStoragePolicyMiniTypeField(val) {
        if (val == 'storage_policy') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StoragePolicyMiniTypeField",
        });
    }
    function deserializeStoragePolicyMini(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyMini"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StoragePolicyMini" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicyMini"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StoragePolicyMini" to be defined',
            });
        }
        const type = deserializeStoragePolicyMiniTypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeStoragePolicy(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "StoragePolicy"' });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "StoragePolicy"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StoragePolicy" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicy"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StoragePolicy" to be defined',
            });
        }
        const type = deserializeStoragePolicyMiniTypeField(val.type);
        return { name: name, id: id, type: type };
    }

    function deserializeStoragePolicies(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "StoragePolicies"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "StoragePolicies"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "StoragePolicies"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "StoragePolicies"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "StoragePolicies"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeStoragePolicy(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetStoragePolicyByIdOptionals {
        constructor(fields) {
            this.headers = new GetStoragePolicyByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetStoragePoliciesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetStoragePolicyByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class StoragePoliciesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Fetches all the storage policies in the enterprise.
         * @param {GetStoragePoliciesQueryParams} queryParams Query parameters of getStoragePolicies method
         * @param {GetStoragePoliciesHeadersInput} headersInput Headers of getStoragePolicies method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<StoragePolicies>}
         */
        getStoragePolicies() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetStoragePoliciesHeaders({}), cancellationToken) {
                const headers = new GetStoragePoliciesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policies'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeStoragePolicies(response.data)), { rawData: response.data });
            });
        }
        /**
           * Fetches a specific storage policy.
           * @param {string} storagePolicyId The ID of the storage policy.
          Example: "34342"
           * @param {GetStoragePolicyByIdOptionalsInput} optionalsInput
           * @returns {Promise<StoragePolicy>}
           */
        getStoragePolicyById(storagePolicyId_1) {
            return __awaiter$1(this, arguments, void 0, function* (storagePolicyId, optionalsInput = {}) {
                const optionals = new GetStoragePolicyByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policies/', toString(storagePolicyId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeStoragePolicy(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeStoragePolicyAssignmentTypeField(val) {
        if (val == 'storage_policy_assignment') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize StoragePolicyAssignmentTypeField",
        });
    }
    function deserializeStoragePolicyAssignmentAssignedToField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyAssignmentAssignedToField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicyAssignmentAssignedToField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "StoragePolicyAssignmentAssignedToField"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        return {
            id: id,
            type: type,
        };
    }
    function deserializeStoragePolicyAssignment(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyAssignment"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "StoragePolicyAssignment" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "StoragePolicyAssignment"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "StoragePolicyAssignment" to be defined',
            });
        }
        const type = deserializeStoragePolicyAssignmentTypeField(val.type);
        const storagePolicy = val.storage_policy == void 0
            ? void 0
            : deserializeStoragePolicyMini(val.storage_policy);
        const assignedTo = val.assigned_to == void 0
            ? void 0
            : deserializeStoragePolicyAssignmentAssignedToField(val.assigned_to);
        return {
            id: id,
            type: type,
            storagePolicy: storagePolicy,
            assignedTo: assignedTo,
        };
    }

    function deserializeStoragePolicyAssignments(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "StoragePolicyAssignments"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "StoragePolicyAssignments"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "StoragePolicyAssignments"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "StoragePolicyAssignments"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "StoragePolicyAssignments"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeStoragePolicyAssignment(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetStoragePolicyAssignmentsOptionals {
        constructor(fields) {
            this.headers = new GetStoragePolicyAssignmentsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateStoragePolicyAssignmentOptionals {
        constructor(fields) {
            this.headers = new CreateStoragePolicyAssignmentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetStoragePolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new GetStoragePolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateStoragePolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateStoragePolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteStoragePolicyAssignmentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteStoragePolicyAssignmentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetStoragePolicyAssignmentsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateStoragePolicyAssignmentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetStoragePolicyAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateStoragePolicyAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteStoragePolicyAssignmentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class StoragePolicyAssignmentsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Fetches all the storage policy assignment for an enterprise or user.
         * @param {GetStoragePolicyAssignmentsQueryParams} queryParams Query parameters of getStoragePolicyAssignments method
         * @param {GetStoragePolicyAssignmentsOptionalsInput} optionalsInput
         * @returns {Promise<StoragePolicyAssignments>}
         */
        getStoragePolicyAssignments(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetStoragePolicyAssignmentsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['resolved_for_type']: toString(queryParams.resolvedForType),
                    ['resolved_for_id']: toString(queryParams.resolvedForId),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeStoragePolicyAssignments(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a storage policy assignment for an enterprise or user.
         * @param {CreateStoragePolicyAssignmentRequestBody} requestBody Request body of createStoragePolicyAssignment method
         * @param {CreateStoragePolicyAssignmentOptionalsInput} optionalsInput
         * @returns {Promise<StoragePolicyAssignment>}
         */
        createStoragePolicyAssignment(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateStoragePolicyAssignmentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateStoragePolicyAssignmentRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeStoragePolicyAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Fetches a specific storage policy assignment.
           * @param {string} storagePolicyAssignmentId The ID of the storage policy assignment.
          Example: "932483"
           * @param {GetStoragePolicyAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<StoragePolicyAssignment>}
           */
        getStoragePolicyAssignmentById(storagePolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (storagePolicyAssignmentId, optionalsInput = {}) {
                const optionals = new GetStoragePolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments/', toString(storagePolicyAssignmentId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeStoragePolicyAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a specific storage policy assignment.
           * @param {string} storagePolicyAssignmentId The ID of the storage policy assignment.
          Example: "932483"
           * @param {UpdateStoragePolicyAssignmentByIdRequestBody} requestBody Request body of updateStoragePolicyAssignmentById method
           * @param {UpdateStoragePolicyAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<StoragePolicyAssignment>}
           */
        updateStoragePolicyAssignmentById(storagePolicyAssignmentId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (storagePolicyAssignmentId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateStoragePolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments/', toString(storagePolicyAssignmentId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateStoragePolicyAssignmentByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeStoragePolicyAssignment(response.data)), { rawData: response.data });
            });
        }
        /**
           * Delete a storage policy assignment.
           *
           * Deleting a storage policy assignment on a user
           * will have the user inherit the enterprise's default
           * storage policy.
           *
           * There is a rate limit for calling this endpoint of only
           * twice per user in a 24 hour time frame.
           * @param {string} storagePolicyAssignmentId The ID of the storage policy assignment.
          Example: "932483"
           * @param {DeleteStoragePolicyAssignmentByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteStoragePolicyAssignmentById(storagePolicyAssignmentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (storagePolicyAssignmentId, optionalsInput = {}) {
                const optionals = new DeleteStoragePolicyAssignmentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/storage_policy_assignments/', toString(storagePolicyAssignmentId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyTypeField(val) {
        return val;
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyField(val) {
        return {
            ['type']: serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyAssignedToTypeField(val) {
        return val;
    }
    function serializeCreateStoragePolicyAssignmentRequestBodyAssignedToField(val) {
        return {
            ['type']: serializeCreateStoragePolicyAssignmentRequestBodyAssignedToTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCreateStoragePolicyAssignmentRequestBody(val) {
        return {
            ['storage_policy']: serializeCreateStoragePolicyAssignmentRequestBodyStoragePolicyField(val.storagePolicy),
            ['assigned_to']: serializeCreateStoragePolicyAssignmentRequestBodyAssignedToField(val.assignedTo),
        };
    }
    function serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyTypeField(val) {
        return val;
    }
    function serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyField(val) {
        return {
            ['type']: serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeUpdateStoragePolicyAssignmentByIdRequestBody(val) {
        return {
            ['storage_policy']: serializeUpdateStoragePolicyAssignmentByIdRequestBodyStoragePolicyField(val.storagePolicy),
        };
    }

    function deserializeZipDownloadNameConflictsTypeField(val) {
        if (val == 'file') {
            return val;
        }
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ZipDownloadNameConflictsTypeField",
        });
    }
    function deserializeZipDownloadNameConflictsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ZipDownloadNameConflictsField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ZipDownloadNameConflictsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeZipDownloadNameConflictsTypeField(val.type);
        if (!(val.original_name == void 0) && !sdIsString(val.original_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "original_name" of type "ZipDownloadNameConflictsField"',
            });
        }
        const originalName = val.original_name == void 0 ? void 0 : val.original_name;
        if (!(val.download_name == void 0) && !sdIsString(val.download_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_name" of type "ZipDownloadNameConflictsField"',
            });
        }
        const downloadName = val.download_name == void 0 ? void 0 : val.download_name;
        return {
            id: id,
            type: type,
            originalName: originalName,
            downloadName: downloadName,
        };
    }
    function deserializeZipDownload(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "ZipDownload"' });
        }
        if (!(val.download_url == void 0) && !sdIsString(val.download_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "download_url" of type "ZipDownload"',
            });
        }
        const downloadUrl = val.download_url == void 0 ? void 0 : val.download_url;
        if (!(val.status_url == void 0) && !sdIsString(val.status_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "status_url" of type "ZipDownload"',
            });
        }
        const statusUrl = val.status_url == void 0 ? void 0 : val.status_url;
        if (!(val.expires_at == void 0) && !sdIsString(val.expires_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "expires_at" of type "ZipDownload"',
            });
        }
        const expiresAt = val.expires_at == void 0 ? void 0 : dateTimeFromString(val.expires_at);
        if (!(val.name_conflicts == void 0) && !sdIsList(val.name_conflicts)) {
            throw new BoxSdkError({
                message: 'Expecting array for "name_conflicts" of type "ZipDownload"',
            });
        }
        const nameConflicts = val.name_conflicts == void 0
            ? void 0
            : sdIsList(val.name_conflicts)
                ? val.name_conflicts.map(function (itm) {
                    return sdIsList(itm)
                        ? itm.map(function (itm) {
                            return deserializeZipDownloadNameConflictsField(itm);
                        })
                        : [];
                })
                : [];
        return {
            downloadUrl: downloadUrl,
            statusUrl: statusUrl,
            expiresAt: expiresAt,
            nameConflicts: nameConflicts,
        };
    }

    function serializeZipDownloadRequestItemsTypeField(val) {
        return val;
    }
    function serializeZipDownloadRequestItemsField(val) {
        return {
            ['type']: serializeZipDownloadRequestItemsTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeZipDownloadRequest(val) {
        return {
            ['items']: val.items.map(function (item) {
                return serializeZipDownloadRequestItemsField(item);
            }),
            ['download_file_name']: val.downloadFileName,
        };
    }

    function deserializeZipDownloadStatusStateField(val) {
        if (val == 'in_progress') {
            return val;
        }
        if (val == 'failed') {
            return val;
        }
        if (val == 'succeeded') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ZipDownloadStatusStateField",
        });
    }
    function deserializeZipDownloadStatus(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ZipDownloadStatus"',
            });
        }
        if (!(val.total_file_count == void 0) && !sdIsNumber(val.total_file_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "total_file_count" of type "ZipDownloadStatus"',
            });
        }
        const totalFileCount = val.total_file_count == void 0 ? void 0 : val.total_file_count;
        if (!(val.downloaded_file_count == void 0) &&
            !sdIsNumber(val.downloaded_file_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "downloaded_file_count" of type "ZipDownloadStatus"',
            });
        }
        const downloadedFileCount = val.downloaded_file_count == void 0 ? void 0 : val.downloaded_file_count;
        if (!(val.skipped_file_count == void 0) &&
            !sdIsNumber(val.skipped_file_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "skipped_file_count" of type "ZipDownloadStatus"',
            });
        }
        const skippedFileCount = val.skipped_file_count == void 0 ? void 0 : val.skipped_file_count;
        if (!(val.skipped_folder_count == void 0) &&
            !sdIsNumber(val.skipped_folder_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "skipped_folder_count" of type "ZipDownloadStatus"',
            });
        }
        const skippedFolderCount = val.skipped_folder_count == void 0 ? void 0 : val.skipped_folder_count;
        const state = val.state == void 0
            ? void 0
            : deserializeZipDownloadStatusStateField(val.state);
        return {
            totalFileCount: totalFileCount,
            downloadedFileCount: downloadedFileCount,
            skippedFileCount: skippedFileCount,
            skippedFolderCount: skippedFolderCount,
            state: state,
        };
    }

    class CreateZipDownloadOptionals {
        constructor(fields) {
            this.headers = new CreateZipDownloadHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetZipDownloadContentOptionals {
        constructor(fields) {
            this.headers = new GetZipDownloadContentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetZipDownloadStatusOptionals {
        constructor(fields) {
            this.headers = new GetZipDownloadStatusHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DownloadZipOptionals {
        constructor(fields) {
            this.headers = new DownloadZipHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateZipDownloadHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetZipDownloadContentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetZipDownloadStatusHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DownloadZipHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ZipDownloadsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Creates a request to download multiple files and folders as a single `zip`
         * archive file. This API does not return the archive but instead performs all
         * the checks to ensure that the user has access to all the items, and then
         * returns a `download_url` and a `status_url` that can be used to download the
         * archive.
         *
         * The limit for an archive is either the Account's upload limit or
         * 10,000 files, whichever is met first.
         *
         * **Note**: Downloading a large file can be
         * affected by various
         * factors such as distance, network latency,
         * bandwidth, and congestion, as well as packet loss
         * ratio and current server load.
         * For these reasons we recommend that a maximum ZIP archive
         * total size does not exceed 25GB.
         * @param {ZipDownloadRequest} requestBody Request body of createZipDownload method
         * @param {CreateZipDownloadOptionalsInput} optionalsInput
         * @returns {Promise<ZipDownload>}
         */
        createZipDownload(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateZipDownloadOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/zip_downloads'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeZipDownloadRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeZipDownload(response.data)), { rawData: response.data });
            });
        }
        /**
           * Returns the contents of a `zip` archive in binary format. This URL does not
           * require any form of authentication and could be used in a user's browser to
           * download the archive to a user's device.
           *
           * By default, this URL is only valid for a few seconds from the creation of
           * the request for this archive. Once a download has started it can not be
           * stopped and resumed, instead a new request for a zip archive would need to
           * be created.
           *
           * The URL of this endpoint should not be considered as fixed. Instead, use
           * the [Create zip download](e://post_zip_downloads) API to request to create a
           * `zip` archive, and then follow the `download_url` field in the response to
           * this endpoint.
           * @param {string} downloadUrl The URL that can be used to download created `zip` archive.
           Example: `https://dl.boxcloud.com/2.0/zip_downloads/29l00nfxDyHOt7RphI9zT_w==nDnZEDjY2S8iEWWCHEEiptFxwoWojjlibZjJ6geuE5xnXENDTPxzgbks_yY=/content`
           * @param {GetZipDownloadContentOptionalsInput} optionalsInput
           * @returns {Promise<ByteStream>}
           */
        getZipDownloadContent(downloadUrl_1) {
            return __awaiter$1(this, arguments, void 0, function* (downloadUrl, optionalsInput = {}) {
                const optionals = new GetZipDownloadContentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: downloadUrl,
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'binary',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return response.content;
            });
        }
        /**
           * Returns the download status of a `zip` archive, allowing an application to
           * inspect the progress of the download as well as the number of items that
           * might have been skipped.
           *
           * This endpoint can only be accessed once the download has started.
           * Subsequently this endpoint is valid for 12 hours from the start of the
           * download.
           *
           * The URL of this endpoint should not be considered as fixed. Instead, use
           * the [Create zip download](e://post_zip_downloads) API to request to create a
           * `zip` archive, and then follow the `status_url` field in the response to
           * this endpoint.
           * @param {string} statusUrl The URL that can be used to get the status of the `zip` archive being downloaded.
           Example: `https://dl.boxcloud.com/2.0/zip_downloads/29l00nfxDyHOt7RphI9zT_w==nDnZEDjY2S8iEWWCHEEiptFxwoWojjlibZjJ6geuE5xnXENDTPxzgbks_yY=/status`
           * @param {GetZipDownloadStatusOptionalsInput} optionalsInput
           * @returns {Promise<ZipDownloadStatus>}
           */
        getZipDownloadStatus(statusUrl_1) {
            return __awaiter$1(this, arguments, void 0, function* (statusUrl, optionalsInput = {}) {
                const optionals = new GetZipDownloadStatusOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: statusUrl,
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeZipDownloadStatus(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a zip and downloads its content
         * @param {ZipDownloadRequest} requestBody Zip download request body
         * @param {DownloadZipOptionalsInput} optionalsInput
         * @returns {Promise<ByteStream>}
         */
        downloadZip(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new DownloadZipOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const zipDownloadSession = yield this.createZipDownload({
                    items: requestBody.items,
                    downloadFileName: requestBody.downloadFileName,
                }, {
                    headers: new CreateZipDownloadHeaders({
                        extraHeaders: headers.extraHeaders,
                    }),
                    cancellationToken: cancellationToken,
                });
                return yield this.getZipDownloadContent(zipDownloadSession.downloadUrl, {
                    headers: new GetZipDownloadContentHeaders({
                        extraHeaders: headers.extraHeaders,
                    }),
                    cancellationToken: cancellationToken,
                });
            });
        }
    }

    function serializeSignRequestPrefillTag(val) {
        return {
            ['document_tag_id']: val.documentTagId,
            ['text_value']: val.textValue,
            ['checkbox_value']: val.checkboxValue,
            ['date_value']: val.dateValue == void 0 ? val.dateValue : dateToString(val.dateValue),
        };
    }
    function deserializeSignRequestPrefillTag(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestPrefillTag"',
            });
        }
        if (!(val.document_tag_id == void 0) && !sdIsString(val.document_tag_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_tag_id" of type "SignRequestPrefillTag"',
            });
        }
        const documentTagId = val.document_tag_id == void 0 ? void 0 : val.document_tag_id;
        if (!(val.text_value == void 0) && !sdIsString(val.text_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text_value" of type "SignRequestPrefillTag"',
            });
        }
        const textValue = val.text_value == void 0 ? void 0 : val.text_value;
        if (!(val.checkbox_value == void 0) && !sdIsBoolean(val.checkbox_value)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "checkbox_value" of type "SignRequestPrefillTag"',
            });
        }
        const checkboxValue = val.checkbox_value == void 0 ? void 0 : val.checkbox_value;
        if (!(val.date_value == void 0) && !sdIsString(val.date_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "date_value" of type "SignRequestPrefillTag"',
            });
        }
        const dateValue = val.date_value == void 0 ? void 0 : dateFromString(val.date_value);
        return {
            documentTagId: documentTagId,
            textValue: textValue,
            checkboxValue: checkboxValue,
            dateValue: dateValue,
        };
    }

    function serializeSignRequestBase(val) {
        return {
            ['is_document_preparation_needed']: val.isDocumentPreparationNeeded,
            ['redirect_url']: val.redirectUrl,
            ['declined_redirect_url']: val.declinedRedirectUrl,
            ['are_text_signatures_enabled']: val.areTextSignaturesEnabled,
            ['email_subject']: val.emailSubject,
            ['email_message']: val.emailMessage,
            ['are_reminders_enabled']: val.areRemindersEnabled,
            ['name']: val.name,
            ['prefill_tags']: val.prefillTags == void 0
                ? val.prefillTags
                : val.prefillTags.map(function (item) {
                    return serializeSignRequestPrefillTag(item);
                }),
            ['days_valid']: val.daysValid,
            ['external_id']: val.externalId,
            ['template_id']: val.templateId,
            ['external_system_name']: val.externalSystemName,
        };
    }

    function serializeSignRequestCreateSignerRoleField(val) {
        return val;
    }
    function deserializeSignRequestCreateSignerRoleField(val) {
        if (val == 'signer') {
            return val;
        }
        if (val == 'approver') {
            return val;
        }
        if (val == 'final_copy_reader') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestCreateSignerRoleField",
        });
    }
    function serializeSignRequestCreateSigner(val) {
        return {
            ['email']: val.email,
            ['role']: val.role == void 0
                ? val.role
                : serializeSignRequestCreateSignerRoleField(val.role),
            ['is_in_person']: val.isInPerson,
            ['order']: val.order,
            ['embed_url_external_user_id']: val.embedUrlExternalUserId,
            ['redirect_url']: val.redirectUrl,
            ['declined_redirect_url']: val.declinedRedirectUrl,
            ['login_required']: val.loginRequired,
            ['verification_phone_number']: val.verificationPhoneNumber,
            ['password']: val.password,
            ['signer_group_id']: val.signerGroupId,
            ['suppress_notifications']: val.suppressNotifications,
        };
    }

    function deserializeSignRequestSignerInputTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestSignerInputTypeField",
        });
    }
    function deserializeSignRequestSignerInputContentTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'initial') {
            return val;
        }
        if (val == 'stamp') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'full_name') {
            return val;
        }
        if (val == 'first_name') {
            return val;
        }
        if (val == 'last_name') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'title') {
            return val;
        }
        if (val == 'email') {
            return val;
        }
        if (val == 'attachment') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestSignerInputContentTypeField",
        });
    }
    function deserializeSignRequestSignerInput(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSignerInput"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeSignRequestSignerInputTypeField(val.type);
        const contentType = val.content_type == void 0
            ? void 0
            : deserializeSignRequestSignerInputContentTypeField(val.content_type);
        if (val.page_index == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "page_index" of type "SignRequestSignerInput" to be defined',
            });
        }
        if (!sdIsNumber(val.page_index)) {
            throw new BoxSdkError({
                message: 'Expecting number for "page_index" of type "SignRequestSignerInput"',
            });
        }
        const pageIndex = val.page_index;
        if (!(val.read_only == void 0) && !sdIsBoolean(val.read_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "read_only" of type "SignRequestSignerInput"',
            });
        }
        const readOnly = val.read_only == void 0 ? void 0 : val.read_only;
        if (!(val.document_tag_id == void 0) && !sdIsString(val.document_tag_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_tag_id" of type "SignRequestSignerInput"',
            });
        }
        const documentTagId = val.document_tag_id == void 0 ? void 0 : val.document_tag_id;
        if (!(val.text_value == void 0) && !sdIsString(val.text_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text_value" of type "SignRequestSignerInput"',
            });
        }
        const textValue = val.text_value == void 0 ? void 0 : val.text_value;
        if (!(val.checkbox_value == void 0) && !sdIsBoolean(val.checkbox_value)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "checkbox_value" of type "SignRequestSignerInput"',
            });
        }
        const checkboxValue = val.checkbox_value == void 0 ? void 0 : val.checkbox_value;
        if (!(val.date_value == void 0) && !sdIsString(val.date_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "date_value" of type "SignRequestSignerInput"',
            });
        }
        const dateValue = val.date_value == void 0 ? void 0 : dateFromString(val.date_value);
        return {
            type: type,
            contentType: contentType,
            pageIndex: pageIndex,
            readOnly: readOnly,
            documentTagId: documentTagId,
            textValue: textValue,
            checkboxValue: checkboxValue,
            dateValue: dateValue,
        };
    }

    function deserializeSignRequestSignerSignerDecisionTypeField(val) {
        if (val == 'signed') {
            return val;
        }
        if (val == 'declined') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestSignerSignerDecisionTypeField",
        });
    }
    function deserializeSignRequestSignerSignerDecisionField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSignerSignerDecisionField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeSignRequestSignerSignerDecisionTypeField(val.type);
        if (!(val.finalized_at == void 0) && !sdIsString(val.finalized_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "finalized_at" of type "SignRequestSignerSignerDecisionField"',
            });
        }
        const finalizedAt = val.finalized_at == void 0 ? void 0 : dateTimeFromString(val.finalized_at);
        if (!(val.additional_info == void 0) && !sdIsString(val.additional_info)) {
            throw new BoxSdkError({
                message: 'Expecting string for "additional_info" of type "SignRequestSignerSignerDecisionField"',
            });
        }
        const additionalInfo = val.additional_info == void 0 ? void 0 : val.additional_info;
        return {
            type: type,
            finalizedAt: finalizedAt,
            additionalInfo: additionalInfo,
        };
    }
    function deserializeSignRequestSigner(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSigner"',
            });
        }
        if (!(val.has_viewed_document == void 0) &&
            !sdIsBoolean(val.has_viewed_document)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "has_viewed_document" of type "SignRequestSigner"',
            });
        }
        const hasViewedDocument = val.has_viewed_document == void 0 ? void 0 : val.has_viewed_document;
        const signerDecision = val.signer_decision == void 0
            ? void 0
            : deserializeSignRequestSignerSignerDecisionField(val.signer_decision);
        if (!(val.inputs == void 0) && !sdIsList(val.inputs)) {
            throw new BoxSdkError({
                message: 'Expecting array for "inputs" of type "SignRequestSigner"',
            });
        }
        const inputs = val.inputs == void 0
            ? void 0
            : sdIsList(val.inputs)
                ? val.inputs.map(function (itm) {
                    return deserializeSignRequestSignerInput(itm);
                })
                : [];
        if (!(val.embed_url == void 0) && !sdIsString(val.embed_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "embed_url" of type "SignRequestSigner"',
            });
        }
        const embedUrl = val.embed_url == void 0 ? void 0 : val.embed_url;
        if (!(val.iframeable_embed_url == void 0) &&
            !sdIsString(val.iframeable_embed_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "iframeable_embed_url" of type "SignRequestSigner"',
            });
        }
        const iframeableEmbedUrl = val.iframeable_embed_url == void 0 ? void 0 : val.iframeable_embed_url;
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "SignRequestSigner"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        const role = val.role == void 0
            ? void 0
            : deserializeSignRequestCreateSignerRoleField(val.role);
        if (!(val.is_in_person == void 0) && !sdIsBoolean(val.is_in_person)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_in_person" of type "SignRequestSigner"',
            });
        }
        const isInPerson = val.is_in_person == void 0 ? void 0 : val.is_in_person;
        if (!(val.order == void 0) && !sdIsNumber(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting number for "order" of type "SignRequestSigner"',
            });
        }
        const order = val.order == void 0 ? void 0 : val.order;
        if (!(val.embed_url_external_user_id == void 0) &&
            !sdIsString(val.embed_url_external_user_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "embed_url_external_user_id" of type "SignRequestSigner"',
            });
        }
        const embedUrlExternalUserId = val.embed_url_external_user_id == void 0
            ? void 0
            : val.embed_url_external_user_id;
        if (!(val.redirect_url == void 0) && !sdIsString(val.redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "redirect_url" of type "SignRequestSigner"',
            });
        }
        const redirectUrl = val.redirect_url == void 0 ? void 0 : val.redirect_url;
        if (!(val.declined_redirect_url == void 0) &&
            !sdIsString(val.declined_redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "declined_redirect_url" of type "SignRequestSigner"',
            });
        }
        const declinedRedirectUrl = val.declined_redirect_url == void 0 ? void 0 : val.declined_redirect_url;
        if (!(val.login_required == void 0) && !sdIsBoolean(val.login_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "login_required" of type "SignRequestSigner"',
            });
        }
        const loginRequired = val.login_required == void 0 ? void 0 : val.login_required;
        if (!(val.verification_phone_number == void 0) &&
            !sdIsString(val.verification_phone_number)) {
            throw new BoxSdkError({
                message: 'Expecting string for "verification_phone_number" of type "SignRequestSigner"',
            });
        }
        const verificationPhoneNumber = val.verification_phone_number == void 0
            ? void 0
            : val.verification_phone_number;
        if (!(val.password == void 0) && !sdIsString(val.password)) {
            throw new BoxSdkError({
                message: 'Expecting string for "password" of type "SignRequestSigner"',
            });
        }
        const password = val.password == void 0 ? void 0 : val.password;
        if (!(val.signer_group_id == void 0) && !sdIsString(val.signer_group_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "signer_group_id" of type "SignRequestSigner"',
            });
        }
        const signerGroupId = val.signer_group_id == void 0 ? void 0 : val.signer_group_id;
        if (!(val.suppress_notifications == void 0) &&
            !sdIsBoolean(val.suppress_notifications)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "suppress_notifications" of type "SignRequestSigner"',
            });
        }
        const suppressNotifications = val.suppress_notifications == void 0 ? void 0 : val.suppress_notifications;
        return {
            hasViewedDocument: hasViewedDocument,
            signerDecision: signerDecision,
            inputs: inputs,
            embedUrl: embedUrl,
            iframeableEmbedUrl: iframeableEmbedUrl,
            email: email,
            role: role,
            isInPerson: isInPerson,
            order: order,
            embedUrlExternalUserId: embedUrlExternalUserId,
            redirectUrl: redirectUrl,
            declinedRedirectUrl: declinedRedirectUrl,
            loginRequired: loginRequired,
            verificationPhoneNumber: verificationPhoneNumber,
            password: password,
            signerGroupId: signerGroupId,
            suppressNotifications: suppressNotifications,
        };
    }

    function deserializeSignRequestTypeField(val) {
        if (val == 'sign-request') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize SignRequestTypeField" });
    }
    function deserializeSignRequestStatusField(val) {
        if (val == 'converting') {
            return val;
        }
        if (val == 'created') {
            return val;
        }
        if (val == 'sent') {
            return val;
        }
        if (val == 'viewed') {
            return val;
        }
        if (val == 'signed') {
            return val;
        }
        if (val == 'cancelled') {
            return val;
        }
        if (val == 'declined') {
            return val;
        }
        if (val == 'error_converting') {
            return val;
        }
        if (val == 'error_sending') {
            return val;
        }
        if (val == 'expired') {
            return val;
        }
        if (val == 'finalizing') {
            return val;
        }
        if (val == 'error_finalizing') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignRequestStatusField",
        });
    }
    function deserializeSignRequestSignFilesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestSignFilesField"',
            });
        }
        if (!(val.files == void 0) && !sdIsList(val.files)) {
            throw new BoxSdkError({
                message: 'Expecting array for "files" of type "SignRequestSignFilesField"',
            });
        }
        const files = val.files == void 0
            ? void 0
            : sdIsList(val.files)
                ? val.files.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        if (!(val.is_ready_for_download == void 0) &&
            !sdIsBoolean(val.is_ready_for_download)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_ready_for_download" of type "SignRequestSignFilesField"',
            });
        }
        const isReadyForDownload = val.is_ready_for_download == void 0 ? void 0 : val.is_ready_for_download;
        return {
            files: files,
            isReadyForDownload: isReadyForDownload,
        };
    }
    function deserializeSignRequest(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignRequest"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeSignRequestTypeField(val.type);
        if (!(val.source_files == void 0) && !sdIsList(val.source_files)) {
            throw new BoxSdkError({
                message: 'Expecting array for "source_files" of type "SignRequest"',
            });
        }
        const sourceFiles = val.source_files == void 0
            ? void 0
            : sdIsList(val.source_files)
                ? val.source_files.map(function (itm) {
                    return deserializeFileBase(itm);
                })
                : [];
        if (!(val.signers == void 0) && !sdIsList(val.signers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "signers" of type "SignRequest"',
            });
        }
        const signers = val.signers == void 0
            ? void 0
            : sdIsList(val.signers)
                ? val.signers.map(function (itm) {
                    return deserializeSignRequestSigner(itm);
                })
                : [];
        if (!(val.signature_color == void 0) && !sdIsString(val.signature_color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "signature_color" of type "SignRequest"',
            });
        }
        const signatureColor = val.signature_color == void 0 ? void 0 : val.signature_color;
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "SignRequest"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.prepare_url == void 0) && !sdIsString(val.prepare_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prepare_url" of type "SignRequest"',
            });
        }
        const prepareUrl = val.prepare_url == void 0 ? void 0 : val.prepare_url;
        const signingLog = val.signing_log == void 0 ? void 0 : deserializeFileMini(val.signing_log);
        const status = val.status == void 0
            ? void 0
            : deserializeSignRequestStatusField(val.status);
        const signFiles = val.sign_files == void 0
            ? void 0
            : deserializeSignRequestSignFilesField(val.sign_files);
        if (!(val.auto_expire_at == void 0) && !sdIsString(val.auto_expire_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "auto_expire_at" of type "SignRequest"',
            });
        }
        const autoExpireAt = val.auto_expire_at == void 0
            ? void 0
            : dateTimeFromString(val.auto_expire_at);
        const parentFolder = val.parent_folder == void 0
            ? void 0
            : deserializeFolderMini(val.parent_folder);
        if (!(val.collaborator_level == void 0) &&
            !sdIsString(val.collaborator_level)) {
            throw new BoxSdkError({
                message: 'Expecting string for "collaborator_level" of type "SignRequest"',
            });
        }
        const collaboratorLevel = val.collaborator_level == void 0 ? void 0 : val.collaborator_level;
        if (!(val.sender_email == void 0) && !sdIsString(val.sender_email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "sender_email" of type "SignRequest"',
            });
        }
        const senderEmail = val.sender_email == void 0 ? void 0 : val.sender_email;
        if (!(val.sender_id == void 0) && !sdIsNumber(val.sender_id)) {
            throw new BoxSdkError({
                message: 'Expecting number for "sender_id" of type "SignRequest"',
            });
        }
        const senderId = val.sender_id == void 0 ? void 0 : val.sender_id;
        if (!(val.is_document_preparation_needed == void 0) &&
            !sdIsBoolean(val.is_document_preparation_needed)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_document_preparation_needed" of type "SignRequest"',
            });
        }
        const isDocumentPreparationNeeded = val.is_document_preparation_needed == void 0
            ? void 0
            : val.is_document_preparation_needed;
        if (!(val.redirect_url == void 0) && !sdIsString(val.redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "redirect_url" of type "SignRequest"',
            });
        }
        const redirectUrl = val.redirect_url == void 0 ? void 0 : val.redirect_url;
        if (!(val.declined_redirect_url == void 0) &&
            !sdIsString(val.declined_redirect_url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "declined_redirect_url" of type "SignRequest"',
            });
        }
        const declinedRedirectUrl = val.declined_redirect_url == void 0 ? void 0 : val.declined_redirect_url;
        if (!(val.are_text_signatures_enabled == void 0) &&
            !sdIsBoolean(val.are_text_signatures_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_text_signatures_enabled" of type "SignRequest"',
            });
        }
        const areTextSignaturesEnabled = val.are_text_signatures_enabled == void 0
            ? void 0
            : val.are_text_signatures_enabled;
        if (!(val.email_subject == void 0) && !sdIsString(val.email_subject)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_subject" of type "SignRequest"',
            });
        }
        const emailSubject = val.email_subject == void 0 ? void 0 : val.email_subject;
        if (!(val.email_message == void 0) && !sdIsString(val.email_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_message" of type "SignRequest"',
            });
        }
        const emailMessage = val.email_message == void 0 ? void 0 : val.email_message;
        if (!(val.are_reminders_enabled == void 0) &&
            !sdIsBoolean(val.are_reminders_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_reminders_enabled" of type "SignRequest"',
            });
        }
        const areRemindersEnabled = val.are_reminders_enabled == void 0 ? void 0 : val.are_reminders_enabled;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "SignRequest"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.prefill_tags == void 0) && !sdIsList(val.prefill_tags)) {
            throw new BoxSdkError({
                message: 'Expecting array for "prefill_tags" of type "SignRequest"',
            });
        }
        const prefillTags = val.prefill_tags == void 0
            ? void 0
            : sdIsList(val.prefill_tags)
                ? val.prefill_tags.map(function (itm) {
                    return deserializeSignRequestPrefillTag(itm);
                })
                : [];
        if (!(val.days_valid == void 0) && !sdIsNumber(val.days_valid)) {
            throw new BoxSdkError({
                message: 'Expecting number for "days_valid" of type "SignRequest"',
            });
        }
        const daysValid = val.days_valid == void 0 ? void 0 : val.days_valid;
        if (!(val.external_id == void 0) && !sdIsString(val.external_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_id" of type "SignRequest"',
            });
        }
        const externalId = val.external_id == void 0 ? void 0 : val.external_id;
        if (!(val.template_id == void 0) && !sdIsString(val.template_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "template_id" of type "SignRequest"',
            });
        }
        const templateId = val.template_id == void 0 ? void 0 : val.template_id;
        if (!(val.external_system_name == void 0) &&
            !sdIsString(val.external_system_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "external_system_name" of type "SignRequest"',
            });
        }
        const externalSystemName = val.external_system_name == void 0 ? void 0 : val.external_system_name;
        return {
            type: type,
            sourceFiles: sourceFiles,
            signers: signers,
            signatureColor: signatureColor,
            id: id,
            prepareUrl: prepareUrl,
            signingLog: signingLog,
            status: status,
            signFiles: signFiles,
            autoExpireAt: autoExpireAt,
            parentFolder: parentFolder,
            collaboratorLevel: collaboratorLevel,
            senderEmail: senderEmail,
            senderId: senderId,
            isDocumentPreparationNeeded: isDocumentPreparationNeeded,
            redirectUrl: redirectUrl,
            declinedRedirectUrl: declinedRedirectUrl,
            areTextSignaturesEnabled: areTextSignaturesEnabled,
            emailSubject: emailSubject,
            emailMessage: emailMessage,
            areRemindersEnabled: areRemindersEnabled,
            name: name,
            prefillTags: prefillTags,
            daysValid: daysValid,
            externalId: externalId,
            templateId: templateId,
            externalSystemName: externalSystemName,
        };
    }

    function deserializeSignRequests(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignRequests"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SignRequests"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "SignRequests"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SignRequests"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeSignRequest(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    function serializeSignRequestCreateRequestSignatureColorField(val) {
        return val;
    }
    function serializeSignRequestCreateRequest(val) {
        const base = serializeSignRequestBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignRequestCreateRequest"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['source_files']: val.sourceFiles == void 0
                ? val.sourceFiles
                : val.sourceFiles.map(function (item) {
                    return serializeFileBase(item);
                }),
            ['signature_color']: val.signatureColor == void 0
                ? val.signatureColor
                : serializeSignRequestCreateRequestSignatureColorField(val.signatureColor),
            ['signers']: val.signers.map(function (item) {
                return serializeSignRequestCreateSigner(item);
            }),
            ['parent_folder']: val.parentFolder == void 0
                ? val.parentFolder
                : serializeFolderMini(val.parentFolder),
        });
    }

    class CancelSignRequestOptionals {
        constructor(fields) {
            this.headers = new CancelSignRequestHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class ResendSignRequestOptionals {
        constructor(fields) {
            this.headers = new ResendSignRequestHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSignRequestByIdOptionals {
        constructor(fields) {
            this.headers = new GetSignRequestByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateSignRequestOptionals {
        constructor(fields) {
            this.headers = new CreateSignRequestHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CancelSignRequestHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ResendSignRequestHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSignRequestByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSignRequestsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateSignRequestHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SignRequestsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Cancels a sign request.
           * @param {string} signRequestId The ID of the signature request.
          Example: "33243242"
           * @param {CancelSignRequestOptionalsInput} optionalsInput
           * @returns {Promise<SignRequest>}
           */
        cancelSignRequest(signRequestId_1) {
            return __awaiter$1(this, arguments, void 0, function* (signRequestId, optionalsInput = {}) {
                const optionals = new CancelSignRequestOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests/', toString(signRequestId), '/cancel'),
                    method: 'POST',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSignRequest(response.data)), { rawData: response.data });
            });
        }
        /**
           * Resends a signature request email to all outstanding signers.
           * @param {string} signRequestId The ID of the signature request.
          Example: "33243242"
           * @param {ResendSignRequestOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        resendSignRequest(signRequestId_1) {
            return __awaiter$1(this, arguments, void 0, function* (signRequestId, optionalsInput = {}) {
                const optionals = new ResendSignRequestOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests/', toString(signRequestId), '/resend'),
                    method: 'POST',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Gets a sign request by ID.
           * @param {string} signRequestId The ID of the signature request.
          Example: "33243242"
           * @param {GetSignRequestByIdOptionalsInput} optionalsInput
           * @returns {Promise<SignRequest>}
           */
        getSignRequestById(signRequestId_1) {
            return __awaiter$1(this, arguments, void 0, function* (signRequestId, optionalsInput = {}) {
                const optionals = new GetSignRequestByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests/', toString(signRequestId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSignRequest(response.data)), { rawData: response.data });
            });
        }
        /**
         * Gets signature requests created by a user. If the `sign_files` and/or
         * `parent_folder` are deleted, the signature request will not return in the list.
         * @param {GetSignRequestsQueryParams} queryParams Query parameters of getSignRequests method
         * @param {GetSignRequestsHeadersInput} headersInput Headers of getSignRequests method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<SignRequests>}
         */
        getSignRequests() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetSignRequestsHeaders({}), cancellationToken) {
                const headers = new GetSignRequestsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['senders']: queryParams.senders
                        ? queryParams.senders.map(toString).join(',')
                        : undefined,
                    ['shared_requests']: toString(queryParams.sharedRequests),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSignRequests(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a signature request. This involves preparing a document for signing and
         * sending the signature request to signers.
         * @param {SignRequestCreateRequest} requestBody Request body of createSignRequest method
         * @param {CreateSignRequestOptionalsInput} optionalsInput
         * @returns {Promise<SignRequest>}
         */
        createSignRequest(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateSignRequestOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_requests'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeSignRequestCreateRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSignRequest(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeWorkflowMiniTypeField(val) {
        if (val == 'workflow') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize WorkflowMiniTypeField" });
    }

    function deserializeWorkflowFlowsTypeField(val) {
        if (val == 'flow') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerTypeField(val) {
        if (val == 'trigger') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerTriggerTypeField(val) {
        if (val == 'WORKFLOW_MANUAL_START') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerTriggerTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerScopeTypeField(val) {
        if (val == 'trigger_scope') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerScopeTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerScopeObjectTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsTriggerScopeObjectTypeField",
        });
    }
    function deserializeWorkflowFlowsTriggerScopeObjectField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsTriggerScopeObjectField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerScopeObjectTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsTriggerScopeObjectField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return { type: type, id: id };
    }
    function deserializeWorkflowFlowsTriggerScopeField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsTriggerScopeField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerScopeTypeField(val.type);
        if (!(val.ref == void 0) && !sdIsString(val.ref)) {
            throw new BoxSdkError({
                message: 'Expecting string for "ref" of type "WorkflowFlowsTriggerScopeField"',
            });
        }
        const ref = val.ref == void 0 ? void 0 : val.ref;
        const object = val.object == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerScopeObjectField(val.object);
        return {
            type: type,
            ref: ref,
            object: object,
        };
    }
    function deserializeWorkflowFlowsTriggerField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsTriggerField"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerTypeField(val.type);
        const triggerType = val.trigger_type == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerTriggerTypeField(val.trigger_type);
        if (!(val.scope == void 0) && !sdIsList(val.scope)) {
            throw new BoxSdkError({
                message: 'Expecting array for "scope" of type "WorkflowFlowsTriggerField"',
            });
        }
        const scope = val.scope == void 0
            ? void 0
            : sdIsList(val.scope)
                ? val.scope.map(function (itm) {
                    return deserializeWorkflowFlowsTriggerScopeField(itm);
                })
                : [];
        return {
            type: type,
            triggerType: triggerType,
            scope: scope,
        };
    }
    function deserializeWorkflowFlowsOutcomesTypeField(val) {
        if (val == 'outcome') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesActionTypeField(val) {
        if (val == 'add_metadata') {
            return val;
        }
        if (val == 'assign_task') {
            return val;
        }
        if (val == 'copy_file') {
            return val;
        }
        if (val == 'copy_folder') {
            return val;
        }
        if (val == 'create_folder') {
            return val;
        }
        if (val == 'delete_file') {
            return val;
        }
        if (val == 'delete_folder') {
            return val;
        }
        if (val == 'lock_file') {
            return val;
        }
        if (val == 'move_file') {
            return val;
        }
        if (val == 'move_folder') {
            return val;
        }
        if (val == 'remove_watermark_file') {
            return val;
        }
        if (val == 'rename_folder') {
            return val;
        }
        if (val == 'restore_folder') {
            return val;
        }
        if (val == 'share_file') {
            return val;
        }
        if (val == 'share_folder') {
            return val;
        }
        if (val == 'unlock_file') {
            return val;
        }
        if (val == 'upload_file') {
            return val;
        }
        if (val == 'wait_for_task') {
            return val;
        }
        if (val == 'watermark_file') {
            return val;
        }
        if (val == 'go_back_to_step') {
            return val;
        }
        if (val == 'apply_file_classification') {
            return val;
        }
        if (val == 'apply_folder_classification') {
            return val;
        }
        if (val == 'send_notification') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesActionTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesIfRejectedTypeField(val) {
        if (val == 'outcome') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesIfRejectedTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesIfRejectedActionTypeField(val) {
        if (val == 'add_metadata') {
            return val;
        }
        if (val == 'assign_task') {
            return val;
        }
        if (val == 'copy_file') {
            return val;
        }
        if (val == 'copy_folder') {
            return val;
        }
        if (val == 'create_folder') {
            return val;
        }
        if (val == 'delete_file') {
            return val;
        }
        if (val == 'delete_folder') {
            return val;
        }
        if (val == 'lock_file') {
            return val;
        }
        if (val == 'move_file') {
            return val;
        }
        if (val == 'move_folder') {
            return val;
        }
        if (val == 'remove_watermark_file') {
            return val;
        }
        if (val == 'rename_folder') {
            return val;
        }
        if (val == 'restore_folder') {
            return val;
        }
        if (val == 'share_file') {
            return val;
        }
        if (val == 'share_folder') {
            return val;
        }
        if (val == 'unlock_file') {
            return val;
        }
        if (val == 'upload_file') {
            return val;
        }
        if (val == 'wait_for_task') {
            return val;
        }
        if (val == 'watermark_file') {
            return val;
        }
        if (val == 'go_back_to_step') {
            return val;
        }
        if (val == 'apply_file_classification') {
            return val;
        }
        if (val == 'apply_folder_classification') {
            return val;
        }
        if (val == 'send_notification') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WorkflowFlowsOutcomesIfRejectedActionTypeField",
        });
    }
    function deserializeWorkflowFlowsOutcomesIfRejectedField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsOutcomesIfRejectedField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsOutcomesIfRejectedField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesIfRejectedTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "WorkflowFlowsOutcomesIfRejectedField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const actionType = val.action_type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesIfRejectedActionTypeField(val.action_type);
        return {
            id: id,
            type: type,
            name: name,
            actionType: actionType,
        };
    }
    function deserializeWorkflowFlowsOutcomesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsOutcomesField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsOutcomesField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "WorkflowFlowsOutcomesField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const actionType = val.action_type == void 0
            ? void 0
            : deserializeWorkflowFlowsOutcomesActionTypeField(val.action_type);
        if (!(val.if_rejected == void 0) && !sdIsList(val.if_rejected)) {
            throw new BoxSdkError({
                message: 'Expecting array for "if_rejected" of type "WorkflowFlowsOutcomesField"',
            });
        }
        const ifRejected = val.if_rejected == void 0
            ? void 0
            : sdIsList(val.if_rejected)
                ? val.if_rejected.map(function (itm) {
                    return deserializeWorkflowFlowsOutcomesIfRejectedField(itm);
                })
                : [];
        return {
            id: id,
            type: type,
            name: name,
            actionType: actionType,
            ifRejected: ifRejected,
        };
    }
    function deserializeWorkflowFlowsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WorkflowFlowsField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WorkflowFlowsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWorkflowFlowsTypeField(val.type);
        const trigger = val.trigger == void 0
            ? void 0
            : deserializeWorkflowFlowsTriggerField(val.trigger);
        if (!(val.outcomes == void 0) && !sdIsList(val.outcomes)) {
            throw new BoxSdkError({
                message: 'Expecting array for "outcomes" of type "WorkflowFlowsField"',
            });
        }
        const outcomes = val.outcomes == void 0
            ? void 0
            : sdIsList(val.outcomes)
                ? val.outcomes.map(function (itm) {
                    return deserializeWorkflowFlowsOutcomesField(itm);
                })
                : [];
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "WorkflowFlowsField"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        return {
            id: id,
            type: type,
            trigger: trigger,
            outcomes: outcomes,
            createdAt: createdAt,
            createdBy: createdBy,
        };
    }
    function deserializeWorkflow(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Workflow"' });
        }
        if (!(val.flows == void 0) && !sdIsList(val.flows)) {
            throw new BoxSdkError({
                message: 'Expecting array for "flows" of type "Workflow"',
            });
        }
        const flows = val.flows == void 0
            ? void 0
            : sdIsList(val.flows)
                ? val.flows.map(function (itm) {
                    return deserializeWorkflowFlowsField(itm);
                })
                : [];
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "Workflow"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeWorkflowMiniTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "Workflow"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "Workflow"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.is_enabled == void 0) && !sdIsBoolean(val.is_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_enabled" of type "Workflow"',
            });
        }
        const isEnabled = val.is_enabled == void 0 ? void 0 : val.is_enabled;
        return {
            flows: flows,
            id: id,
            type: type,
            name: name,
            description: description,
            isEnabled: isEnabled,
        };
    }

    function deserializeWorkflows(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "Workflows"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "Workflows"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "Workflows"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "Workflows"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "Workflows"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeWorkflow(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function serializeCollaboratorVariableTypeField(val) {
        return val;
    }
    function serializeCollaboratorVariableVariableTypeField(val) {
        return val;
    }
    function serializeCollaboratorVariableVariableValueTypeField(val) {
        return val;
    }
    function serializeCollaboratorVariableVariableValueField(val) {
        return {
            ['type']: serializeCollaboratorVariableVariableValueTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeCollaboratorVariable(val) {
        return {
            ['type']: serializeCollaboratorVariableTypeField(val.type),
            ['variable_type']: serializeCollaboratorVariableVariableTypeField(val.variableType),
            ['variable_value']: val.variableValue.map(function (item) {
                return serializeCollaboratorVariableVariableValueField(item);
            }),
        };
    }

    function serializeCompletionRuleVariableTypeField(val) {
        return val;
    }
    function serializeCompletionRuleVariableVariableTypeField(val) {
        return val;
    }
    function serializeCompletionRuleVariableVariableValueField(val) {
        return val;
    }
    function serializeCompletionRuleVariable(val) {
        return {
            ['type']: serializeCompletionRuleVariableTypeField(val.type),
            ['variable_type']: serializeCompletionRuleVariableVariableTypeField(val.variableType),
            ['variable_value']: serializeCompletionRuleVariableVariableValueField(val.variableValue),
        };
    }

    function serializeRoleVariableTypeField(val) {
        return val;
    }
    function serializeRoleVariableVariableTypeField(val) {
        return val;
    }
    function serializeRoleVariableVariableValueField(val) {
        return val;
    }
    function serializeRoleVariable(val) {
        return {
            ['type']: serializeRoleVariableTypeField(val.type),
            ['variable_type']: serializeRoleVariableVariableTypeField(val.variableType),
            ['variable_value']: serializeRoleVariableVariableValueField(val.variableValue),
        };
    }

    function serializeOutcome(val) {
        return {
            ['id']: val.id,
            ['collaborators']: val.collaborators == void 0
                ? val.collaborators
                : serializeCollaboratorVariable(val.collaborators),
            ['completion_rule']: val.completionRule == void 0
                ? val.completionRule
                : serializeCompletionRuleVariable(val.completionRule),
            ['file_collaborator_role']: val.fileCollaboratorRole == void 0
                ? val.fileCollaboratorRole
                : serializeRoleVariable(val.fileCollaboratorRole),
            ['task_collaborators']: val.taskCollaborators == void 0
                ? val.taskCollaborators
                : serializeCollaboratorVariable(val.taskCollaborators),
            ['role']: val.role == void 0 ? val.role : serializeRoleVariable(val.role),
        };
    }

    class GetWorkflowsOptionals {
        constructor(fields) {
            this.headers = new GetWorkflowsHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class StartWorkflowOptionals {
        constructor(fields) {
            this.headers = new StartWorkflowHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetWorkflowsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class StartWorkflowHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class WorkflowsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Returns list of workflows that act on a given `folder ID`, and
         * have a flow with a trigger type of `WORKFLOW_MANUAL_START`.
         *
         * You application must be authorized to use the `Manage Box Relay` application
         * scope within the developer console in to use this endpoint.
         * @param {GetWorkflowsQueryParams} queryParams Query parameters of getWorkflows method
         * @param {GetWorkflowsOptionalsInput} optionalsInput
         * @returns {Promise<Workflows>}
         */
        getWorkflows(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetWorkflowsOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['folder_id']: toString(queryParams.folderId),
                    ['trigger_type']: toString(queryParams.triggerType),
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/workflows'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeWorkflows(response.data)), { rawData: response.data });
            });
        }
        /**
           * Initiates a flow with a trigger type of `WORKFLOW_MANUAL_START`.
           *
           * You application must be authorized to use the `Manage Box Relay` application
           * scope within the developer console.
           * @param {string} workflowId The ID of the workflow.
          Example: "12345"
           * @param {StartWorkflowRequestBody} requestBody Request body of startWorkflow method
           * @param {StartWorkflowOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        startWorkflow(workflowId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (workflowId, requestBody, optionalsInput = {}) {
                const optionals = new StartWorkflowOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/workflows/', toString(workflowId), '/start'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeStartWorkflowRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeStartWorkflowRequestBodyTypeField(val) {
        return val;
    }
    function serializeStartWorkflowRequestBodyFlowField(val) {
        return { ['type']: val.type, ['id']: val.id };
    }
    function serializeStartWorkflowRequestBodyFilesTypeField(val) {
        return val;
    }
    function serializeStartWorkflowRequestBodyFilesField(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeStartWorkflowRequestBodyFilesTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeStartWorkflowRequestBodyFolderTypeField(val) {
        return val;
    }
    function serializeStartWorkflowRequestBodyFolderField(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeStartWorkflowRequestBodyFolderTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeStartWorkflowRequestBody(val) {
        return {
            ['type']: val.type == void 0
                ? val.type
                : serializeStartWorkflowRequestBodyTypeField(val.type),
            ['flow']: serializeStartWorkflowRequestBodyFlowField(val.flow),
            ['files']: val.files.map(function (item) {
                return serializeStartWorkflowRequestBodyFilesField(item);
            }),
            ['folder']: serializeStartWorkflowRequestBodyFolderField(val.folder),
            ['outcomes']: val.outcomes == void 0
                ? val.outcomes
                : val.outcomes.map(function (item) {
                    return serializeOutcome(item);
                }),
        };
    }

    function deserializeTemplateSignerInputTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'attachment') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TemplateSignerInputTypeField",
        });
    }
    function deserializeTemplateSignerInputContentTypeField(val) {
        if (val == 'signature') {
            return val;
        }
        if (val == 'initial') {
            return val;
        }
        if (val == 'stamp') {
            return val;
        }
        if (val == 'date') {
            return val;
        }
        if (val == 'checkbox') {
            return val;
        }
        if (val == 'text') {
            return val;
        }
        if (val == 'full_name') {
            return val;
        }
        if (val == 'first_name') {
            return val;
        }
        if (val == 'last_name') {
            return val;
        }
        if (val == 'company') {
            return val;
        }
        if (val == 'title') {
            return val;
        }
        if (val == 'email') {
            return val;
        }
        if (val == 'attachment') {
            return val;
        }
        if (val == 'radio') {
            return val;
        }
        if (val == 'dropdown') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TemplateSignerInputContentTypeField",
        });
    }
    function deserializeTemplateSignerInputCoordinatesField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TemplateSignerInputCoordinatesField"',
            });
        }
        if (!(val.x == void 0) && !sdIsNumber(val.x)) {
            throw new BoxSdkError({
                message: 'Expecting number for "x" of type "TemplateSignerInputCoordinatesField"',
            });
        }
        const x = val.x == void 0 ? void 0 : val.x;
        if (!(val.y == void 0) && !sdIsNumber(val.y)) {
            throw new BoxSdkError({
                message: 'Expecting number for "y" of type "TemplateSignerInputCoordinatesField"',
            });
        }
        const y = val.y == void 0 ? void 0 : val.y;
        return { x: x, y: y };
    }
    function deserializeTemplateSignerInputDimensionsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TemplateSignerInputDimensionsField"',
            });
        }
        if (!(val.width == void 0) && !sdIsNumber(val.width)) {
            throw new BoxSdkError({
                message: 'Expecting number for "width" of type "TemplateSignerInputDimensionsField"',
            });
        }
        const width = val.width == void 0 ? void 0 : val.width;
        if (!(val.height == void 0) && !sdIsNumber(val.height)) {
            throw new BoxSdkError({
                message: 'Expecting number for "height" of type "TemplateSignerInputDimensionsField"',
            });
        }
        const height = val.height == void 0 ? void 0 : val.height;
        return {
            width: width,
            height: height,
        };
    }
    function deserializeTemplateSignerInput(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TemplateSignerInput"',
            });
        }
        const type = val.type == void 0
            ? void 0
            : deserializeTemplateSignerInputTypeField(val.type);
        const contentType = val.content_type == void 0
            ? void 0
            : deserializeTemplateSignerInputContentTypeField(val.content_type);
        if (!(val.is_required == void 0) && !sdIsBoolean(val.is_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_required" of type "TemplateSignerInput"',
            });
        }
        const isRequired = val.is_required == void 0 ? void 0 : val.is_required;
        if (val.page_index == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "page_index" of type "TemplateSignerInput" to be defined',
            });
        }
        if (!sdIsNumber(val.page_index)) {
            throw new BoxSdkError({
                message: 'Expecting number for "page_index" of type "TemplateSignerInput"',
            });
        }
        const pageIndex = val.page_index;
        if (!(val.document_id == void 0) && !sdIsString(val.document_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_id" of type "TemplateSignerInput"',
            });
        }
        const documentId = val.document_id == void 0 ? void 0 : val.document_id;
        if (!(val.dropdown_choices == void 0) && !sdIsList(val.dropdown_choices)) {
            throw new BoxSdkError({
                message: 'Expecting array for "dropdown_choices" of type "TemplateSignerInput"',
            });
        }
        const dropdownChoices = val.dropdown_choices == void 0
            ? void 0
            : sdIsList(val.dropdown_choices)
                ? val.dropdown_choices.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "TemplateSignerInput"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.group_id == void 0) && !sdIsString(val.group_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "group_id" of type "TemplateSignerInput"',
            });
        }
        const groupId = val.group_id == void 0 ? void 0 : val.group_id;
        const coordinates = val.coordinates == void 0
            ? void 0
            : deserializeTemplateSignerInputCoordinatesField(val.coordinates);
        const dimensions = val.dimensions == void 0
            ? void 0
            : deserializeTemplateSignerInputDimensionsField(val.dimensions);
        if (!(val.label == void 0) && !sdIsString(val.label)) {
            throw new BoxSdkError({
                message: 'Expecting string for "label" of type "TemplateSignerInput"',
            });
        }
        const label = val.label == void 0 ? void 0 : val.label;
        if (!(val.read_only == void 0) && !sdIsBoolean(val.read_only)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "read_only" of type "TemplateSignerInput"',
            });
        }
        const readOnly = val.read_only == void 0 ? void 0 : val.read_only;
        if (!(val.document_tag_id == void 0) && !sdIsString(val.document_tag_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "document_tag_id" of type "TemplateSignerInput"',
            });
        }
        const documentTagId = val.document_tag_id == void 0 ? void 0 : val.document_tag_id;
        if (!(val.text_value == void 0) && !sdIsString(val.text_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "text_value" of type "TemplateSignerInput"',
            });
        }
        const textValue = val.text_value == void 0 ? void 0 : val.text_value;
        if (!(val.checkbox_value == void 0) && !sdIsBoolean(val.checkbox_value)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "checkbox_value" of type "TemplateSignerInput"',
            });
        }
        const checkboxValue = val.checkbox_value == void 0 ? void 0 : val.checkbox_value;
        if (!(val.date_value == void 0) && !sdIsString(val.date_value)) {
            throw new BoxSdkError({
                message: 'Expecting string for "date_value" of type "TemplateSignerInput"',
            });
        }
        const dateValue = val.date_value == void 0 ? void 0 : dateFromString(val.date_value);
        return {
            type: type,
            contentType: contentType,
            isRequired: isRequired,
            pageIndex: pageIndex,
            documentId: documentId,
            dropdownChoices: dropdownChoices,
            groupId: groupId,
            coordinates: coordinates,
            dimensions: dimensions,
            label: label,
            readOnly: readOnly,
            documentTagId: documentTagId,
            textValue: textValue,
            checkboxValue: checkboxValue,
            dateValue: dateValue,
        };
    }

    function deserializeTemplateSignerRoleField(val) {
        if (val == 'signer') {
            return val;
        }
        if (val == 'approver') {
            return val;
        }
        if (val == 'final_copy_reader') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TemplateSignerRoleField",
        });
    }
    function deserializeTemplateSigner(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "TemplateSigner"' });
        }
        if (!(val.inputs == void 0) && !sdIsList(val.inputs)) {
            throw new BoxSdkError({
                message: 'Expecting array for "inputs" of type "TemplateSigner"',
            });
        }
        const inputs = val.inputs == void 0
            ? void 0
            : sdIsList(val.inputs)
                ? val.inputs.map(function (itm) {
                    return deserializeTemplateSignerInput(itm);
                })
                : [];
        if (!(val.email == void 0) && !sdIsString(val.email)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email" of type "TemplateSigner"',
            });
        }
        const email = val.email == void 0 ? void 0 : val.email;
        const role = val.role == void 0 ? void 0 : deserializeTemplateSignerRoleField(val.role);
        if (!(val.is_in_person == void 0) && !sdIsBoolean(val.is_in_person)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_in_person" of type "TemplateSigner"',
            });
        }
        const isInPerson = val.is_in_person == void 0 ? void 0 : val.is_in_person;
        if (!(val.order == void 0) && !sdIsNumber(val.order)) {
            throw new BoxSdkError({
                message: 'Expecting number for "order" of type "TemplateSigner"',
            });
        }
        const order = val.order == void 0 ? void 0 : val.order;
        if (!(val.signer_group_id == void 0) && !sdIsString(val.signer_group_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "signer_group_id" of type "TemplateSigner"',
            });
        }
        const signerGroupId = val.signer_group_id == void 0 ? void 0 : val.signer_group_id;
        if (!(val.label == void 0) && !sdIsString(val.label)) {
            throw new BoxSdkError({
                message: 'Expecting string for "label" of type "TemplateSigner"',
            });
        }
        const label = val.label == void 0 ? void 0 : val.label;
        if (!(val.public_id == void 0) && !sdIsString(val.public_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "public_id" of type "TemplateSigner"',
            });
        }
        const publicId = val.public_id == void 0 ? void 0 : val.public_id;
        if (!(val.is_password_required == void 0) &&
            !sdIsBoolean(val.is_password_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_password_required" of type "TemplateSigner"',
            });
        }
        const isPasswordRequired = val.is_password_required == void 0 ? void 0 : val.is_password_required;
        if (!(val.is_phone_number_required == void 0) &&
            !sdIsBoolean(val.is_phone_number_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_phone_number_required" of type "TemplateSigner"',
            });
        }
        const isPhoneNumberRequired = val.is_phone_number_required == void 0
            ? void 0
            : val.is_phone_number_required;
        if (!(val.login_required == void 0) && !sdIsBoolean(val.login_required)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "login_required" of type "TemplateSigner"',
            });
        }
        const loginRequired = val.login_required == void 0 ? void 0 : val.login_required;
        return {
            inputs: inputs,
            email: email,
            role: role,
            isInPerson: isInPerson,
            order: order,
            signerGroupId: signerGroupId,
            label: label,
            publicId: publicId,
            isPasswordRequired: isPasswordRequired,
            isPhoneNumberRequired: isPhoneNumberRequired,
            loginRequired: loginRequired,
        };
    }

    function deserializeSignTemplateTypeField(val) {
        if (val == 'sign-template') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize SignTemplateTypeField" });
    }
    function deserializeSignTemplateAdditionalInfoNonEditableField(val) {
        if (val == 'email_subject') {
            return val;
        }
        if (val == 'email_message') {
            return val;
        }
        if (val == 'name') {
            return val;
        }
        if (val == 'days_valid') {
            return val;
        }
        if (val == 'signers') {
            return val;
        }
        if (val == 'source_files') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignTemplateAdditionalInfoNonEditableField",
        });
    }
    function deserializeSignTemplateAdditionalInfoRequiredSignersField(val) {
        if (val == 'email') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize SignTemplateAdditionalInfoRequiredSignersField",
        });
    }
    function deserializeSignTemplateAdditionalInfoRequiredField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateAdditionalInfoRequiredField"',
            });
        }
        if (!(val.signers == void 0) && !sdIsList(val.signers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "signers" of type "SignTemplateAdditionalInfoRequiredField"',
            });
        }
        const signers = val.signers == void 0
            ? void 0
            : sdIsList(val.signers)
                ? val.signers.map(function (itm) {
                    return sdIsList(itm)
                        ? itm.map(function (itm) {
                            return deserializeSignTemplateAdditionalInfoRequiredSignersField(itm);
                        })
                        : [];
                })
                : [];
        return { signers: signers };
    }
    function deserializeSignTemplateAdditionalInfoField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateAdditionalInfoField"',
            });
        }
        if (!(val.non_editable == void 0) && !sdIsList(val.non_editable)) {
            throw new BoxSdkError({
                message: 'Expecting array for "non_editable" of type "SignTemplateAdditionalInfoField"',
            });
        }
        const nonEditable = val.non_editable == void 0
            ? void 0
            : sdIsList(val.non_editable)
                ? val.non_editable.map(function (itm) {
                    return deserializeSignTemplateAdditionalInfoNonEditableField(itm);
                })
                : [];
        const required = val.required == void 0
            ? void 0
            : deserializeSignTemplateAdditionalInfoRequiredField(val.required);
        return {
            nonEditable: nonEditable,
            required: required,
        };
    }
    function deserializeSignTemplateReadySignLinkField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateReadySignLinkField"',
            });
        }
        if (!(val.url == void 0) && !sdIsString(val.url)) {
            throw new BoxSdkError({
                message: 'Expecting string for "url" of type "SignTemplateReadySignLinkField"',
            });
        }
        const url = val.url == void 0 ? void 0 : val.url;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "SignTemplateReadySignLinkField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.instructions == void 0) && !sdIsString(val.instructions)) {
            throw new BoxSdkError({
                message: 'Expecting string for "instructions" of type "SignTemplateReadySignLinkField"',
            });
        }
        const instructions = val.instructions == void 0 ? void 0 : val.instructions;
        if (!(val.folder_id == void 0) && !sdIsString(val.folder_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "folder_id" of type "SignTemplateReadySignLinkField"',
            });
        }
        const folderId = val.folder_id == void 0 ? void 0 : val.folder_id;
        if (!(val.is_notification_disabled == void 0) &&
            !sdIsBoolean(val.is_notification_disabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_notification_disabled" of type "SignTemplateReadySignLinkField"',
            });
        }
        const isNotificationDisabled = val.is_notification_disabled == void 0
            ? void 0
            : val.is_notification_disabled;
        if (!(val.is_active == void 0) && !sdIsBoolean(val.is_active)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_active" of type "SignTemplateReadySignLinkField"',
            });
        }
        const isActive = val.is_active == void 0 ? void 0 : val.is_active;
        return {
            url: url,
            name: name,
            instructions: instructions,
            folderId: folderId,
            isNotificationDisabled: isNotificationDisabled,
            isActive: isActive,
        };
    }
    function deserializeSignTemplateCustomBrandingField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "SignTemplateCustomBrandingField"',
            });
        }
        if (!(val.company_name == void 0) && !sdIsString(val.company_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "company_name" of type "SignTemplateCustomBrandingField"',
            });
        }
        const companyName = val.company_name == void 0 ? void 0 : val.company_name;
        if (!(val.logo_uri == void 0) && !sdIsString(val.logo_uri)) {
            throw new BoxSdkError({
                message: 'Expecting string for "logo_uri" of type "SignTemplateCustomBrandingField"',
            });
        }
        const logoUri = val.logo_uri == void 0 ? void 0 : val.logo_uri;
        if (!(val.branding_color == void 0) && !sdIsString(val.branding_color)) {
            throw new BoxSdkError({
                message: 'Expecting string for "branding_color" of type "SignTemplateCustomBrandingField"',
            });
        }
        const brandingColor = val.branding_color == void 0 ? void 0 : val.branding_color;
        if (!(val.email_footer_text == void 0) &&
            !sdIsString(val.email_footer_text)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_footer_text" of type "SignTemplateCustomBrandingField"',
            });
        }
        const emailFooterText = val.email_footer_text == void 0 ? void 0 : val.email_footer_text;
        return {
            companyName: companyName,
            logoUri: logoUri,
            brandingColor: brandingColor,
            emailFooterText: emailFooterText,
        };
    }
    function deserializeSignTemplate(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignTemplate"' });
        }
        const type = val.type == void 0 ? void 0 : deserializeSignTemplateTypeField(val.type);
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "SignTemplate"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "SignTemplate"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.email_subject == void 0) && !sdIsString(val.email_subject)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_subject" of type "SignTemplate"',
            });
        }
        const emailSubject = val.email_subject == void 0 ? void 0 : val.email_subject;
        if (!(val.email_message == void 0) && !sdIsString(val.email_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "email_message" of type "SignTemplate"',
            });
        }
        const emailMessage = val.email_message == void 0 ? void 0 : val.email_message;
        if (!(val.days_valid == void 0) && !sdIsNumber(val.days_valid)) {
            throw new BoxSdkError({
                message: 'Expecting number for "days_valid" of type "SignTemplate"',
            });
        }
        const daysValid = val.days_valid == void 0 ? void 0 : val.days_valid;
        const parentFolder = val.parent_folder == void 0
            ? void 0
            : deserializeFolderMini(val.parent_folder);
        if (!(val.source_files == void 0) && !sdIsList(val.source_files)) {
            throw new BoxSdkError({
                message: 'Expecting array for "source_files" of type "SignTemplate"',
            });
        }
        const sourceFiles = val.source_files == void 0
            ? void 0
            : sdIsList(val.source_files)
                ? val.source_files.map(function (itm) {
                    return deserializeFileMini(itm);
                })
                : [];
        if (!(val.are_fields_locked == void 0) &&
            !sdIsBoolean(val.are_fields_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_fields_locked" of type "SignTemplate"',
            });
        }
        const areFieldsLocked = val.are_fields_locked == void 0 ? void 0 : val.are_fields_locked;
        if (!(val.are_options_locked == void 0) &&
            !sdIsBoolean(val.are_options_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_options_locked" of type "SignTemplate"',
            });
        }
        const areOptionsLocked = val.are_options_locked == void 0 ? void 0 : val.are_options_locked;
        if (!(val.are_recipients_locked == void 0) &&
            !sdIsBoolean(val.are_recipients_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_recipients_locked" of type "SignTemplate"',
            });
        }
        const areRecipientsLocked = val.are_recipients_locked == void 0 ? void 0 : val.are_recipients_locked;
        if (!(val.are_email_settings_locked == void 0) &&
            !sdIsBoolean(val.are_email_settings_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_email_settings_locked" of type "SignTemplate"',
            });
        }
        const areEmailSettingsLocked = val.are_email_settings_locked == void 0
            ? void 0
            : val.are_email_settings_locked;
        if (!(val.are_files_locked == void 0) && !sdIsBoolean(val.are_files_locked)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "are_files_locked" of type "SignTemplate"',
            });
        }
        const areFilesLocked = val.are_files_locked == void 0 ? void 0 : val.are_files_locked;
        if (!(val.signers == void 0) && !sdIsList(val.signers)) {
            throw new BoxSdkError({
                message: 'Expecting array for "signers" of type "SignTemplate"',
            });
        }
        const signers = val.signers == void 0
            ? void 0
            : sdIsList(val.signers)
                ? val.signers.map(function (itm) {
                    return deserializeTemplateSigner(itm);
                })
                : [];
        const additionalInfo = val.additional_info == void 0
            ? void 0
            : deserializeSignTemplateAdditionalInfoField(val.additional_info);
        const readySignLink = val.ready_sign_link == void 0
            ? void 0
            : deserializeSignTemplateReadySignLinkField(val.ready_sign_link);
        const customBranding = val.custom_branding == void 0
            ? void 0
            : deserializeSignTemplateCustomBrandingField(val.custom_branding);
        return {
            type: type,
            id: id,
            name: name,
            emailSubject: emailSubject,
            emailMessage: emailMessage,
            daysValid: daysValid,
            parentFolder: parentFolder,
            sourceFiles: sourceFiles,
            areFieldsLocked: areFieldsLocked,
            areOptionsLocked: areOptionsLocked,
            areRecipientsLocked: areRecipientsLocked,
            areEmailSettingsLocked: areEmailSettingsLocked,
            areFilesLocked: areFilesLocked,
            signers: signers,
            additionalInfo: additionalInfo,
            readySignLink: readySignLink,
            customBranding: customBranding,
        };
    }

    function deserializeSignTemplates(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "SignTemplates"' });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "SignTemplates"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "SignTemplates"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "SignTemplates"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "SignTemplates"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeSignTemplate(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class GetSignTemplateByIdOptionals {
        constructor(fields) {
            this.headers = new GetSignTemplateByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSignTemplatesHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetSignTemplateByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class SignTemplatesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Gets Box Sign templates created by a user.
         * @param {GetSignTemplatesQueryParams} queryParams Query parameters of getSignTemplates method
         * @param {GetSignTemplatesHeadersInput} headersInput Headers of getSignTemplates method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<SignTemplates>}
         */
        getSignTemplates() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetSignTemplatesHeaders({}), cancellationToken) {
                const headers = new GetSignTemplatesHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_templates'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSignTemplates(response.data)), { rawData: response.data });
            });
        }
        /**
           * Fetches details of a specific Box Sign template.
           * @param {string} templateId The ID of a Box Sign template.
          Example: "123075213-7d117509-8f05-42e4-a5ef-5190a319d41d"
           * @param {GetSignTemplateByIdOptionalsInput} optionalsInput
           * @returns {Promise<SignTemplate>}
           */
        getSignTemplateById(templateId_1) {
            return __awaiter$1(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new GetSignTemplateByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/sign_templates/', toString(templateId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeSignTemplate(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeIntegrationMappingBaseTypeField(val) {
        if (val == 'integration_mapping') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingBaseTypeField",
        });
    }

    function serializeIntegrationMappingSlackOptions(val) {
        return { ['is_access_management_disabled']: val.isAccessManagementDisabled };
    }
    function deserializeIntegrationMappingSlackOptions(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingSlackOptions"',
            });
        }
        if (!(val.is_access_management_disabled == void 0) &&
            !sdIsBoolean(val.is_access_management_disabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_access_management_disabled" of type "IntegrationMappingSlackOptions"',
            });
        }
        const isAccessManagementDisabled = val.is_access_management_disabled == void 0
            ? void 0
            : val.is_access_management_disabled;
        return {
            isAccessManagementDisabled: isAccessManagementDisabled,
        };
    }

    function deserializeUserIntegrationMappings(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "UserIntegrationMappings"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserIntegrationMappings"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserIntegrationMappings"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserIntegrationMappings" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserIntegrationMappings"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserIntegrationMappings" to be defined',
            });
        }
        const type = deserializeUserBaseTypeField(val.type);
        return {
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function serializeIntegrationMappingPartnerItemSlackTypeField(val) {
        return val;
    }
    function deserializeIntegrationMappingPartnerItemSlackTypeField(val) {
        if (val == 'channel') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingPartnerItemSlackTypeField",
        });
    }
    function serializeIntegrationMappingPartnerItemSlack(val) {
        return {
            ['type']: serializeIntegrationMappingPartnerItemSlackTypeField(val.type),
            ['id']: val.id,
            ['slack_workspace_id']: val.slackWorkspaceId,
            ['slack_org_id']: val.slackOrgId,
        };
    }
    function deserializeIntegrationMappingPartnerItemSlack(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingPartnerItemSlack"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "IntegrationMappingPartnerItemSlack" to be defined',
            });
        }
        const type = deserializeIntegrationMappingPartnerItemSlackTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "IntegrationMappingPartnerItemSlack" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "IntegrationMappingPartnerItemSlack"',
            });
        }
        const id = val.id;
        if (!(val.slack_workspace_id == void 0) &&
            !sdIsString(val.slack_workspace_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "slack_workspace_id" of type "IntegrationMappingPartnerItemSlack"',
            });
        }
        const slackWorkspaceId = val.slack_workspace_id == void 0 ? void 0 : val.slack_workspace_id;
        if (!(val.slack_org_id == void 0) && !sdIsString(val.slack_org_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "slack_org_id" of type "IntegrationMappingPartnerItemSlack"',
            });
        }
        const slackOrgId = val.slack_org_id == void 0 ? void 0 : val.slack_org_id;
        return {
            type: type,
            id: id,
            slackWorkspaceId: slackWorkspaceId,
            slackOrgId: slackOrgId,
        };
    }

    function deserializeIntegrationMappingPartnerItemSlackUnion(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingPartnerItemSlackUnion"',
            });
        }
        if (val.type == 'channel') {
            return deserializeIntegrationMappingPartnerItemSlack(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingPartnerItemSlackUnion",
        });
    }

    function deserializeIntegrationMappingIntegrationTypeField(val) {
        if (val == 'slack') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingIntegrationTypeField",
        });
    }
    function deserializeIntegrationMapping(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMapping"',
            });
        }
        const integrationType = val.integration_type == void 0
            ? void 0
            : deserializeIntegrationMappingIntegrationTypeField(val.integration_type);
        if (!(val.is_manually_created == void 0) &&
            !sdIsBoolean(val.is_manually_created)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_manually_created" of type "IntegrationMapping"',
            });
        }
        const isManuallyCreated = val.is_manually_created == void 0 ? void 0 : val.is_manually_created;
        const options = val.options == void 0
            ? void 0
            : deserializeIntegrationMappingSlackOptions(val.options);
        const createdBy = val.created_by == void 0
            ? void 0
            : deserializeUserIntegrationMappings(val.created_by);
        const modifiedBy = val.modified_by == void 0
            ? void 0
            : deserializeUserIntegrationMappings(val.modified_by);
        if (val.partner_item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "partner_item" of type "IntegrationMapping" to be defined',
            });
        }
        const partnerItem = deserializeIntegrationMappingPartnerItemSlackUnion(val.partner_item);
        if (val.box_item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "box_item" of type "IntegrationMapping" to be defined',
            });
        }
        const boxItem = deserializeFolderMini(val.box_item);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "IntegrationMapping"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "IntegrationMapping"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "IntegrationMapping" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "IntegrationMapping"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "IntegrationMapping" to be defined',
            });
        }
        const type = deserializeIntegrationMappingBaseTypeField(val.type);
        return {
            integrationType: integrationType,
            isManuallyCreated: isManuallyCreated,
            options: options,
            createdBy: createdBy,
            modifiedBy: modifiedBy,
            partnerItem: partnerItem,
            boxItem: boxItem,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            id: id,
            type: type,
        };
    }

    function deserializeIntegrationMappings(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappings"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "IntegrationMappings"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "IntegrationMappings"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "IntegrationMappings"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeIntegrationMapping(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            entries: entries,
        };
    }

    function serializeIntegrationMappingBoxItemSlackTypeField(val) {
        return val;
    }
    function serializeIntegrationMappingBoxItemSlack(val) {
        return {
            ['type']: serializeIntegrationMappingBoxItemSlackTypeField(val.type),
            ['id']: val.id,
        };
    }

    function serializeIntegrationMappingSlackCreateRequest(val) {
        return {
            ['partner_item']: serializeIntegrationMappingPartnerItemSlack(val.partnerItem),
            ['box_item']: serializeIntegrationMappingBoxItemSlack(val.boxItem),
            ['options']: val.options == void 0
                ? val.options
                : serializeIntegrationMappingSlackOptions(val.options),
        };
    }

    function deserializeIntegrationMappingPartnerItemTeamsTypeField(val) {
        if (val == 'channel') {
            return val;
        }
        if (val == 'team') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingPartnerItemTeamsTypeField",
        });
    }
    function deserializeIntegrationMappingPartnerItemTeams(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingPartnerItemTeams"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "IntegrationMappingPartnerItemTeams" to be defined',
            });
        }
        const type = deserializeIntegrationMappingPartnerItemTeamsTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "IntegrationMappingPartnerItemTeams" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "IntegrationMappingPartnerItemTeams"',
            });
        }
        const id = val.id;
        if (val.tenant_id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "tenant_id" of type "IntegrationMappingPartnerItemTeams" to be defined',
            });
        }
        if (!sdIsString(val.tenant_id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "tenant_id" of type "IntegrationMappingPartnerItemTeams"',
            });
        }
        const tenantId = val.tenant_id;
        return {
            type: type,
            id: id,
            tenantId: tenantId,
        };
    }

    function deserializeIntegrationMappingPartnerItemTeamsUnion(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingPartnerItemTeamsUnion"',
            });
        }
        if (val.type == 'channel') {
            return deserializeIntegrationMappingPartnerItemTeams(val);
        }
        if (val.type == 'team') {
            return deserializeIntegrationMappingPartnerItemTeams(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingPartnerItemTeamsUnion",
        });
    }

    function serializeFolderReferenceTypeField(val) {
        return val;
    }
    function deserializeFolderReferenceTypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderReferenceTypeField",
        });
    }
    function serializeFolderReference(val) {
        return {
            ['type']: serializeFolderReferenceTypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeFolderReference(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "FolderReference"' });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FolderReference" to be defined',
            });
        }
        const type = deserializeFolderReferenceTypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FolderReference" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderReference"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }

    function deserializeIntegrationMappingTeamsIntegrationTypeField(val) {
        if (val == 'teams') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize IntegrationMappingTeamsIntegrationTypeField",
        });
    }
    function deserializeIntegrationMappingTeams(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingTeams"',
            });
        }
        const integrationType = val.integration_type == void 0
            ? void 0
            : deserializeIntegrationMappingTeamsIntegrationTypeField(val.integration_type);
        if (!(val.is_overridden_by_manual_mapping == void 0) &&
            !sdIsBoolean(val.is_overridden_by_manual_mapping)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_overridden_by_manual_mapping" of type "IntegrationMappingTeams"',
            });
        }
        const isOverriddenByManualMapping = val.is_overridden_by_manual_mapping == void 0
            ? void 0
            : val.is_overridden_by_manual_mapping;
        if (val.partner_item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "partner_item" of type "IntegrationMappingTeams" to be defined',
            });
        }
        const partnerItem = deserializeIntegrationMappingPartnerItemTeamsUnion(val.partner_item);
        if (val.box_item == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "box_item" of type "IntegrationMappingTeams" to be defined',
            });
        }
        const boxItem = deserializeFolderReference(val.box_item);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "IntegrationMappingTeams"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "IntegrationMappingTeams"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "IntegrationMappingTeams" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "IntegrationMappingTeams"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "IntegrationMappingTeams" to be defined',
            });
        }
        const type = deserializeIntegrationMappingBaseTypeField(val.type);
        return {
            integrationType: integrationType,
            isOverriddenByManualMapping: isOverriddenByManualMapping,
            partnerItem: partnerItem,
            boxItem: boxItem,
            createdAt: createdAt,
            modifiedAt: modifiedAt,
            id: id,
            type: type,
        };
    }

    function deserializeIntegrationMappingsTeams(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "IntegrationMappingsTeams"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "IntegrationMappingsTeams"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeIntegrationMappingTeams(itm);
                })
                : [];
        return { entries: entries };
    }

    function serializeIntegrationMappingPartnerItemTeamsCreateRequestTypeField(val) {
        return val;
    }
    function serializeIntegrationMappingPartnerItemTeamsCreateRequest(val) {
        return {
            ['type']: serializeIntegrationMappingPartnerItemTeamsCreateRequestTypeField(val.type),
            ['id']: val.id,
            ['tenant_id']: val.tenantId,
            ['team_id']: val.teamId,
        };
    }

    function serializeIntegrationMappingTeamsCreateRequest(val) {
        return {
            ['partner_item']: serializeIntegrationMappingPartnerItemTeamsCreateRequest(val.partnerItem),
            ['box_item']: serializeFolderReference(val.boxItem),
        };
    }

    class CreateSlackIntegrationMappingOptionals {
        constructor(fields) {
            this.headers = new CreateSlackIntegrationMappingHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateSlackIntegrationMappingByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateSlackIntegrationMappingByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteSlackIntegrationMappingByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteSlackIntegrationMappingByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateTeamsIntegrationMappingOptionals {
        constructor(fields) {
            this.headers = new CreateTeamsIntegrationMappingHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateTeamsIntegrationMappingByIdOptionals {
        constructor(fields) {
            this.requestBody = {};
            this.headers = new UpdateTeamsIntegrationMappingByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.requestBody !== undefined) {
                this.requestBody = fields.requestBody;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteTeamsIntegrationMappingByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteTeamsIntegrationMappingByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetSlackIntegrationMappingHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateSlackIntegrationMappingHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateSlackIntegrationMappingByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteSlackIntegrationMappingByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetTeamsIntegrationMappingHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateTeamsIntegrationMappingHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateTeamsIntegrationMappingByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteTeamsIntegrationMappingByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class IntegrationMappingsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Lists [Slack integration mappings](https://support.box.com/hc/en-us/articles/4415585987859-Box-as-the-Content-Layer-for-Slack) in a users' enterprise.
         *
         * You need Admin or Co-Admin role to
         * use this endpoint.
         * @param {GetSlackIntegrationMappingQueryParams} queryParams Query parameters of getSlackIntegrationMapping method
         * @param {GetSlackIntegrationMappingHeadersInput} headersInput Headers of getSlackIntegrationMapping method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<IntegrationMappings>}
         */
        getSlackIntegrationMapping() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetSlackIntegrationMappingHeaders({}), cancellationToken) {
                const headers = new GetSlackIntegrationMappingHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                    ['partner_item_type']: toString(queryParams.partnerItemType),
                    ['partner_item_id']: toString(queryParams.partnerItemId),
                    ['box_item_id']: toString(queryParams.boxItemId),
                    ['box_item_type']: toString(queryParams.boxItemType),
                    ['is_manually_created']: toString(queryParams.isManuallyCreated),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeIntegrationMappings(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a [Slack integration mapping](https://support.box.com/hc/en-us/articles/4415585987859-Box-as-the-Content-Layer-for-Slack)
         * by mapping a Slack channel to a Box item.
         *
         * You need Admin or Co-Admin role to
         * use this endpoint.
         * @param {IntegrationMappingSlackCreateRequest} requestBody Request body of createSlackIntegrationMapping method
         * @param {CreateSlackIntegrationMappingOptionalsInput} optionalsInput
         * @returns {Promise<IntegrationMapping>}
         */
        createSlackIntegrationMapping(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateSlackIntegrationMappingOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeIntegrationMappingSlackCreateRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeIntegrationMapping(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a [Slack integration mapping](https://support.box.com/hc/en-us/articles/4415585987859-Box-as-the-Content-Layer-for-Slack).
           * Supports updating the Box folder ID and options.
           *
           * You need Admin or Co-Admin role to
           * use this endpoint.
           * @param {string} integrationMappingId An ID of an integration mapping.
          Example: "11235432"
           * @param {UpdateSlackIntegrationMappingByIdOptionalsInput} optionalsInput
           * @returns {Promise<IntegrationMapping>}
           */
        updateSlackIntegrationMappingById(integrationMappingId_1) {
            return __awaiter$1(this, arguments, void 0, function* (integrationMappingId, optionalsInput = {}) {
                const optionals = new UpdateSlackIntegrationMappingByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack/', toString(integrationMappingId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateSlackIntegrationMappingByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeIntegrationMapping(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a [Slack integration mapping](https://support.box.com/hc/en-us/articles/4415585987859-Box-as-the-Content-Layer-for-Slack).
           *
           *
           * You need Admin or Co-Admin role to
           * use this endpoint.
           * @param {string} integrationMappingId An ID of an integration mapping.
          Example: "11235432"
           * @param {DeleteSlackIntegrationMappingByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteSlackIntegrationMappingById(integrationMappingId_1) {
            return __awaiter$1(this, arguments, void 0, function* (integrationMappingId, optionalsInput = {}) {
                const optionals = new DeleteSlackIntegrationMappingByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/slack/', toString(integrationMappingId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
         * Lists [Teams integration mappings](https://support.box.com/hc/en-us/articles/360044681474-Using-Box-for-Teams) in a users' enterprise.
         * You need Admin or Co-Admin role to
         * use this endpoint.
         * @param {GetTeamsIntegrationMappingQueryParams} queryParams Query parameters of getTeamsIntegrationMapping method
         * @param {GetTeamsIntegrationMappingHeadersInput} headersInput Headers of getTeamsIntegrationMapping method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<IntegrationMappingsTeams>}
         */
        getTeamsIntegrationMapping() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetTeamsIntegrationMappingHeaders({}), cancellationToken) {
                const headers = new GetTeamsIntegrationMappingHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['partner_item_type']: toString(queryParams.partnerItemType),
                    ['partner_item_id']: toString(queryParams.partnerItemId),
                    ['box_item_id']: toString(queryParams.boxItemId),
                    ['box_item_type']: toString(queryParams.boxItemType),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/teams'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeIntegrationMappingsTeams(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a [Teams integration mapping](https://support.box.com/hc/en-us/articles/360044681474-Using-Box-for-Teams)
         * by mapping a Teams channel to a Box item.
         * You need Admin or Co-Admin role to
         * use this endpoint.
         * @param {IntegrationMappingTeamsCreateRequest} requestBody Request body of createTeamsIntegrationMapping method
         * @param {CreateTeamsIntegrationMappingOptionalsInput} optionalsInput
         * @returns {Promise<IntegrationMappingTeams>}
         */
        createTeamsIntegrationMapping(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateTeamsIntegrationMappingOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/teams'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeIntegrationMappingTeamsCreateRequest(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeIntegrationMappingTeams(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a [Teams integration mapping](https://support.box.com/hc/en-us/articles/360044681474-Using-Box-for-Teams).
           * Supports updating the Box folder ID and options.
           * You need Admin or Co-Admin role to
           * use this endpoint.
           * @param {string} integrationMappingId An ID of an integration mapping.
          Example: "11235432"
           * @param {UpdateTeamsIntegrationMappingByIdOptionalsInput} optionalsInput
           * @returns {Promise<IntegrationMappingTeams>}
           */
        updateTeamsIntegrationMappingById(integrationMappingId_1) {
            return __awaiter$1(this, arguments, void 0, function* (integrationMappingId, optionalsInput = {}) {
                const optionals = new UpdateTeamsIntegrationMappingByIdOptionals({
                    requestBody: optionalsInput.requestBody,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const requestBody = optionals.requestBody;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/teams/', toString(integrationMappingId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeUpdateTeamsIntegrationMappingByIdRequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeIntegrationMappingTeams(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a [Teams integration mapping](https://support.box.com/hc/en-us/articles/360044681474-Using-Box-for-Teams).
           * You need Admin or Co-Admin role to
           * use this endpoint.
           * @param {string} integrationMappingId An ID of an integration mapping.
          Example: "11235432"
           * @param {DeleteTeamsIntegrationMappingByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteTeamsIntegrationMappingById(integrationMappingId_1) {
            return __awaiter$1(this, arguments, void 0, function* (integrationMappingId, optionalsInput = {}) {
                const optionals = new DeleteTeamsIntegrationMappingByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/integration_mappings/teams/', toString(integrationMappingId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeUpdateSlackIntegrationMappingByIdRequestBody(val) {
        return {
            ['box_item']: val.boxItem == void 0
                ? val.boxItem
                : serializeIntegrationMappingBoxItemSlack(val.boxItem),
            ['options']: val.options == void 0
                ? val.options
                : serializeIntegrationMappingSlackOptions(val.options),
        };
    }
    function serializeUpdateTeamsIntegrationMappingByIdRequestBody(val) {
        return {
            ['box_item']: val.boxItem == void 0
                ? val.boxItem
                : serializeFolderReference(val.boxItem),
        };
    }

    function deserializeAiAgentInfoModelsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentInfoModelsField"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "AiAgentInfoModelsField"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.provider == void 0) && !sdIsString(val.provider)) {
            throw new BoxSdkError({
                message: 'Expecting string for "provider" of type "AiAgentInfoModelsField"',
            });
        }
        const provider = val.provider == void 0 ? void 0 : val.provider;
        if (!(val.supported_purpose == void 0) &&
            !sdIsString(val.supported_purpose)) {
            throw new BoxSdkError({
                message: 'Expecting string for "supported_purpose" of type "AiAgentInfoModelsField"',
            });
        }
        const supportedPurpose = val.supported_purpose == void 0 ? void 0 : val.supported_purpose;
        return {
            name: name,
            provider: provider,
            supportedPurpose: supportedPurpose,
        };
    }
    function deserializeAiAgentInfo(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiAgentInfo"' });
        }
        if (!(val.models == void 0) && !sdIsList(val.models)) {
            throw new BoxSdkError({
                message: 'Expecting array for "models" of type "AiAgentInfo"',
            });
        }
        const models = val.models == void 0
            ? void 0
            : sdIsList(val.models)
                ? val.models.map(function (itm) {
                    return deserializeAiAgentInfoModelsField(itm);
                })
                : [];
        if (!(val.processor == void 0) && !sdIsString(val.processor)) {
            throw new BoxSdkError({
                message: 'Expecting string for "processor" of type "AiAgentInfo"',
            });
        }
        const processor = val.processor == void 0 ? void 0 : val.processor;
        return { models: models, processor: processor };
    }

    function deserializeAiResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiResponse"' });
        }
        if (val.answer == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "answer" of type "AiResponse" to be defined',
            });
        }
        if (!sdIsString(val.answer)) {
            throw new BoxSdkError({
                message: 'Expecting string for "answer" of type "AiResponse"',
            });
        }
        const answer = val.answer;
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "AiResponse" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "AiResponse"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (!(val.completion_reason == void 0) &&
            !sdIsString(val.completion_reason)) {
            throw new BoxSdkError({
                message: 'Expecting string for "completion_reason" of type "AiResponse"',
            });
        }
        const completionReason = val.completion_reason == void 0 ? void 0 : val.completion_reason;
        const aiAgentInfo = val.ai_agent_info == void 0
            ? void 0
            : deserializeAiAgentInfo(val.ai_agent_info);
        return {
            answer: answer,
            createdAt: createdAt,
            completionReason: completionReason,
            aiAgentInfo: aiAgentInfo,
        };
    }

    function deserializeAiCitationTypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize AiCitationTypeField" });
    }
    function deserializeAiCitation(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiCitation"' });
        }
        if (!(val.content == void 0) && !sdIsString(val.content)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content" of type "AiCitation"',
            });
        }
        const content = val.content == void 0 ? void 0 : val.content;
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AiCitation"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0 ? void 0 : deserializeAiCitationTypeField(val.type);
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "AiCitation"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        return {
            content: content,
            id: id,
            type: type,
            name: name,
        };
    }

    function deserializeAiResponseFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiResponseFull"' });
        }
        if (!(val.citations == void 0) && !sdIsList(val.citations)) {
            throw new BoxSdkError({
                message: 'Expecting array for "citations" of type "AiResponseFull"',
            });
        }
        const citations = val.citations == void 0
            ? void 0
            : sdIsList(val.citations)
                ? val.citations.map(function (itm) {
                    return deserializeAiCitation(itm);
                })
                : [];
        if (val.answer == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "answer" of type "AiResponseFull" to be defined',
            });
        }
        if (!sdIsString(val.answer)) {
            throw new BoxSdkError({
                message: 'Expecting string for "answer" of type "AiResponseFull"',
            });
        }
        const answer = val.answer;
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "AiResponseFull" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "AiResponseFull"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (!(val.completion_reason == void 0) &&
            !sdIsString(val.completion_reason)) {
            throw new BoxSdkError({
                message: 'Expecting string for "completion_reason" of type "AiResponseFull"',
            });
        }
        const completionReason = val.completion_reason == void 0 ? void 0 : val.completion_reason;
        const aiAgentInfo = val.ai_agent_info == void 0
            ? void 0
            : deserializeAiAgentInfo(val.ai_agent_info);
        return {
            citations: citations,
            answer: answer,
            createdAt: createdAt,
            completionReason: completionReason,
            aiAgentInfo: aiAgentInfo,
        };
    }

    function serializeAiItemAskTypeField(val) {
        return val;
    }
    function serializeAiItemAsk(val) {
        return {
            ['id']: val.id,
            ['type']: serializeAiItemAskTypeField(val.type),
            ['content']: val.content,
        };
    }

    function serializeAiDialogueHistory(val) {
        return {
            ['prompt']: val.prompt,
            ['answer']: val.answer,
            ['created_at']: val.createdAt == void 0
                ? val.createdAt
                : dateTimeToString(val.createdAt),
        };
    }

    function serializeAiLlmEndpointParamsOpenAiTypeField(val) {
        return val;
    }
    function deserializeAiLlmEndpointParamsOpenAiTypeField(val) {
        if (val == 'openai_params') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiLlmEndpointParamsOpenAiTypeField",
        });
    }
    function serializeAiLlmEndpointParamsOpenAi(val) {
        return {
            ['type']: serializeAiLlmEndpointParamsOpenAiTypeField(val.type),
            ['temperature']: val.temperature,
            ['top_p']: val.topP,
            ['frequency_penalty']: val.frequencyPenalty,
            ['presence_penalty']: val.presencePenalty,
            ['stop']: val.stop,
        };
    }
    function deserializeAiLlmEndpointParamsOpenAi(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiLlmEndpointParamsOpenAi"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiLlmEndpointParamsOpenAi" to be defined',
            });
        }
        const type = deserializeAiLlmEndpointParamsOpenAiTypeField(val.type);
        if (!(val.temperature == void 0) && !sdIsNumber(val.temperature)) {
            throw new BoxSdkError({
                message: 'Expecting number for "temperature" of type "AiLlmEndpointParamsOpenAi"',
            });
        }
        const temperature = val.temperature == void 0 ? void 0 : val.temperature;
        if (!(val.top_p == void 0) && !sdIsNumber(val.top_p)) {
            throw new BoxSdkError({
                message: 'Expecting number for "top_p" of type "AiLlmEndpointParamsOpenAi"',
            });
        }
        const topP = val.top_p == void 0 ? void 0 : val.top_p;
        if (!(val.frequency_penalty == void 0) &&
            !sdIsNumber(val.frequency_penalty)) {
            throw new BoxSdkError({
                message: 'Expecting number for "frequency_penalty" of type "AiLlmEndpointParamsOpenAi"',
            });
        }
        const frequencyPenalty = val.frequency_penalty == void 0 ? void 0 : val.frequency_penalty;
        if (!(val.presence_penalty == void 0) && !sdIsNumber(val.presence_penalty)) {
            throw new BoxSdkError({
                message: 'Expecting number for "presence_penalty" of type "AiLlmEndpointParamsOpenAi"',
            });
        }
        const presencePenalty = val.presence_penalty == void 0 ? void 0 : val.presence_penalty;
        if (!(val.stop == void 0) && !sdIsString(val.stop)) {
            throw new BoxSdkError({
                message: 'Expecting string for "stop" of type "AiLlmEndpointParamsOpenAi"',
            });
        }
        const stop = val.stop == void 0 ? void 0 : val.stop;
        return {
            type: type,
            temperature: temperature,
            topP: topP,
            frequencyPenalty: frequencyPenalty,
            presencePenalty: presencePenalty,
            stop: stop,
        };
    }

    function serializeAiLlmEndpointParamsGoogleTypeField(val) {
        return val;
    }
    function deserializeAiLlmEndpointParamsGoogleTypeField(val) {
        if (val == 'google_params') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiLlmEndpointParamsGoogleTypeField",
        });
    }
    function serializeAiLlmEndpointParamsGoogle(val) {
        return {
            ['type']: serializeAiLlmEndpointParamsGoogleTypeField(val.type),
            ['temperature']: val.temperature,
            ['top_p']: val.topP,
            ['top_k']: val.topK,
        };
    }
    function deserializeAiLlmEndpointParamsGoogle(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiLlmEndpointParamsGoogle"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiLlmEndpointParamsGoogle" to be defined',
            });
        }
        const type = deserializeAiLlmEndpointParamsGoogleTypeField(val.type);
        if (!(val.temperature == void 0) && !sdIsNumber(val.temperature)) {
            throw new BoxSdkError({
                message: 'Expecting number for "temperature" of type "AiLlmEndpointParamsGoogle"',
            });
        }
        const temperature = val.temperature == void 0 ? void 0 : val.temperature;
        if (!(val.top_p == void 0) && !sdIsNumber(val.top_p)) {
            throw new BoxSdkError({
                message: 'Expecting number for "top_p" of type "AiLlmEndpointParamsGoogle"',
            });
        }
        const topP = val.top_p == void 0 ? void 0 : val.top_p;
        if (!(val.top_k == void 0) && !sdIsNumber(val.top_k)) {
            throw new BoxSdkError({
                message: 'Expecting number for "top_k" of type "AiLlmEndpointParamsGoogle"',
            });
        }
        const topK = val.top_k == void 0 ? void 0 : val.top_k;
        return {
            type: type,
            temperature: temperature,
            topP: topP,
            topK: topK,
        };
    }

    function serializeAiLlmEndpointParamsAwsTypeField(val) {
        return val;
    }
    function deserializeAiLlmEndpointParamsAwsTypeField(val) {
        if (val == 'aws_params') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiLlmEndpointParamsAwsTypeField",
        });
    }
    function serializeAiLlmEndpointParamsAws(val) {
        return {
            ['type']: serializeAiLlmEndpointParamsAwsTypeField(val.type),
            ['temperature']: val.temperature,
            ['top_p']: val.topP,
        };
    }
    function deserializeAiLlmEndpointParamsAws(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiLlmEndpointParamsAws"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiLlmEndpointParamsAws" to be defined',
            });
        }
        const type = deserializeAiLlmEndpointParamsAwsTypeField(val.type);
        if (!(val.temperature == void 0) && !sdIsNumber(val.temperature)) {
            throw new BoxSdkError({
                message: 'Expecting number for "temperature" of type "AiLlmEndpointParamsAws"',
            });
        }
        const temperature = val.temperature == void 0 ? void 0 : val.temperature;
        if (!(val.top_p == void 0) && !sdIsNumber(val.top_p)) {
            throw new BoxSdkError({
                message: 'Expecting number for "top_p" of type "AiLlmEndpointParamsAws"',
            });
        }
        const topP = val.top_p == void 0 ? void 0 : val.top_p;
        return {
            type: type,
            temperature: temperature,
            topP: topP,
        };
    }

    function serializeAiLlmEndpointParamsIbmTypeField(val) {
        return val;
    }
    function deserializeAiLlmEndpointParamsIbmTypeField(val) {
        if (val == 'ibm_params') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiLlmEndpointParamsIbmTypeField",
        });
    }
    function serializeAiLlmEndpointParamsIbm(val) {
        return {
            ['type']: serializeAiLlmEndpointParamsIbmTypeField(val.type),
            ['temperature']: val.temperature,
            ['top_p']: val.topP,
            ['top_k']: val.topK,
        };
    }
    function deserializeAiLlmEndpointParamsIbm(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiLlmEndpointParamsIbm"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiLlmEndpointParamsIbm" to be defined',
            });
        }
        const type = deserializeAiLlmEndpointParamsIbmTypeField(val.type);
        if (!(val.temperature == void 0) && !sdIsNumber(val.temperature)) {
            throw new BoxSdkError({
                message: 'Expecting number for "temperature" of type "AiLlmEndpointParamsIbm"',
            });
        }
        const temperature = val.temperature == void 0 ? void 0 : val.temperature;
        if (!(val.top_p == void 0) && !sdIsNumber(val.top_p)) {
            throw new BoxSdkError({
                message: 'Expecting number for "top_p" of type "AiLlmEndpointParamsIbm"',
            });
        }
        const topP = val.top_p == void 0 ? void 0 : val.top_p;
        if (!(val.top_k == void 0) && !sdIsNumber(val.top_k)) {
            throw new BoxSdkError({
                message: 'Expecting number for "top_k" of type "AiLlmEndpointParamsIbm"',
            });
        }
        const topK = val.top_k == void 0 ? void 0 : val.top_k;
        return {
            type: type,
            temperature: temperature,
            topP: topP,
            topK: topK,
        };
    }

    function serializeAiLlmEndpointParams(val) {
        if (val.type == 'openai_params') {
            return serializeAiLlmEndpointParamsOpenAi(val);
        }
        if (val.type == 'google_params') {
            return serializeAiLlmEndpointParamsGoogle(val);
        }
        if (val.type == 'aws_params') {
            return serializeAiLlmEndpointParamsAws(val);
        }
        if (val.type == 'ibm_params') {
            return serializeAiLlmEndpointParamsIbm(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }
    function deserializeAiLlmEndpointParams(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiLlmEndpointParams"',
            });
        }
        if (val.type == 'openai_params') {
            return deserializeAiLlmEndpointParamsOpenAi(val);
        }
        if (val.type == 'google_params') {
            return deserializeAiLlmEndpointParamsGoogle(val);
        }
        if (val.type == 'aws_params') {
            return deserializeAiLlmEndpointParamsAws(val);
        }
        if (val.type == 'ibm_params') {
            return deserializeAiLlmEndpointParamsIbm(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize AiLlmEndpointParams" });
    }

    function serializeAiAgentBasicTextToolBase(val) {
        return {
            ['model']: val.model,
            ['num_tokens_for_completion']: val.numTokensForCompletion,
            ['llm_endpoint_params']: val.llmEndpointParams == void 0
                ? val.llmEndpointParams
                : serializeAiLlmEndpointParams(val.llmEndpointParams),
        };
    }

    function serializeAiAgentBasicTextTool(val) {
        const base = serializeAiAgentBasicTextToolBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentBasicTextTool"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['system_message']: val.systemMessage,
            ['prompt_template']: val.promptTemplate,
        });
    }
    function deserializeAiAgentBasicTextTool(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentBasicTextTool"',
            });
        }
        if (!(val.system_message == void 0) && !sdIsString(val.system_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "system_message" of type "AiAgentBasicTextTool"',
            });
        }
        const systemMessage = val.system_message == void 0 ? void 0 : val.system_message;
        if (!(val.prompt_template == void 0) && !sdIsString(val.prompt_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prompt_template" of type "AiAgentBasicTextTool"',
            });
        }
        const promptTemplate = val.prompt_template == void 0 ? void 0 : val.prompt_template;
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiAgentBasicTextTool"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiAgentBasicTextTool"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            systemMessage: systemMessage,
            promptTemplate: promptTemplate,
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function serializeAiAgentLongTextToolEmbeddingsStrategyField(val) {
        return { ['id']: val.id, ['num_tokens_per_chunk']: val.numTokensPerChunk };
    }
    function deserializeAiAgentLongTextToolEmbeddingsStrategyField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentLongTextToolEmbeddingsStrategyField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AiAgentLongTextToolEmbeddingsStrategyField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.num_tokens_per_chunk == void 0) &&
            !sdIsNumber(val.num_tokens_per_chunk)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_per_chunk" of type "AiAgentLongTextToolEmbeddingsStrategyField"',
            });
        }
        const numTokensPerChunk = val.num_tokens_per_chunk == void 0 ? void 0 : val.num_tokens_per_chunk;
        return {
            id: id,
            numTokensPerChunk: numTokensPerChunk,
        };
    }
    function serializeAiAgentLongTextToolEmbeddingsField(val) {
        return {
            ['model']: val.model,
            ['strategy']: val.strategy == void 0
                ? val.strategy
                : serializeAiAgentLongTextToolEmbeddingsStrategyField(val.strategy),
        };
    }
    function deserializeAiAgentLongTextToolEmbeddingsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentLongTextToolEmbeddingsField"',
            });
        }
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiAgentLongTextToolEmbeddingsField"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        const strategy = val.strategy == void 0
            ? void 0
            : deserializeAiAgentLongTextToolEmbeddingsStrategyField(val.strategy);
        return {
            model: model,
            strategy: strategy,
        };
    }
    function serializeAiAgentLongTextTool(val) {
        const base = serializeAiAgentBasicTextTool(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentLongTextTool"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['embeddings']: val.embeddings == void 0
                ? val.embeddings
                : serializeAiAgentLongTextToolEmbeddingsField(val.embeddings),
        });
    }
    function deserializeAiAgentLongTextTool(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentLongTextTool"',
            });
        }
        const embeddings = val.embeddings == void 0
            ? void 0
            : deserializeAiAgentLongTextToolEmbeddingsField(val.embeddings);
        if (!(val.system_message == void 0) && !sdIsString(val.system_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "system_message" of type "AiAgentLongTextTool"',
            });
        }
        const systemMessage = val.system_message == void 0 ? void 0 : val.system_message;
        if (!(val.prompt_template == void 0) && !sdIsString(val.prompt_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prompt_template" of type "AiAgentLongTextTool"',
            });
        }
        const promptTemplate = val.prompt_template == void 0 ? void 0 : val.prompt_template;
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiAgentLongTextTool"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiAgentLongTextTool"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            embeddings: embeddings,
            systemMessage: systemMessage,
            promptTemplate: promptTemplate,
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function serializeAiAgentSpreadsheetTool(val) {
        return {
            ['model']: val.model,
            ['num_tokens_for_completion']: val.numTokensForCompletion,
            ['llm_endpoint_params']: val.llmEndpointParams == void 0
                ? val.llmEndpointParams
                : serializeAiLlmEndpointParams(val.llmEndpointParams),
        };
    }
    function deserializeAiAgentSpreadsheetTool(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentSpreadsheetTool"',
            });
        }
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiAgentSpreadsheetTool"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiAgentSpreadsheetTool"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function serializeAiAgentAskTypeField(val) {
        return val;
    }
    function deserializeAiAgentAskTypeField(val) {
        if (val == 'ai_agent_ask') {
            return val;
        }
        throw new BoxSdkError({ message: "Can't deserialize AiAgentAskTypeField" });
    }
    function serializeAiAgentAsk(val) {
        return {
            ['type']: serializeAiAgentAskTypeField(val.type),
            ['long_text']: val.longText == void 0
                ? val.longText
                : serializeAiAgentLongTextTool(val.longText),
            ['basic_text']: val.basicText == void 0
                ? val.basicText
                : serializeAiAgentBasicTextTool(val.basicText),
            ['spreadsheet']: val.spreadsheet == void 0
                ? val.spreadsheet
                : serializeAiAgentSpreadsheetTool(val.spreadsheet),
            ['long_text_multi']: val.longTextMulti == void 0
                ? val.longTextMulti
                : serializeAiAgentLongTextTool(val.longTextMulti),
            ['basic_text_multi']: val.basicTextMulti == void 0
                ? val.basicTextMulti
                : serializeAiAgentBasicTextTool(val.basicTextMulti),
            ['basic_image']: val.basicImage == void 0
                ? val.basicImage
                : serializeAiAgentBasicTextTool(val.basicImage),
            ['basic_image_multi']: val.basicImageMulti == void 0
                ? val.basicImageMulti
                : serializeAiAgentBasicTextTool(val.basicImageMulti),
        };
    }
    function deserializeAiAgentAsk(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiAgentAsk"' });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiAgentAsk" to be defined',
            });
        }
        const type = deserializeAiAgentAskTypeField(val.type);
        const longText = val.long_text == void 0
            ? void 0
            : deserializeAiAgentLongTextTool(val.long_text);
        const basicText = val.basic_text == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_text);
        const spreadsheet = val.spreadsheet == void 0
            ? void 0
            : deserializeAiAgentSpreadsheetTool(val.spreadsheet);
        const longTextMulti = val.long_text_multi == void 0
            ? void 0
            : deserializeAiAgentLongTextTool(val.long_text_multi);
        const basicTextMulti = val.basic_text_multi == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_text_multi);
        const basicImage = val.basic_image == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_image);
        const basicImageMulti = val.basic_image_multi == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_image_multi);
        return {
            type: type,
            longText: longText,
            basicText: basicText,
            spreadsheet: spreadsheet,
            longTextMulti: longTextMulti,
            basicTextMulti: basicTextMulti,
            basicImage: basicImage,
            basicImageMulti: basicImageMulti,
        };
    }

    function serializeAiAgentReferenceTypeField(val) {
        return val;
    }
    function serializeAiAgentReference(val) {
        return {
            ['type']: serializeAiAgentReferenceTypeField(val.type),
            ['id']: val.id,
        };
    }

    function serializeAiAgentAskOrAiAgentReference(val) {
        if (val.type == 'ai_agent_ask') {
            return serializeAiAgentAsk(val);
        }
        if (val.type == 'ai_agent_id') {
            return serializeAiAgentReference(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }

    function serializeAiAskModeField(val) {
        return val;
    }
    function serializeAiAsk(val) {
        return {
            ['mode']: serializeAiAskModeField(val.mode),
            ['prompt']: val.prompt,
            ['items']: val.items.map(function (item) {
                return serializeAiItemAsk(item);
            }),
            ['dialogue_history']: val.dialogueHistory == void 0
                ? val.dialogueHistory
                : val.dialogueHistory.map(function (item) {
                    return serializeAiDialogueHistory(item);
                }),
            ['include_citations']: val.includeCitations,
            ['ai_agent']: val.aiAgent == void 0
                ? val.aiAgent
                : serializeAiAgentAskOrAiAgentReference(val.aiAgent),
        };
    }

    function serializeAiAgentBasicTextToolTextGen(val) {
        const base = serializeAiAgentBasicTextToolBase(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentBasicTextToolTextGen"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['system_message']: val.systemMessage,
            ['prompt_template']: val.promptTemplate,
        });
    }

    function serializeAiAgentLongTextToolTextGenEmbeddingsStrategyField(val) {
        return { ['id']: val.id, ['num_tokens_per_chunk']: val.numTokensPerChunk };
    }
    function deserializeAiAgentLongTextToolTextGenEmbeddingsStrategyField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentLongTextToolTextGenEmbeddingsStrategyField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AiAgentLongTextToolTextGenEmbeddingsStrategyField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        if (!(val.num_tokens_per_chunk == void 0) &&
            !sdIsNumber(val.num_tokens_per_chunk)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_per_chunk" of type "AiAgentLongTextToolTextGenEmbeddingsStrategyField"',
            });
        }
        const numTokensPerChunk = val.num_tokens_per_chunk == void 0 ? void 0 : val.num_tokens_per_chunk;
        return {
            id: id,
            numTokensPerChunk: numTokensPerChunk,
        };
    }
    function serializeAiAgentLongTextToolTextGenEmbeddingsField(val) {
        return {
            ['model']: val.model,
            ['strategy']: val.strategy == void 0
                ? val.strategy
                : serializeAiAgentLongTextToolTextGenEmbeddingsStrategyField(val.strategy),
        };
    }
    function deserializeAiAgentLongTextToolTextGenEmbeddingsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentLongTextToolTextGenEmbeddingsField"',
            });
        }
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiAgentLongTextToolTextGenEmbeddingsField"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        const strategy = val.strategy == void 0
            ? void 0
            : deserializeAiAgentLongTextToolTextGenEmbeddingsStrategyField(val.strategy);
        return {
            model: model,
            strategy: strategy,
        };
    }
    function serializeAiAgentLongTextToolTextGen(val) {
        const base = serializeAiAgentBasicTextToolTextGen(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentLongTextToolTextGen"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['embeddings']: val.embeddings == void 0
                ? val.embeddings
                : serializeAiAgentLongTextToolTextGenEmbeddingsField(val.embeddings),
        });
    }

    function serializeAiAgentBasicGenTool(val) {
        const base = serializeAiAgentLongTextToolTextGen(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentBasicGenTool"',
            });
        }
        return Object.assign(Object.assign({}, base), { ['content_template']: val.contentTemplate });
    }
    function deserializeAiAgentBasicGenTool(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentBasicGenTool"',
            });
        }
        if (!(val.content_template == void 0) && !sdIsString(val.content_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_template" of type "AiAgentBasicGenTool"',
            });
        }
        const contentTemplate = val.content_template == void 0 ? void 0 : val.content_template;
        const embeddings = val.embeddings == void 0
            ? void 0
            : deserializeAiAgentLongTextToolTextGenEmbeddingsField(val.embeddings);
        if (!(val.system_message == void 0) && !sdIsString(val.system_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "system_message" of type "AiAgentBasicGenTool"',
            });
        }
        const systemMessage = val.system_message == void 0 ? void 0 : val.system_message;
        if (!(val.prompt_template == void 0) && !sdIsString(val.prompt_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prompt_template" of type "AiAgentBasicGenTool"',
            });
        }
        const promptTemplate = val.prompt_template == void 0 ? void 0 : val.prompt_template;
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiAgentBasicGenTool"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiAgentBasicGenTool"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            contentTemplate: contentTemplate,
            embeddings: embeddings,
            systemMessage: systemMessage,
            promptTemplate: promptTemplate,
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function serializeAiAgentTextGenTypeField(val) {
        return val;
    }
    function deserializeAiAgentTextGenTypeField(val) {
        if (val == 'ai_agent_text_gen') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiAgentTextGenTypeField",
        });
    }
    function serializeAiAgentTextGen(val) {
        return {
            ['type']: serializeAiAgentTextGenTypeField(val.type),
            ['basic_gen']: val.basicGen == void 0
                ? val.basicGen
                : serializeAiAgentBasicGenTool(val.basicGen),
        };
    }
    function deserializeAiAgentTextGen(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiAgentTextGen"' });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiAgentTextGen" to be defined',
            });
        }
        const type = deserializeAiAgentTextGenTypeField(val.type);
        const basicGen = val.basic_gen == void 0
            ? void 0
            : deserializeAiAgentBasicGenTool(val.basic_gen);
        return { type: type, basicGen: basicGen };
    }

    function serializeAiAgentReferenceOrAiAgentTextGen(val) {
        if (val.type == 'ai_agent_id') {
            return serializeAiAgentReference(val);
        }
        if (val.type == 'ai_agent_text_gen') {
            return serializeAiAgentTextGen(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }

    function serializeAiTextGenItemsTypeField(val) {
        return val;
    }
    function serializeAiTextGenItemsField(val) {
        return {
            ['id']: val.id,
            ['type']: serializeAiTextGenItemsTypeField(val.type),
            ['content']: val.content,
        };
    }
    function serializeAiTextGen(val) {
        return {
            ['prompt']: val.prompt,
            ['items']: val.items.map(function (item) {
                return serializeAiTextGenItemsField(item);
            }),
            ['dialogue_history']: val.dialogueHistory == void 0
                ? val.dialogueHistory
                : val.dialogueHistory.map(function (item) {
                    return serializeAiDialogueHistory(item);
                }),
            ['ai_agent']: val.aiAgent == void 0
                ? val.aiAgent
                : serializeAiAgentReferenceOrAiAgentTextGen(val.aiAgent),
        };
    }

    function serializeAiAgentExtractTypeField(val) {
        return val;
    }
    function deserializeAiAgentExtractTypeField(val) {
        if (val == 'ai_agent_extract') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiAgentExtractTypeField",
        });
    }
    function serializeAiAgentExtract(val) {
        return {
            ['type']: serializeAiAgentExtractTypeField(val.type),
            ['long_text']: val.longText == void 0
                ? val.longText
                : serializeAiAgentLongTextTool(val.longText),
            ['basic_text']: val.basicText == void 0
                ? val.basicText
                : serializeAiAgentBasicTextTool(val.basicText),
            ['basic_image']: val.basicImage == void 0
                ? val.basicImage
                : serializeAiAgentBasicTextTool(val.basicImage),
        };
    }
    function deserializeAiAgentExtract(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "AiAgentExtract"' });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiAgentExtract" to be defined',
            });
        }
        const type = deserializeAiAgentExtractTypeField(val.type);
        const longText = val.long_text == void 0
            ? void 0
            : deserializeAiAgentLongTextTool(val.long_text);
        const basicText = val.basic_text == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_text);
        const basicImage = val.basic_image == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_image);
        return {
            type: type,
            longText: longText,
            basicText: basicText,
            basicImage: basicImage,
        };
    }

    function serializeAiAgentExtractStructuredTypeField(val) {
        return val;
    }
    function deserializeAiAgentExtractStructuredTypeField(val) {
        if (val == 'ai_agent_extract_structured') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiAgentExtractStructuredTypeField",
        });
    }
    function serializeAiAgentExtractStructured(val) {
        return {
            ['type']: serializeAiAgentExtractStructuredTypeField(val.type),
            ['long_text']: val.longText == void 0
                ? val.longText
                : serializeAiAgentLongTextTool(val.longText),
            ['basic_text']: val.basicText == void 0
                ? val.basicText
                : serializeAiAgentBasicTextTool(val.basicText),
            ['basic_image']: val.basicImage == void 0
                ? val.basicImage
                : serializeAiAgentBasicTextTool(val.basicImage),
        };
    }
    function deserializeAiAgentExtractStructured(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentExtractStructured"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiAgentExtractStructured" to be defined',
            });
        }
        const type = deserializeAiAgentExtractStructuredTypeField(val.type);
        const longText = val.long_text == void 0
            ? void 0
            : deserializeAiAgentLongTextTool(val.long_text);
        const basicText = val.basic_text == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_text);
        const basicImage = val.basic_image == void 0
            ? void 0
            : deserializeAiAgentBasicTextTool(val.basic_image);
        return {
            type: type,
            longText: longText,
            basicText: basicText,
            basicImage: basicImage,
        };
    }

    function deserializeAiAgentAskOrAiAgentExtractOrAiAgentExtractStructuredOrAiAgentTextGen(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentAskOrAiAgentExtractOrAiAgentExtractStructuredOrAiAgentTextGen"',
            });
        }
        if (val.type == 'ai_agent_ask') {
            return deserializeAiAgentAsk(val);
        }
        if (val.type == 'ai_agent_extract') {
            return deserializeAiAgentExtract(val);
        }
        if (val.type == 'ai_agent_extract_structured') {
            return deserializeAiAgentExtractStructured(val);
        }
        if (val.type == 'ai_agent_text_gen') {
            return deserializeAiAgentTextGen(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiAgentAskOrAiAgentExtractOrAiAgentExtractStructuredOrAiAgentTextGen",
        });
    }

    function serializeAiItemBaseTypeField(val) {
        return val;
    }
    function serializeAiItemBase(val) {
        return {
            ['id']: val.id,
            ['type']: serializeAiItemBaseTypeField(val.type),
            ['content']: val.content,
        };
    }

    function serializeAiAgentExtractOrAiAgentReference(val) {
        if (val.type == 'ai_agent_extract') {
            return serializeAiAgentExtract(val);
        }
        if (val.type == 'ai_agent_id') {
            return serializeAiAgentReference(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }

    function serializeAiExtract(val) {
        return {
            ['prompt']: val.prompt,
            ['items']: val.items.map(function (item) {
                return serializeAiItemBase(item);
            }),
            ['ai_agent']: val.aiAgent == void 0
                ? val.aiAgent
                : serializeAiAgentExtractOrAiAgentReference(val.aiAgent),
        };
    }

    function deserializeAiExtractResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiExtractResponse"',
            });
        }
        return {};
    }

    function deserializeAiExtractStructuredResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiExtractStructuredResponse"',
            });
        }
        if (val.answer == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "answer" of type "AiExtractStructuredResponse" to be defined',
            });
        }
        const answer = deserializeAiExtractResponse(val.answer);
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "AiExtractStructuredResponse" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "AiExtractStructuredResponse"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (!(val.completion_reason == void 0) &&
            !sdIsString(val.completion_reason)) {
            throw new BoxSdkError({
                message: 'Expecting string for "completion_reason" of type "AiExtractStructuredResponse"',
            });
        }
        const completionReason = val.completion_reason == void 0 ? void 0 : val.completion_reason;
        const aiAgentInfo = val.ai_agent_info == void 0
            ? void 0
            : deserializeAiAgentInfo(val.ai_agent_info);
        return {
            answer: answer,
            createdAt: createdAt,
            completionReason: completionReason,
            aiAgentInfo: aiAgentInfo,
        };
    }

    function serializeAiAgentExtractStructuredOrAiAgentReference(val) {
        if (val.type == 'ai_agent_extract_structured') {
            return serializeAiAgentExtractStructured(val);
        }
        if (val.type == 'ai_agent_id') {
            return serializeAiAgentReference(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }

    function serializeAiExtractStructuredMetadataTemplateTypeField(val) {
        return val;
    }
    function serializeAiExtractStructuredMetadataTemplateField(val) {
        return {
            ['template_key']: val.templateKey,
            ['type']: val.type == void 0
                ? val.type
                : serializeAiExtractStructuredMetadataTemplateTypeField(val.type),
            ['scope']: val.scope,
        };
    }
    function serializeAiExtractStructuredFieldsOptionsField(val) {
        return { ['key']: val.key };
    }
    function serializeAiExtractStructuredFieldsField(val) {
        return {
            ['key']: val.key,
            ['description']: val.description,
            ['displayName']: val.displayName,
            ['prompt']: val.prompt,
            ['type']: val.type,
            ['options']: val.options == void 0
                ? val.options
                : val.options.map(function (item) {
                    return serializeAiExtractStructuredFieldsOptionsField(item);
                }),
        };
    }
    function serializeAiExtractStructured(val) {
        return {
            ['items']: val.items.map(function (item) {
                return serializeAiItemBase(item);
            }),
            ['metadata_template']: val.metadataTemplate == void 0
                ? val.metadataTemplate
                : serializeAiExtractStructuredMetadataTemplateField(val.metadataTemplate),
            ['fields']: val.fields == void 0
                ? val.fields
                : val.fields.map(function (item) {
                    return serializeAiExtractStructuredFieldsField(item);
                }),
            ['ai_agent']: val.aiAgent == void 0
                ? val.aiAgent
                : serializeAiAgentExtractStructuredOrAiAgentReference(val.aiAgent),
        };
    }

    class CreateAiAskOptionals {
        constructor(fields) {
            this.headers = new CreateAiAskHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateAiTextGenOptionals {
        constructor(fields) {
            this.headers = new CreateAiTextGenHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetAiAgentDefaultConfigOptionals {
        constructor(fields) {
            this.headers = new GetAiAgentDefaultConfigHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateAiExtractOptionals {
        constructor(fields) {
            this.headers = new CreateAiExtractHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateAiExtractStructuredOptionals {
        constructor(fields) {
            this.headers = new CreateAiExtractStructuredHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateAiAskHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateAiTextGenHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetAiAgentDefaultConfigHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateAiExtractHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateAiExtractStructuredHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AiManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Sends an AI request to supported LLMs and returns an answer specifically focused on the user's question given the provided context.
         * @param {AiAsk} requestBody Request body of createAiAsk method
         * @param {CreateAiAskOptionalsInput} optionalsInput
         * @returns {Promise<undefined | AiResponseFull>}
         */
        createAiAsk(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateAiAskOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai/ask'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAiAsk(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                if (toString(response.status) == '204') {
                    return void 0;
                }
                return Object.assign(Object.assign({}, deserializeAiResponseFull(response.data)), { rawData: response.data });
            });
        }
        /**
         * Sends an AI request to supported Large Language Models (LLMs) and returns generated text based on the provided prompt.
         * @param {AiTextGen} requestBody Request body of createAiTextGen method
         * @param {CreateAiTextGenOptionalsInput} optionalsInput
         * @returns {Promise<AiResponse>}
         */
        createAiTextGen(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateAiTextGenOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai/text_gen'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAiTextGen(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiResponse(response.data)), { rawData: response.data });
            });
        }
        /**
         * Get the AI agent default config.
         * @param {GetAiAgentDefaultConfigQueryParams} queryParams Query parameters of getAiAgentDefaultConfig method
         * @param {GetAiAgentDefaultConfigOptionalsInput} optionalsInput
         * @returns {Promise<AiAgentAskOrAiAgentExtractOrAiAgentExtractStructuredOrAiAgentTextGen>}
         */
        getAiAgentDefaultConfig(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetAiAgentDefaultConfigOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['mode']: toString(queryParams.mode),
                    ['language']: toString(queryParams.language),
                    ['model']: toString(queryParams.model),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai_agent_default'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiAgentAskOrAiAgentExtractOrAiAgentExtractStructuredOrAiAgentTextGen(response.data)), { rawData: response.data });
            });
        }
        /**
         * Sends an AI request to supported Large Language Models (LLMs) and extracts metadata in form of key-value pairs.
         * In this request, both the prompt and the output can be freeform.
         * Metadata template setup before sending the request is not required.
         * @param {AiExtract} requestBody Request body of createAiExtract method
         * @param {CreateAiExtractOptionalsInput} optionalsInput
         * @returns {Promise<AiResponse>}
         */
        createAiExtract(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateAiExtractOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai/extract'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAiExtract(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiResponse(response.data)), { rawData: response.data });
            });
        }
        /**
         * Sends an AI request to supported Large Language Models (LLMs) and returns extracted metadata as a set of key-value pairs.
         * For this request, you either need a metadata template or a list of fields you want to extract.
         * Input is **either** a metadata template or a list of fields to ensure the structure.
         * To learn more about creating templates, see [Creating metadata templates in the Admin Console](https://support.box.com/hc/en-us/articles/360044194033-Customizing-Metadata-Templates)
         * or use the [metadata template API](g://metadata/templates/create).
         * @param {AiExtractStructured} requestBody Request body of createAiExtractStructured method
         * @param {CreateAiExtractStructuredOptionalsInput} optionalsInput
         * @returns {Promise<AiExtractStructuredResponse>}
         */
        createAiExtractStructured(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateAiExtractStructuredOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai/extract_structured'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeAiExtractStructured(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiExtractStructuredResponse(response.data)), { rawData: response.data });
            });
        }
    }

    function serializeAiAgentAllowedEntity(val) {
        if (val.type == 'user') {
            return serializeUserBase(val);
        }
        if (val.type == 'group') {
            return serializeGroupBase(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }
    function deserializeAiAgentAllowedEntity(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiAgentAllowedEntity"',
            });
        }
        if (val.type == 'user') {
            return deserializeUserBase(val);
        }
        if (val.type == 'group') {
            return deserializeGroupBase(val);
        }
        throw new BoxSdkError({ message: "Can't deserialize AiAgentAllowedEntity" });
    }

    function deserializeAiSingleAgentResponseTypeField(val) {
        if (val == 'ai_agent') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiSingleAgentResponseTypeField",
        });
    }

    function serializeAiStudioAgentLongTextTool(val) {
        const base = serializeAiAgentLongTextTool(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentLongTextTool"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['is_custom_instructions_included']: val.isCustomInstructionsIncluded,
        });
    }

    function deserializeAiStudioAgentLongTextToolResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentLongTextToolResponse"',
            });
        }
        if (!(val.warnings == void 0) && !sdIsList(val.warnings)) {
            throw new BoxSdkError({
                message: 'Expecting array for "warnings" of type "AiStudioAgentLongTextToolResponse"',
            });
        }
        const warnings = val.warnings == void 0
            ? void 0
            : sdIsList(val.warnings)
                ? val.warnings.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "AiStudioAgentLongTextToolResponse"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.is_custom_instructions_included == void 0) &&
            !sdIsBoolean(val.is_custom_instructions_included)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_custom_instructions_included" of type "AiStudioAgentLongTextToolResponse"',
            });
        }
        const isCustomInstructionsIncluded = val.is_custom_instructions_included == void 0
            ? void 0
            : val.is_custom_instructions_included;
        const embeddings = val.embeddings == void 0
            ? void 0
            : deserializeAiAgentLongTextToolEmbeddingsField(val.embeddings);
        if (!(val.system_message == void 0) && !sdIsString(val.system_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "system_message" of type "AiStudioAgentLongTextToolResponse"',
            });
        }
        const systemMessage = val.system_message == void 0 ? void 0 : val.system_message;
        if (!(val.prompt_template == void 0) && !sdIsString(val.prompt_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prompt_template" of type "AiStudioAgentLongTextToolResponse"',
            });
        }
        const promptTemplate = val.prompt_template == void 0 ? void 0 : val.prompt_template;
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiStudioAgentLongTextToolResponse"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiStudioAgentLongTextToolResponse"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            warnings: warnings,
            isCustomInstructionsIncluded: isCustomInstructionsIncluded,
            embeddings: embeddings,
            systemMessage: systemMessage,
            promptTemplate: promptTemplate,
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function serializeAiStudioAgentBasicTextTool(val) {
        const base = serializeAiAgentBasicTextTool(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentBasicTextTool"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['is_custom_instructions_included']: val.isCustomInstructionsIncluded,
        });
    }

    function deserializeAiStudioAgentBasicTextToolResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentBasicTextToolResponse"',
            });
        }
        if (!(val.warnings == void 0) && !sdIsList(val.warnings)) {
            throw new BoxSdkError({
                message: 'Expecting array for "warnings" of type "AiStudioAgentBasicTextToolResponse"',
            });
        }
        const warnings = val.warnings == void 0
            ? void 0
            : sdIsList(val.warnings)
                ? val.warnings.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "AiStudioAgentBasicTextToolResponse"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.is_custom_instructions_included == void 0) &&
            !sdIsBoolean(val.is_custom_instructions_included)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_custom_instructions_included" of type "AiStudioAgentBasicTextToolResponse"',
            });
        }
        const isCustomInstructionsIncluded = val.is_custom_instructions_included == void 0
            ? void 0
            : val.is_custom_instructions_included;
        if (!(val.system_message == void 0) && !sdIsString(val.system_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "system_message" of type "AiStudioAgentBasicTextToolResponse"',
            });
        }
        const systemMessage = val.system_message == void 0 ? void 0 : val.system_message;
        if (!(val.prompt_template == void 0) && !sdIsString(val.prompt_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prompt_template" of type "AiStudioAgentBasicTextToolResponse"',
            });
        }
        const promptTemplate = val.prompt_template == void 0 ? void 0 : val.prompt_template;
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiStudioAgentBasicTextToolResponse"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiStudioAgentBasicTextToolResponse"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            warnings: warnings,
            isCustomInstructionsIncluded: isCustomInstructionsIncluded,
            systemMessage: systemMessage,
            promptTemplate: promptTemplate,
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function serializeAiStudioAgentSpreadsheetTool(val) {
        const base = serializeAiAgentSpreadsheetTool(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentSpreadsheetTool"',
            });
        }
        return Object.assign(Object.assign({}, base), {});
    }

    function deserializeAiStudioAgentSpreadsheetToolResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentSpreadsheetToolResponse"',
            });
        }
        if (!(val.warnings == void 0) && !sdIsList(val.warnings)) {
            throw new BoxSdkError({
                message: 'Expecting array for "warnings" of type "AiStudioAgentSpreadsheetToolResponse"',
            });
        }
        const warnings = val.warnings == void 0
            ? void 0
            : sdIsList(val.warnings)
                ? val.warnings.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "AiStudioAgentSpreadsheetToolResponse"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiStudioAgentSpreadsheetToolResponse"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiStudioAgentSpreadsheetToolResponse"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            warnings: warnings,
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function deserializeAiStudioAgentAskResponseTypeField(val) {
        if (val == 'ai_agent_ask') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiStudioAgentAskResponseTypeField",
        });
    }
    function deserializeAiStudioAgentAskResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentAskResponse"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiStudioAgentAskResponse" to be defined',
            });
        }
        const type = deserializeAiStudioAgentAskResponseTypeField(val.type);
        if (val.access_state == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "access_state" of type "AiStudioAgentAskResponse" to be defined',
            });
        }
        if (!sdIsString(val.access_state)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_state" of type "AiStudioAgentAskResponse"',
            });
        }
        const accessState = val.access_state;
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "AiStudioAgentAskResponse" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "AiStudioAgentAskResponse"',
            });
        }
        const description = val.description;
        if (!(val.custom_instructions == void 0) &&
            !sdIsString(val.custom_instructions)) {
            throw new BoxSdkError({
                message: 'Expecting string for "custom_instructions" of type "AiStudioAgentAskResponse"',
            });
        }
        const customInstructions = val.custom_instructions == void 0 ? void 0 : val.custom_instructions;
        if (!(val.suggested_questions == void 0) &&
            !sdIsList(val.suggested_questions)) {
            throw new BoxSdkError({
                message: 'Expecting array for "suggested_questions" of type "AiStudioAgentAskResponse"',
            });
        }
        const suggestedQuestions = val.suggested_questions == void 0
            ? void 0
            : sdIsList(val.suggested_questions)
                ? val.suggested_questions.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "AiStudioAgentAskResponse"',
                        });
                    }
                    return itm;
                })
                : [];
        const longText = val.long_text == void 0
            ? void 0
            : deserializeAiStudioAgentLongTextToolResponse(val.long_text);
        const basicText = val.basic_text == void 0
            ? void 0
            : deserializeAiStudioAgentBasicTextToolResponse(val.basic_text);
        const basicImage = val.basic_image == void 0
            ? void 0
            : deserializeAiStudioAgentBasicTextToolResponse(val.basic_image);
        const spreadsheet = val.spreadsheet == void 0
            ? void 0
            : deserializeAiStudioAgentSpreadsheetToolResponse(val.spreadsheet);
        const longTextMulti = val.long_text_multi == void 0
            ? void 0
            : deserializeAiStudioAgentLongTextToolResponse(val.long_text_multi);
        const basicTextMulti = val.basic_text_multi == void 0
            ? void 0
            : deserializeAiStudioAgentBasicTextToolResponse(val.basic_text_multi);
        const basicImageMulti = val.basic_image_multi == void 0
            ? void 0
            : deserializeAiStudioAgentBasicTextToolResponse(val.basic_image_multi);
        return {
            type: type,
            accessState: accessState,
            description: description,
            customInstructions: customInstructions,
            suggestedQuestions: suggestedQuestions,
            longText: longText,
            basicText: basicText,
            basicImage: basicImage,
            spreadsheet: spreadsheet,
            longTextMulti: longTextMulti,
            basicTextMulti: basicTextMulti,
            basicImageMulti: basicImageMulti,
        };
    }

    function serializeAiStudioAgentBasicGenTool(val) {
        const base = serializeAiAgentBasicGenTool(val);
        if (!sdIsMap(base)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentBasicGenTool"',
            });
        }
        return Object.assign(Object.assign({}, base), {
            ['is_custom_instructions_included']: val.isCustomInstructionsIncluded,
        });
    }

    function deserializeAiStudioAgentBasicGenToolResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentBasicGenToolResponse"',
            });
        }
        if (!(val.warnings == void 0) && !sdIsList(val.warnings)) {
            throw new BoxSdkError({
                message: 'Expecting array for "warnings" of type "AiStudioAgentBasicGenToolResponse"',
            });
        }
        const warnings = val.warnings == void 0
            ? void 0
            : sdIsList(val.warnings)
                ? val.warnings.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "AiStudioAgentBasicGenToolResponse"',
                        });
                    }
                    return itm;
                })
                : [];
        if (!(val.is_custom_instructions_included == void 0) &&
            !sdIsBoolean(val.is_custom_instructions_included)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_custom_instructions_included" of type "AiStudioAgentBasicGenToolResponse"',
            });
        }
        const isCustomInstructionsIncluded = val.is_custom_instructions_included == void 0
            ? void 0
            : val.is_custom_instructions_included;
        if (!(val.content_template == void 0) && !sdIsString(val.content_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "content_template" of type "AiStudioAgentBasicGenToolResponse"',
            });
        }
        const contentTemplate = val.content_template == void 0 ? void 0 : val.content_template;
        const embeddings = val.embeddings == void 0
            ? void 0
            : deserializeAiAgentLongTextToolTextGenEmbeddingsField(val.embeddings);
        if (!(val.system_message == void 0) && !sdIsString(val.system_message)) {
            throw new BoxSdkError({
                message: 'Expecting string for "system_message" of type "AiStudioAgentBasicGenToolResponse"',
            });
        }
        const systemMessage = val.system_message == void 0 ? void 0 : val.system_message;
        if (!(val.prompt_template == void 0) && !sdIsString(val.prompt_template)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prompt_template" of type "AiStudioAgentBasicGenToolResponse"',
            });
        }
        const promptTemplate = val.prompt_template == void 0 ? void 0 : val.prompt_template;
        if (!(val.model == void 0) && !sdIsString(val.model)) {
            throw new BoxSdkError({
                message: 'Expecting string for "model" of type "AiStudioAgentBasicGenToolResponse"',
            });
        }
        const model = val.model == void 0 ? void 0 : val.model;
        if (!(val.num_tokens_for_completion == void 0) &&
            !sdIsNumber(val.num_tokens_for_completion)) {
            throw new BoxSdkError({
                message: 'Expecting number for "num_tokens_for_completion" of type "AiStudioAgentBasicGenToolResponse"',
            });
        }
        const numTokensForCompletion = val.num_tokens_for_completion == void 0
            ? void 0
            : val.num_tokens_for_completion;
        const llmEndpointParams = val.llm_endpoint_params == void 0
            ? void 0
            : deserializeAiLlmEndpointParams(val.llm_endpoint_params);
        return {
            warnings: warnings,
            isCustomInstructionsIncluded: isCustomInstructionsIncluded,
            contentTemplate: contentTemplate,
            embeddings: embeddings,
            systemMessage: systemMessage,
            promptTemplate: promptTemplate,
            model: model,
            numTokensForCompletion: numTokensForCompletion,
            llmEndpointParams: llmEndpointParams,
        };
    }

    function deserializeAiStudioAgentTextGenResponseTypeField(val) {
        if (val == 'ai_agent_text_gen') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiStudioAgentTextGenResponseTypeField",
        });
    }
    function deserializeAiStudioAgentTextGenResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentTextGenResponse"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiStudioAgentTextGenResponse" to be defined',
            });
        }
        const type = deserializeAiStudioAgentTextGenResponseTypeField(val.type);
        if (val.access_state == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "access_state" of type "AiStudioAgentTextGenResponse" to be defined',
            });
        }
        if (!sdIsString(val.access_state)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_state" of type "AiStudioAgentTextGenResponse"',
            });
        }
        const accessState = val.access_state;
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "AiStudioAgentTextGenResponse" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "AiStudioAgentTextGenResponse"',
            });
        }
        const description = val.description;
        if (!(val.custom_instructions == void 0) &&
            !sdIsString(val.custom_instructions)) {
            throw new BoxSdkError({
                message: 'Expecting string for "custom_instructions" of type "AiStudioAgentTextGenResponse"',
            });
        }
        const customInstructions = val.custom_instructions == void 0 ? void 0 : val.custom_instructions;
        if (!(val.suggested_questions == void 0) &&
            !sdIsList(val.suggested_questions)) {
            throw new BoxSdkError({
                message: 'Expecting array for "suggested_questions" of type "AiStudioAgentTextGenResponse"',
            });
        }
        const suggestedQuestions = val.suggested_questions == void 0
            ? void 0
            : sdIsList(val.suggested_questions)
                ? val.suggested_questions.map(function (itm) {
                    if (!sdIsString(itm)) {
                        throw new BoxSdkError({
                            message: 'Expecting string for "AiStudioAgentTextGenResponse"',
                        });
                    }
                    return itm;
                })
                : [];
        const basicGen = val.basic_gen == void 0
            ? void 0
            : deserializeAiStudioAgentBasicGenToolResponse(val.basic_gen);
        return {
            type: type,
            accessState: accessState,
            description: description,
            customInstructions: customInstructions,
            suggestedQuestions: suggestedQuestions,
            basicGen: basicGen,
        };
    }

    function deserializeAiStudioAgentExtractResponseTypeField(val) {
        if (val == 'ai_agent_extract') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize AiStudioAgentExtractResponseTypeField",
        });
    }
    function deserializeAiStudioAgentExtractResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiStudioAgentExtractResponse"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "AiStudioAgentExtractResponse" to be defined',
            });
        }
        const type = deserializeAiStudioAgentExtractResponseTypeField(val.type);
        if (val.access_state == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "access_state" of type "AiStudioAgentExtractResponse" to be defined',
            });
        }
        if (!sdIsString(val.access_state)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_state" of type "AiStudioAgentExtractResponse"',
            });
        }
        const accessState = val.access_state;
        if (val.description == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "description" of type "AiStudioAgentExtractResponse" to be defined',
            });
        }
        if (!sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "AiStudioAgentExtractResponse"',
            });
        }
        const description = val.description;
        if (!(val.custom_instructions == void 0) &&
            !sdIsString(val.custom_instructions)) {
            throw new BoxSdkError({
                message: 'Expecting string for "custom_instructions" of type "AiStudioAgentExtractResponse"',
            });
        }
        const customInstructions = val.custom_instructions == void 0 ? void 0 : val.custom_instructions;
        const longText = val.long_text == void 0
            ? void 0
            : deserializeAiStudioAgentLongTextToolResponse(val.long_text);
        const basicText = val.basic_text == void 0
            ? void 0
            : deserializeAiStudioAgentBasicTextToolResponse(val.basic_text);
        const basicImage = val.basic_image == void 0
            ? void 0
            : deserializeAiStudioAgentBasicTextToolResponse(val.basic_image);
        return {
            type: type,
            accessState: accessState,
            description: description,
            customInstructions: customInstructions,
            longText: longText,
            basicText: basicText,
            basicImage: basicImage,
        };
    }

    function deserializeAiSingleAgentResponseFull(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiSingleAgentResponseFull"',
            });
        }
        const ask = val.ask == void 0 ? void 0 : deserializeAiStudioAgentAskResponse(val.ask);
        const textGen = val.text_gen == void 0
            ? void 0
            : deserializeAiStudioAgentTextGenResponse(val.text_gen);
        const extract = val.extract == void 0
            ? void 0
            : deserializeAiStudioAgentExtractResponse(val.extract);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "AiSingleAgentResponseFull" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "AiSingleAgentResponseFull"',
            });
        }
        const id = val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeAiSingleAgentResponseTypeField(val.type);
        if (val.origin == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "origin" of type "AiSingleAgentResponseFull" to be defined',
            });
        }
        if (!sdIsString(val.origin)) {
            throw new BoxSdkError({
                message: 'Expecting string for "origin" of type "AiSingleAgentResponseFull"',
            });
        }
        const origin = val.origin;
        if (val.name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "name" of type "AiSingleAgentResponseFull" to be defined',
            });
        }
        if (!sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "AiSingleAgentResponseFull"',
            });
        }
        const name = val.name;
        if (val.access_state == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "access_state" of type "AiSingleAgentResponseFull" to be defined',
            });
        }
        if (!sdIsString(val.access_state)) {
            throw new BoxSdkError({
                message: 'Expecting string for "access_state" of type "AiSingleAgentResponseFull"',
            });
        }
        const accessState = val.access_state;
        const createdBy = val.created_by == void 0 ? void 0 : deserializeUserBase(val.created_by);
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "AiSingleAgentResponseFull"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        const modifiedBy = val.modified_by == void 0 ? void 0 : deserializeUserBase(val.modified_by);
        if (!(val.modified_at == void 0) && !sdIsString(val.modified_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "modified_at" of type "AiSingleAgentResponseFull"',
            });
        }
        const modifiedAt = val.modified_at == void 0 ? void 0 : dateTimeFromString(val.modified_at);
        if (!(val.icon_reference == void 0) && !sdIsString(val.icon_reference)) {
            throw new BoxSdkError({
                message: 'Expecting string for "icon_reference" of type "AiSingleAgentResponseFull"',
            });
        }
        const iconReference = val.icon_reference == void 0 ? void 0 : val.icon_reference;
        if (!(val.allowed_entities == void 0) && !sdIsList(val.allowed_entities)) {
            throw new BoxSdkError({
                message: 'Expecting array for "allowed_entities" of type "AiSingleAgentResponseFull"',
            });
        }
        const allowedEntities = val.allowed_entities == void 0
            ? void 0
            : sdIsList(val.allowed_entities)
                ? val.allowed_entities.map(function (itm) {
                    return deserializeAiAgentAllowedEntity(itm);
                })
                : [];
        return {
            ask: ask,
            textGen: textGen,
            extract: extract,
            id: id,
            type: type,
            origin: origin,
            name: name,
            accessState: accessState,
            createdBy: createdBy,
            createdAt: createdAt,
            modifiedBy: modifiedBy,
            modifiedAt: modifiedAt,
            iconReference: iconReference,
            allowedEntities: allowedEntities,
        };
    }

    function deserializeAiMultipleAgentResponse(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "AiMultipleAgentResponse"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "AiMultipleAgentResponse"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "AiMultipleAgentResponse"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "AiMultipleAgentResponse"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (val.entries == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "entries" of type "AiMultipleAgentResponse" to be defined',
            });
        }
        if (!sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "AiMultipleAgentResponse"',
            });
        }
        const entries = sdIsList(val.entries)
            ? val.entries.map(function (itm) {
                return deserializeAiSingleAgentResponseFull(itm);
            })
            : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function serializeAiStudioAgentAskTypeField(val) {
        return val;
    }
    function serializeAiStudioAgentAsk(val) {
        return {
            ['type']: serializeAiStudioAgentAskTypeField(val.type),
            ['access_state']: val.accessState,
            ['description']: val.description,
            ['custom_instructions']: val.customInstructions,
            ['suggested_questions']: val.suggestedQuestions == void 0
                ? val.suggestedQuestions
                : val.suggestedQuestions.map(function (item) {
                    return item;
                }),
            ['long_text']: val.longText == void 0
                ? val.longText
                : serializeAiStudioAgentLongTextTool(val.longText),
            ['basic_text']: val.basicText == void 0
                ? val.basicText
                : serializeAiStudioAgentBasicTextTool(val.basicText),
            ['basic_image']: val.basicImage == void 0
                ? val.basicImage
                : serializeAiStudioAgentBasicTextTool(val.basicImage),
            ['spreadsheet']: val.spreadsheet == void 0
                ? val.spreadsheet
                : serializeAiStudioAgentSpreadsheetTool(val.spreadsheet),
            ['long_text_multi']: val.longTextMulti == void 0
                ? val.longTextMulti
                : serializeAiStudioAgentLongTextTool(val.longTextMulti),
            ['basic_text_multi']: val.basicTextMulti == void 0
                ? val.basicTextMulti
                : serializeAiStudioAgentBasicTextTool(val.basicTextMulti),
            ['basic_image_multi']: val.basicImageMulti == void 0
                ? val.basicImageMulti
                : serializeAiStudioAgentBasicTextTool(val.basicImageMulti),
        };
    }

    function serializeAiStudioAgentTextGenTypeField(val) {
        return val;
    }
    function serializeAiStudioAgentTextGen(val) {
        return {
            ['type']: serializeAiStudioAgentTextGenTypeField(val.type),
            ['access_state']: val.accessState,
            ['description']: val.description,
            ['custom_instructions']: val.customInstructions,
            ['suggested_questions']: val.suggestedQuestions == void 0
                ? val.suggestedQuestions
                : val.suggestedQuestions.map(function (item) {
                    return item;
                }),
            ['basic_gen']: val.basicGen == void 0
                ? val.basicGen
                : serializeAiStudioAgentBasicGenTool(val.basicGen),
        };
    }

    function serializeAiStudioAgentExtractTypeField(val) {
        return val;
    }
    function serializeAiStudioAgentExtract(val) {
        return {
            ['type']: serializeAiStudioAgentExtractTypeField(val.type),
            ['access_state']: val.accessState,
            ['description']: val.description,
            ['custom_instructions']: val.customInstructions,
            ['long_text']: val.longText == void 0
                ? val.longText
                : serializeAiStudioAgentLongTextTool(val.longText),
            ['basic_text']: val.basicText == void 0
                ? val.basicText
                : serializeAiStudioAgentBasicTextTool(val.basicText),
            ['basic_image']: val.basicImage == void 0
                ? val.basicImage
                : serializeAiStudioAgentBasicTextTool(val.basicImage),
        };
    }

    class CreateAiAgent {
        constructor(fields) {
            /**
             * The type of agent used to handle queries. */
            this.type = 'ai_agent';
            if (fields.type !== undefined) {
                this.type = fields.type;
            }
            if (fields.name !== undefined) {
                this.name = fields.name;
            }
            if (fields.accessState !== undefined) {
                this.accessState = fields.accessState;
            }
            if (fields.iconReference !== undefined) {
                this.iconReference = fields.iconReference;
            }
            if (fields.allowedEntities !== undefined) {
                this.allowedEntities = fields.allowedEntities;
            }
            if (fields.ask !== undefined) {
                this.ask = fields.ask;
            }
            if (fields.textGen !== undefined) {
                this.textGen = fields.textGen;
            }
            if (fields.extract !== undefined) {
                this.extract = fields.extract;
            }
            if (fields.rawData !== undefined) {
                this.rawData = fields.rawData;
            }
        }
    }
    function serializeCreateAiAgentTypeField(val) {
        return val;
    }
    function serializeCreateAiAgent(val) {
        return {
            ['type']: serializeCreateAiAgentTypeField(val.type),
            ['name']: val.name,
            ['access_state']: val.accessState,
            ['icon_reference']: val.iconReference,
            ['allowed_entities']: val.allowedEntities == void 0
                ? val.allowedEntities
                : val.allowedEntities.map(function (item) {
                    return serializeAiAgentAllowedEntity(item);
                }),
            ['ask']: val.ask == void 0 ? val.ask : serializeAiStudioAgentAsk(val.ask),
            ['text_gen']: val.textGen == void 0
                ? val.textGen
                : serializeAiStudioAgentTextGen(val.textGen),
            ['extract']: val.extract == void 0
                ? val.extract
                : serializeAiStudioAgentExtract(val.extract),
        };
    }

    class CreateAiAgentOptionals {
        constructor(fields) {
            this.headers = new CreateAiAgentHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateAiAgentByIdOptionals {
        constructor(fields) {
            this.headers = new UpdateAiAgentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetAiAgentByIdOptionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetAiAgentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteAiAgentByIdOptionals {
        constructor(fields) {
            this.headers = new DeleteAiAgentByIdHeaders({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetAiAgentsHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateAiAgentHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateAiAgentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetAiAgentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteAiAgentByIdHeaders {
        constructor(fields) {
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class AiStudioManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Lists AI agents based on the provided parameters.
         * @param {GetAiAgentsQueryParams} queryParams Query parameters of getAiAgents method
         * @param {GetAiAgentsHeadersInput} headersInput Headers of getAiAgents method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<AiMultipleAgentResponse>}
         */
        getAiAgents() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetAiAgentsHeaders({}), cancellationToken) {
                const headers = new GetAiAgentsHeaders({
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['mode']: queryParams.mode
                        ? queryParams.mode.map(toString).join(',')
                        : undefined,
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                    ['agent_state']: queryParams.agentState
                        ? queryParams.agentState.map(toString).join(',')
                        : undefined,
                    ['include_box_default']: toString(queryParams.includeBoxDefault),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai_agents'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiMultipleAgentResponse(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates an AI agent. At least one of the following capabilities must be provided: `ask`, `text_gen`, `extract`.
         * @param {CreateAiAgentInput} requestBodyInput Request body of createAiAgent method
         * @param {CreateAiAgentOptionalsInput} optionalsInput
         * @returns {Promise<AiSingleAgentResponseFull>}
         */
        createAiAgent(requestBodyInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBodyInput, optionalsInput = {}) {
                const requestBody = new CreateAiAgent({
                    type: requestBodyInput.type,
                    name: requestBodyInput.name,
                    accessState: requestBodyInput.accessState,
                    iconReference: requestBodyInput.iconReference,
                    allowedEntities: requestBodyInput.allowedEntities,
                    ask: requestBodyInput.ask,
                    textGen: requestBodyInput.textGen,
                    extract: requestBodyInput.extract,
                });
                const optionals = new CreateAiAgentOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai_agents'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateAiAgent(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiSingleAgentResponseFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates an AI agent.
           * @param {string} agentId The ID of the agent to update.
          Example: "1234"
           * @param {CreateAiAgentInput} requestBodyInput Request body of updateAiAgentById method
           * @param {UpdateAiAgentByIdOptionalsInput} optionalsInput
           * @returns {Promise<AiSingleAgentResponseFull>}
           */
        updateAiAgentById(agentId_1, requestBodyInput_1) {
            return __awaiter$1(this, arguments, void 0, function* (agentId, requestBodyInput, optionalsInput = {}) {
                const requestBody = new CreateAiAgent({
                    type: requestBodyInput.type,
                    name: requestBodyInput.name,
                    accessState: requestBodyInput.accessState,
                    iconReference: requestBodyInput.iconReference,
                    allowedEntities: requestBodyInput.allowedEntities,
                    ask: requestBodyInput.ask,
                    textGen: requestBodyInput.textGen,
                    extract: requestBodyInput.extract,
                });
                const optionals = new UpdateAiAgentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai_agents/', toString(agentId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeCreateAiAgent(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiSingleAgentResponseFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Gets an AI Agent using the `agent_id` parameter.
           * @param {string} agentId The agent id to get.
          Example: "1234"
           * @param {GetAiAgentByIdOptionalsInput} optionalsInput
           * @returns {Promise<AiSingleAgentResponseFull>}
           */
        getAiAgentById(agentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (agentId, optionalsInput = {}) {
                const optionals = new GetAiAgentByIdOptionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['fields']: queryParams.fields
                        ? queryParams.fields.map(toString).join(',')
                        : undefined,
                });
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai_agents/', toString(agentId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeAiSingleAgentResponseFull(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes an AI agent using the provided parameters.
           * @param {string} agentId The ID of the agent to delete.
          Example: "1234"
           * @param {DeleteAiAgentByIdOptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteAiAgentById(agentId_1) {
            return __awaiter$1(this, arguments, void 0, function* (agentId, optionalsInput = {}) {
                const optionals = new DeleteAiAgentByIdOptionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({}, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/ai_agents/', toString(agentId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }

    function serializeFileReferenceV2025R0TypeField(val) {
        return val;
    }
    function deserializeFileReferenceV2025R0TypeField(val) {
        if (val == 'file') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileReferenceV2025R0TypeField",
        });
    }
    function serializeFileReferenceV2025R0(val) {
        return {
            ['type']: serializeFileReferenceV2025R0TypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeFileReferenceV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileReferenceV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileReferenceV2025R0" to be defined',
            });
        }
        const type = deserializeFileReferenceV2025R0TypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileReferenceV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileReferenceV2025R0"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }

    function deserializeDocGenTemplateBaseV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenTemplateBaseV2025R0"',
            });
        }
        const file = val.file == void 0 ? void 0 : deserializeFileReferenceV2025R0(val.file);
        return { file: file };
    }

    function serializeDocGenTemplateCreateRequestV2025R0(val) {
        return { ['file']: serializeFileReferenceV2025R0(val.file) };
    }

    function deserializeDocGenTemplateV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenTemplateV2025R0"',
            });
        }
        if (!(val.file_name == void 0) && !sdIsString(val.file_name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "file_name" of type "DocGenTemplateV2025R0"',
            });
        }
        const fileName = val.file_name == void 0 ? void 0 : val.file_name;
        const file = val.file == void 0 ? void 0 : deserializeFileReferenceV2025R0(val.file);
        return { fileName: fileName, file: file };
    }

    function deserializeDocGenTemplatesV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenTemplatesV2025R0"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "DocGenTemplatesV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "DocGenTemplatesV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "DocGenTemplatesV2025R0"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "DocGenTemplatesV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeDocGenTemplateV2025R0(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function deserializeDocGenTagV2025R0TagTypeField(val) {
        if (val == 'text') {
            return val;
        }
        if (val == 'arithmetic') {
            return val;
        }
        if (val == 'conditional') {
            return val;
        }
        if (val == 'for-loop') {
            return val;
        }
        if (val == 'table-loop') {
            return val;
        }
        if (val == 'image') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DocGenTagV2025R0TagTypeField",
        });
    }
    function deserializeDocGenTagV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenTagV2025R0"',
            });
        }
        if (val.tag_content == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "tag_content" of type "DocGenTagV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.tag_content)) {
            throw new BoxSdkError({
                message: 'Expecting string for "tag_content" of type "DocGenTagV2025R0"',
            });
        }
        const tagContent = val.tag_content;
        if (val.tag_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "tag_type" of type "DocGenTagV2025R0" to be defined',
            });
        }
        const tagType = deserializeDocGenTagV2025R0TagTypeField(val.tag_type);
        if (val.json_paths == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "json_paths" of type "DocGenTagV2025R0" to be defined',
            });
        }
        if (!sdIsList(val.json_paths)) {
            throw new BoxSdkError({
                message: 'Expecting array for "json_paths" of type "DocGenTagV2025R0"',
            });
        }
        const jsonPaths = sdIsList(val.json_paths)
            ? val.json_paths.map(function (itm) {
                if (!sdIsString(itm)) {
                    throw new BoxSdkError({
                        message: 'Expecting string for "DocGenTagV2025R0"',
                    });
                }
                return itm;
            })
            : [];
        return {
            tagContent: tagContent,
            tagType: tagType,
            jsonPaths: jsonPaths,
        };
    }

    function deserializeDocGenTagsV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenTagsV2025R0"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "DocGenTagsV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "DocGenTagsV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "DocGenTagsV2025R0"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "DocGenTagsV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeDocGenTagV2025R0(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function deserializeDocGenJobBaseV2025R0TypeField(val) {
        if (val == 'docgen_job') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DocGenJobBaseV2025R0TypeField",
        });
    }

    function deserializeDocGenBatchBaseV2025R0TypeField(val) {
        if (val == 'docgen_batch') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DocGenBatchBaseV2025R0TypeField",
        });
    }
    function deserializeDocGenBatchBaseV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenBatchBaseV2025R0"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "DocGenBatchBaseV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "DocGenBatchBaseV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "DocGenBatchBaseV2025R0" to be defined',
            });
        }
        const type = deserializeDocGenBatchBaseV2025R0TypeField(val.type);
        return { id: id, type: type };
    }

    function serializeFileVersionBaseV2025R0TypeField(val) {
        return val;
    }
    function deserializeFileVersionBaseV2025R0TypeField(val) {
        if (val == 'file_version') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FileVersionBaseV2025R0TypeField",
        });
    }
    function serializeFileVersionBaseV2025R0(val) {
        return {
            ['id']: val.id,
            ['type']: serializeFileVersionBaseV2025R0TypeField(val.type),
        };
    }
    function deserializeFileVersionBaseV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FileVersionBaseV2025R0"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FileVersionBaseV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FileVersionBaseV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FileVersionBaseV2025R0" to be defined',
            });
        }
        const type = deserializeFileVersionBaseV2025R0TypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeDocGenJobV2025R0StatusField(val) {
        if (val == 'submitted') {
            return val;
        }
        if (val == 'completed') {
            return val;
        }
        if (val == 'failed') {
            return val;
        }
        if (val == 'completed_with_error') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize DocGenJobV2025R0StatusField",
        });
    }
    function deserializeDocGenJobV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenJobV2025R0"',
            });
        }
        if (val.batch == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "batch" of type "DocGenJobV2025R0" to be defined',
            });
        }
        const batch = deserializeDocGenBatchBaseV2025R0(val.batch);
        if (val.template_file == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "template_file" of type "DocGenJobV2025R0" to be defined',
            });
        }
        const templateFile = deserializeFileReferenceV2025R0(val.template_file);
        if (val.template_file_version == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "template_file_version" of type "DocGenJobV2025R0" to be defined',
            });
        }
        const templateFileVersion = deserializeFileVersionBaseV2025R0(val.template_file_version);
        const outputFile = val.output_file == void 0
            ? void 0
            : val.output_file == void 0
                ? void 0
                : deserializeFileReferenceV2025R0(val.output_file);
        const outputFileVersion = val.output_file_version == void 0
            ? void 0
            : val.output_file_version == void 0
                ? void 0
                : deserializeFileVersionBaseV2025R0(val.output_file_version);
        if (val.status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "status" of type "DocGenJobV2025R0" to be defined',
            });
        }
        const status = deserializeDocGenJobV2025R0StatusField(val.status);
        if (val.output_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "output_type" of type "DocGenJobV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.output_type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "output_type" of type "DocGenJobV2025R0"',
            });
        }
        const outputType = val.output_type;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "DocGenJobV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "DocGenJobV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "DocGenJobV2025R0" to be defined',
            });
        }
        const type = deserializeDocGenJobBaseV2025R0TypeField(val.type);
        return {
            batch: batch,
            templateFile: templateFile,
            templateFileVersion: templateFileVersion,
            outputFile: outputFile,
            outputFileVersion: outputFileVersion,
            status: status,
            outputType: outputType,
            id: id,
            type: type,
        };
    }

    function deserializeDocGenJobsV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenJobsV2025R0"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "DocGenJobsV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "DocGenJobsV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "DocGenJobsV2025R0"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "DocGenJobsV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeDocGenJobV2025R0(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    class CreateDocgenTemplateV2025R0Optionals {
        constructor(fields) {
            this.headers = new CreateDocgenTemplateV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteDocgenTemplateByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new DeleteDocgenTemplateByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDocgenTemplateByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new GetDocgenTemplateByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDocgenTemplateTagsV2025R0Optionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetDocgenTemplateTagsV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDocgenTemplateJobByIdV2025R0Optionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetDocgenTemplateJobByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateDocgenTemplateV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetDocgenTemplatesV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteDocgenTemplateByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetDocgenTemplateByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetDocgenTemplateTagsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetDocgenTemplateJobByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DocgenTemplateManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Marks a file as a Box Doc Gen template.
         * @param {DocGenTemplateCreateRequestV2025R0} requestBody Request body of createDocgenTemplateV2025R0 method
         * @param {CreateDocgenTemplateV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<DocGenTemplateBaseV2025R0>}
         */
        createDocgenTemplateV2025R0(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateDocgenTemplateV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_templates'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeDocGenTemplateCreateRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenTemplateBaseV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Lists Box Doc Gen templates on which the user is a collaborator.
         * @param {GetDocgenTemplatesV2025R0QueryParams} queryParams Query parameters of getDocgenTemplatesV2025R0 method
         * @param {GetDocgenTemplatesV2025R0HeadersInput} headersInput Headers of getDocgenTemplatesV2025R0 method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<DocGenTemplatesV2025R0>}
         */
        getDocgenTemplatesV2025R0() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetDocgenTemplatesV2025R0Headers({}), cancellationToken) {
                const headers = new GetDocgenTemplatesV2025R0Headers({
                    boxVersion: headersInput.boxVersion,
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_templates'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenTemplatesV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Unmarks file as Box Doc Gen template.
           * @param {string} templateId ID of the file which will no longer be marked as a Box Doc Gen template.
          Example: "123"
           * @param {DeleteDocgenTemplateByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteDocgenTemplateByIdV2025R0(templateId_1) {
            return __awaiter$1(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new DeleteDocgenTemplateByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_templates/', toString(templateId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Lists details of a specific Box Doc Gen template.
           * @param {string} templateId The ID of a Box Doc Gen template.
          Example: 123
           * @param {GetDocgenTemplateByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<DocGenTemplateV2025R0>}
           */
        getDocgenTemplateByIdV2025R0(templateId_1) {
            return __awaiter$1(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new GetDocgenTemplateByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_templates/', toString(templateId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenTemplateV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Lists all tags in a Box Doc Gen template.
           * @param {string} templateId ID of template.
          Example: 123
           * @param {GetDocgenTemplateTagsV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<DocGenTagsV2025R0>}
           */
        getDocgenTemplateTagsV2025R0(templateId_1) {
            return __awaiter$1(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new GetDocgenTemplateTagsV2025R0Optionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['template_version_id']: toString(queryParams.templateVersionId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_templates/', toString(templateId), '/tags'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenTagsV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Lists the users jobs which use this template.
           * @param {string} templateId Id of template to fetch jobs for.
          Example: 123
           * @param {GetDocgenTemplateJobByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<DocGenJobsV2025R0>}
           */
        getDocgenTemplateJobByIdV2025R0(templateId_1) {
            return __awaiter$1(this, arguments, void 0, function* (templateId, optionalsInput = {}) {
                const optionals = new GetDocgenTemplateJobByIdV2025R0Optionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_template_jobs/', toString(templateId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenJobsV2025R0(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeUserBaseV2025R0TypeField(val) {
        if (val == 'user') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize UserBaseV2025R0TypeField",
        });
    }
    function deserializeUserBaseV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserBaseV2025R0"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserBaseV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserBaseV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserBaseV2025R0" to be defined',
            });
        }
        const type = deserializeUserBaseV2025R0TypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeEnterpriseReferenceV2025R0TypeField(val) {
        if (val == 'enterprise') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize EnterpriseReferenceV2025R0TypeField",
        });
    }
    function deserializeEnterpriseReferenceV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "EnterpriseReferenceV2025R0"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "EnterpriseReferenceV2025R0"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        const type = val.type == void 0
            ? void 0
            : deserializeEnterpriseReferenceV2025R0TypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeDocGenJobFullV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenJobFullV2025R0"',
            });
        }
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "DocGenJobFullV2025R0"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : val.created_at;
        if (val.created_by == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_by" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        const createdBy = deserializeUserBaseV2025R0(val.created_by);
        if (val.enterprise == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "enterprise" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        const enterprise = deserializeEnterpriseReferenceV2025R0(val.enterprise);
        if (val.source == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "source" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.source)) {
            throw new BoxSdkError({
                message: 'Expecting string for "source" of type "DocGenJobFullV2025R0"',
            });
        }
        const source = val.source;
        if (val.batch == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "batch" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        const batch = deserializeDocGenBatchBaseV2025R0(val.batch);
        if (val.template_file == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "template_file" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        const templateFile = deserializeFileReferenceV2025R0(val.template_file);
        if (val.template_file_version == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "template_file_version" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        const templateFileVersion = deserializeFileVersionBaseV2025R0(val.template_file_version);
        const outputFile = val.output_file == void 0
            ? void 0
            : val.output_file == void 0
                ? void 0
                : deserializeFileReferenceV2025R0(val.output_file);
        const outputFileVersion = val.output_file_version == void 0
            ? void 0
            : val.output_file_version == void 0
                ? void 0
                : deserializeFileVersionBaseV2025R0(val.output_file_version);
        if (val.status == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "status" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        const status = deserializeDocGenJobV2025R0StatusField(val.status);
        if (val.output_type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "output_type" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.output_type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "output_type" of type "DocGenJobFullV2025R0"',
            });
        }
        const outputType = val.output_type;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "DocGenJobFullV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "DocGenJobFullV2025R0" to be defined',
            });
        }
        const type = deserializeDocGenJobBaseV2025R0TypeField(val.type);
        return {
            createdAt: createdAt,
            createdBy: createdBy,
            enterprise: enterprise,
            source: source,
            batch: batch,
            templateFile: templateFile,
            templateFileVersion: templateFileVersion,
            outputFile: outputFile,
            outputFileVersion: outputFileVersion,
            status: status,
            outputType: outputType,
            id: id,
            type: type,
        };
    }

    function deserializeDocGenJobsFullV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "DocGenJobsFullV2025R0"',
            });
        }
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "DocGenJobsFullV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "DocGenJobsFullV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        if (!(val.prev_marker == void 0) && !sdIsString(val.prev_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "prev_marker" of type "DocGenJobsFullV2025R0"',
            });
        }
        const prevMarker = val.prev_marker == void 0 ? void 0 : val.prev_marker;
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "DocGenJobsFullV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeDocGenJobFullV2025R0(itm);
                })
                : [];
        return {
            limit: limit,
            nextMarker: nextMarker,
            prevMarker: prevMarker,
            entries: entries,
        };
    }

    function serializeDocGenDocumentGenerationDataV2025R0(val) {
        return {
            ['generated_file_name']: val.generatedFileName,
            ['user_input']: Object.fromEntries(Object.entries(val.userInput).map(([k, v]) => [
                k,
                (function (v) {
                    return v;
                })(v),
            ])),
        };
    }

    function serializeDocGenBatchCreateRequestV2025R0DestinationFolderTypeField(val) {
        return val;
    }
    function serializeDocGenBatchCreateRequestV2025R0DestinationFolderField(val) {
        return {
            ['type']: serializeDocGenBatchCreateRequestV2025R0DestinationFolderTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeDocGenBatchCreateRequestV2025R0(val) {
        return {
            ['file']: serializeFileReferenceV2025R0(val.file),
            ['file_version']: val.fileVersion == void 0
                ? val.fileVersion
                : serializeFileVersionBaseV2025R0(val.fileVersion),
            ['input_source']: val.inputSource,
            ['destination_folder']: serializeDocGenBatchCreateRequestV2025R0DestinationFolderField(val.destinationFolder),
            ['output_type']: val.outputType,
            ['document_generation_data']: val.documentGenerationData.map(function (item) {
                return serializeDocGenDocumentGenerationDataV2025R0(item);
            }),
        };
    }

    class GetDocgenJobByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new GetDocgenJobByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDocgenBatchJobByIdV2025R0Optionals {
        constructor(fields) {
            this.queryParams = {};
            this.headers = new GetDocgenBatchJobByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.queryParams !== undefined) {
                this.queryParams = fields.queryParams;
            }
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateDocgenBatchV2025R0Optionals {
        constructor(fields) {
            this.headers = new CreateDocgenBatchV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetDocgenJobByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetDocgenJobsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetDocgenBatchJobByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateDocgenBatchV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DocgenManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
           * Get details of the Box Doc Gen job.
           * @param {string} jobId Box Doc Gen job ID.
          Example: 123
           * @param {GetDocgenJobByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<DocGenJobV2025R0>}
           */
        getDocgenJobByIdV2025R0(jobId_1) {
            return __awaiter$1(this, arguments, void 0, function* (jobId, optionalsInput = {}) {
                const optionals = new GetDocgenJobByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_jobs/', toString(jobId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenJobV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Lists all Box Doc Gen jobs for a user.
         * @param {GetDocgenJobsV2025R0QueryParams} queryParams Query parameters of getDocgenJobsV2025R0 method
         * @param {GetDocgenJobsV2025R0HeadersInput} headersInput Headers of getDocgenJobsV2025R0 method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<DocGenJobsFullV2025R0>}
         */
        getDocgenJobsV2025R0() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetDocgenJobsV2025R0Headers({}), cancellationToken) {
                const headers = new GetDocgenJobsV2025R0Headers({
                    boxVersion: headersInput.boxVersion,
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_jobs'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenJobsFullV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Lists Box Doc Gen jobs in a batch.
           * @param {string} batchId Box Doc Gen batch ID.
          Example: 123
           * @param {GetDocgenBatchJobByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<DocGenJobsV2025R0>}
           */
        getDocgenBatchJobByIdV2025R0(batchId_1) {
            return __awaiter$1(this, arguments, void 0, function* (batchId, optionalsInput = {}) {
                const optionals = new GetDocgenBatchJobByIdV2025R0Optionals({
                    queryParams: optionalsInput.queryParams,
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const queryParams = optionals.queryParams;
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_batch_jobs/', toString(batchId)),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenJobsV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Generates a document using a Box Doc Gen template.
         * @param {DocGenBatchCreateRequestV2025R0} requestBody Request body of createDocgenBatchV2025R0 method
         * @param {CreateDocgenBatchV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<DocGenBatchBaseV2025R0>}
         */
        createDocgenBatchV2025R0(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateDocgenBatchV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/docgen_batches'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeDocGenBatchCreateRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeDocGenBatchBaseV2025R0(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeHubBaseV2025R0TypeField(val) {
        if (val == 'hubs') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize HubBaseV2025R0TypeField",
        });
    }
    function deserializeHubBaseV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "HubBaseV2025R0"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "HubBaseV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "HubBaseV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "HubBaseV2025R0" to be defined',
            });
        }
        const type = deserializeHubBaseV2025R0TypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeUserMiniV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "UserMiniV2025R0"' });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "UserMiniV2025R0"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "UserMiniV2025R0"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "UserMiniV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "UserMiniV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "UserMiniV2025R0" to be defined',
            });
        }
        const type = deserializeUserBaseV2025R0TypeField(val.type);
        return {
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function deserializeHubV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "HubV2025R0"' });
        }
        if (!(val.title == void 0) && !sdIsString(val.title)) {
            throw new BoxSdkError({
                message: 'Expecting string for "title" of type "HubV2025R0"',
            });
        }
        const title = val.title == void 0 ? void 0 : val.title;
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "HubV2025R0"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (!(val.created_at == void 0) && !sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "HubV2025R0"',
            });
        }
        const createdAt = val.created_at == void 0 ? void 0 : dateTimeFromString(val.created_at);
        if (!(val.updated_at == void 0) && !sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "HubV2025R0"',
            });
        }
        const updatedAt = val.updated_at == void 0 ? void 0 : dateTimeFromString(val.updated_at);
        const createdBy = val.created_by == void 0
            ? void 0
            : deserializeUserMiniV2025R0(val.created_by);
        const updatedBy = val.updated_by == void 0
            ? void 0
            : deserializeUserMiniV2025R0(val.updated_by);
        if (!(val.view_count == void 0) && !sdIsNumber(val.view_count)) {
            throw new BoxSdkError({
                message: 'Expecting number for "view_count" of type "HubV2025R0"',
            });
        }
        const viewCount = val.view_count == void 0 ? void 0 : val.view_count;
        if (!(val.is_ai_enabled == void 0) && !sdIsBoolean(val.is_ai_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_ai_enabled" of type "HubV2025R0"',
            });
        }
        const isAiEnabled = val.is_ai_enabled == void 0 ? void 0 : val.is_ai_enabled;
        if (!(val.is_collaboration_restricted_to_enterprise == void 0) &&
            !sdIsBoolean(val.is_collaboration_restricted_to_enterprise)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_collaboration_restricted_to_enterprise" of type "HubV2025R0"',
            });
        }
        const isCollaborationRestrictedToEnterprise = val.is_collaboration_restricted_to_enterprise == void 0
            ? void 0
            : val.is_collaboration_restricted_to_enterprise;
        if (!(val.can_non_owners_invite == void 0) &&
            !sdIsBoolean(val.can_non_owners_invite)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_non_owners_invite" of type "HubV2025R0"',
            });
        }
        const canNonOwnersInvite = val.can_non_owners_invite == void 0 ? void 0 : val.can_non_owners_invite;
        if (!(val.can_shared_link_be_created == void 0) &&
            !sdIsBoolean(val.can_shared_link_be_created)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "can_shared_link_be_created" of type "HubV2025R0"',
            });
        }
        const canSharedLinkBeCreated = val.can_shared_link_be_created == void 0
            ? void 0
            : val.can_shared_link_be_created;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "HubV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "HubV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "HubV2025R0" to be defined',
            });
        }
        const type = deserializeHubBaseV2025R0TypeField(val.type);
        return {
            title: title,
            description: description,
            createdAt: createdAt,
            updatedAt: updatedAt,
            createdBy: createdBy,
            updatedBy: updatedBy,
            viewCount: viewCount,
            isAiEnabled: isAiEnabled,
            isCollaborationRestrictedToEnterprise: isCollaborationRestrictedToEnterprise,
            canNonOwnersInvite: canNonOwnersInvite,
            canSharedLinkBeCreated: canSharedLinkBeCreated,
            id: id,
            type: type,
        };
    }

    function deserializeHubsV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "HubsV2025R0"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "HubsV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeHubV2025R0(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "HubsV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "HubsV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    function serializeHubCreateRequestV2025R0(val) {
        return { ['title']: val.title, ['description']: val.description };
    }

    function serializeHubUpdateRequestV2025R0(val) {
        return {
            ['title']: val.title,
            ['description']: val.description,
            ['is_ai_enabled']: val.isAiEnabled,
            ['is_collaboration_restricted_to_enterprise']: val.isCollaborationRestrictedToEnterprise,
            ['can_non_owners_invite']: val.canNonOwnersInvite,
            ['can_shared_link_be_created']: val.canSharedLinkBeCreated,
        };
    }

    function serializeHubCopyRequestV2025R0(val) {
        return { ['title']: val.title, ['description']: val.description };
    }

    class CreateHubV2025R0Optionals {
        constructor(fields) {
            this.headers = new CreateHubV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetHubByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new GetHubByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateHubByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new UpdateHubByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteHubByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new DeleteHubByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CopyHubV2025R0Optionals {
        constructor(fields) {
            this.headers = new CopyHubV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetHubsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateHubV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetEnterpriseHubsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetHubByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateHubByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteHubByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CopyHubV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class HubsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all hubs for requesting user.
         * @param {GetHubsV2025R0QueryParams} queryParams Query parameters of getHubsV2025R0 method
         * @param {GetHubsV2025R0HeadersInput} headersInput Headers of getHubsV2025R0 method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<HubsV2025R0>}
         */
        getHubsV2025R0() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetHubsV2025R0Headers({}), cancellationToken) {
                const headers = new GetHubsV2025R0Headers({
                    boxVersion: headersInput.boxVersion,
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['query']: toString(queryParams.query),
                    ['scope']: toString(queryParams.scope),
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hubs'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubsV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a new Hub.
         * @param {HubCreateRequestV2025R0} requestBody Request body of createHubV2025R0 method
         * @param {CreateHubV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<HubV2025R0>}
         */
        createHubV2025R0(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateHubV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hubs'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeHubCreateRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Retrieves all hubs for a given enterprise.
         *
         * Admins or Hub Co-admins of an enterprise
         * with GCM scope can make this call.
         * @param {GetEnterpriseHubsV2025R0QueryParams} queryParams Query parameters of getEnterpriseHubsV2025R0 method
         * @param {GetEnterpriseHubsV2025R0HeadersInput} headersInput Headers of getEnterpriseHubsV2025R0 method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<HubsV2025R0>}
         */
        getEnterpriseHubsV2025R0() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetEnterpriseHubsV2025R0Headers({}), cancellationToken) {
                const headers = new GetEnterpriseHubsV2025R0Headers({
                    boxVersion: headersInput.boxVersion,
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['query']: toString(queryParams.query),
                    ['sort']: toString(queryParams.sort),
                    ['direction']: toString(queryParams.direction),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/enterprise_hubs'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubsV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves details for a hub by its ID.
           * @param {string} hubId The unique identifier that represent a hub.
          
          The ID for any hub can be determined
          by visiting this hub in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/hubs/123`
          the `hub_id` is `123`.
          Example: "12345"
           * @param {GetHubByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<HubV2025R0>}
           */
        getHubByIdV2025R0(hubId_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubId, optionalsInput = {}) {
                const optionals = new GetHubByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hubs/', toString(hubId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a Hub. Can be used to change title, description, or Hub settings.
           * @param {string} hubId The unique identifier that represent a hub.
          
          The ID for any hub can be determined
          by visiting this hub in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/hubs/123`
          the `hub_id` is `123`.
          Example: "12345"
           * @param {HubUpdateRequestV2025R0} requestBody Request body of updateHubByIdV2025R0 method
           * @param {UpdateHubByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<HubV2025R0>}
           */
        updateHubByIdV2025R0(hubId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateHubByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hubs/', toString(hubId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeHubUpdateRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a single hub.
           * @param {string} hubId The unique identifier that represent a hub.
          
          The ID for any hub can be determined
          by visiting this hub in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/hubs/123`
          the `hub_id` is `123`.
          Example: "12345"
           * @param {DeleteHubByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteHubByIdV2025R0(hubId_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubId, optionalsInput = {}) {
                const optionals = new DeleteHubByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hubs/', toString(hubId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Creates a copy of a Hub.
           *
           * The original Hub will not be modified.
           * @param {string} hubId The unique identifier that represent a hub.
          
          The ID for any hub can be determined
          by visiting this hub in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/hubs/123`
          the `hub_id` is `123`.
          Example: "12345"
           * @param {HubCopyRequestV2025R0} requestBody Request body of copyHubV2025R0 method
           * @param {CopyHubV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<HubV2025R0>}
           */
        copyHubV2025R0(hubId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubId, requestBody, optionalsInput = {}) {
                const optionals = new CopyHubV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hubs/', toString(hubId), '/copy'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeHubCopyRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubV2025R0(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeHubCollaborationUserV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubCollaborationUserV2025R0"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "HubCollaborationUserV2025R0"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        if (!(val.login == void 0) && !sdIsString(val.login)) {
            throw new BoxSdkError({
                message: 'Expecting string for "login" of type "HubCollaborationUserV2025R0"',
            });
        }
        const login = val.login == void 0 ? void 0 : val.login;
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "HubCollaborationUserV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "HubCollaborationUserV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "HubCollaborationUserV2025R0" to be defined',
            });
        }
        const type = deserializeUserBaseV2025R0TypeField(val.type);
        return {
            name: name,
            login: login,
            id: id,
            type: type,
        };
    }

    function deserializeGroupBaseV2025R0TypeField(val) {
        if (val == 'group') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupBaseV2025R0TypeField",
        });
    }

    function deserializeGroupMiniV2025R0GroupTypeField(val) {
        if (val == 'managed_group') {
            return val;
        }
        if (val == 'all_users_group') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize GroupMiniV2025R0GroupTypeField",
        });
    }
    function deserializeGroupMiniV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "GroupMiniV2025R0"',
            });
        }
        if (!(val.name == void 0) && !sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "GroupMiniV2025R0"',
            });
        }
        const name = val.name == void 0 ? void 0 : val.name;
        const groupType = val.group_type == void 0
            ? void 0
            : deserializeGroupMiniV2025R0GroupTypeField(val.group_type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "GroupMiniV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "GroupMiniV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "GroupMiniV2025R0" to be defined',
            });
        }
        const type = deserializeGroupBaseV2025R0TypeField(val.type);
        return {
            name: name,
            groupType: groupType,
            id: id,
            type: type,
        };
    }

    function deserializeHubAccessGranteeV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubAccessGranteeV2025R0"',
            });
        }
        if (val.type == 'user') {
            return deserializeHubCollaborationUserV2025R0(val);
        }
        if (val.type == 'group') {
            return deserializeGroupMiniV2025R0(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize HubAccessGranteeV2025R0",
        });
    }

    function deserializeTermsOfServiceBaseV2025R0TypeField(val) {
        if (val == 'terms_of_service') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize TermsOfServiceBaseV2025R0TypeField",
        });
    }
    function deserializeTermsOfServiceBaseV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "TermsOfServiceBaseV2025R0"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "TermsOfServiceBaseV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "TermsOfServiceBaseV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "TermsOfServiceBaseV2025R0" to be defined',
            });
        }
        const type = deserializeTermsOfServiceBaseV2025R0TypeField(val.type);
        return { id: id, type: type };
    }

    function deserializeHubCollaborationV2025R0TypeField(val) {
        if (val == 'hub_collaboration') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize HubCollaborationV2025R0TypeField",
        });
    }
    function deserializeHubCollaborationV2025R0StatusField(val) {
        if (val == 'accepted') {
            return val;
        }
        if (val == 'pending') {
            return val;
        }
        if (val == 'rejected') {
            return val;
        }
        if (sdIsString(val)) {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize HubCollaborationV2025R0StatusField",
        });
    }
    function deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusTermsOfServiceRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubCollaborationV2025R0AcceptanceRequirementsStatusTermsOfServiceRequirementField"',
            });
        }
        if (!(val.is_accepted == void 0) && !sdIsBoolean(val.is_accepted)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "is_accepted" of type "HubCollaborationV2025R0AcceptanceRequirementsStatusTermsOfServiceRequirementField"',
            });
        }
        const isAccepted = val.is_accepted == void 0 ? void 0 : val.is_accepted;
        const termsOfService = val.terms_of_service == void 0
            ? void 0
            : deserializeTermsOfServiceBaseV2025R0(val.terms_of_service);
        return {
            isAccepted: isAccepted,
            termsOfService: termsOfService,
        };
    }
    function deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusStrongPasswordRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubCollaborationV2025R0AcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        if (!(val.enterprise_has_strong_password_required_for_external_users == void 0) &&
            !sdIsBoolean(val.enterprise_has_strong_password_required_for_external_users)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "enterprise_has_strong_password_required_for_external_users" of type "HubCollaborationV2025R0AcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        const enterpriseHasStrongPasswordRequiredForExternalUsers = val.enterprise_has_strong_password_required_for_external_users == void 0
            ? void 0
            : val.enterprise_has_strong_password_required_for_external_users;
        if (!(val.user_has_strong_password == void 0) &&
            !sdIsBoolean(val.user_has_strong_password)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "user_has_strong_password" of type "HubCollaborationV2025R0AcceptanceRequirementsStatusStrongPasswordRequirementField"',
            });
        }
        const userHasStrongPassword = val.user_has_strong_password == void 0
            ? void 0
            : val.user_has_strong_password;
        return {
            enterpriseHasStrongPasswordRequiredForExternalUsers: enterpriseHasStrongPasswordRequiredForExternalUsers,
            userHasStrongPassword: userHasStrongPassword,
        };
    }
    function deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubCollaborationV2025R0AcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        if (!(val.enterprise_has_two_factor_auth_enabled == void 0) &&
            !sdIsBoolean(val.enterprise_has_two_factor_auth_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "enterprise_has_two_factor_auth_enabled" of type "HubCollaborationV2025R0AcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        const enterpriseHasTwoFactorAuthEnabled = val.enterprise_has_two_factor_auth_enabled == void 0
            ? void 0
            : val.enterprise_has_two_factor_auth_enabled;
        if (!(val.user_has_two_factor_authentication_enabled == void 0) &&
            !sdIsBoolean(val.user_has_two_factor_authentication_enabled)) {
            throw new BoxSdkError({
                message: 'Expecting boolean for "user_has_two_factor_authentication_enabled" of type "HubCollaborationV2025R0AcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField"',
            });
        }
        const userHasTwoFactorAuthenticationEnabled = val.user_has_two_factor_authentication_enabled == void 0
            ? void 0
            : val.user_has_two_factor_authentication_enabled;
        return {
            enterpriseHasTwoFactorAuthEnabled: enterpriseHasTwoFactorAuthEnabled,
            userHasTwoFactorAuthenticationEnabled: userHasTwoFactorAuthenticationEnabled,
        };
    }
    function deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubCollaborationV2025R0AcceptanceRequirementsStatusField"',
            });
        }
        const termsOfServiceRequirement = val.terms_of_service_requirement == void 0
            ? void 0
            : deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusTermsOfServiceRequirementField(val.terms_of_service_requirement);
        const strongPasswordRequirement = val.strong_password_requirement == void 0
            ? void 0
            : deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusStrongPasswordRequirementField(val.strong_password_requirement);
        const twoFactorAuthenticationRequirement = val.two_factor_authentication_requirement == void 0
            ? void 0
            : deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusTwoFactorAuthenticationRequirementField(val.two_factor_authentication_requirement);
        return {
            termsOfServiceRequirement: termsOfServiceRequirement,
            strongPasswordRequirement: strongPasswordRequirement,
            twoFactorAuthenticationRequirement: twoFactorAuthenticationRequirement,
        };
    }
    function deserializeHubCollaborationV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubCollaborationV2025R0"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "HubCollaborationV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "HubCollaborationV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "HubCollaborationV2025R0" to be defined',
            });
        }
        const type = deserializeHubCollaborationV2025R0TypeField(val.type);
        const hub = val.hub == void 0 ? void 0 : deserializeHubBaseV2025R0(val.hub);
        const accessibleBy = val.accessible_by == void 0
            ? void 0
            : deserializeHubAccessGranteeV2025R0(val.accessible_by);
        if (!(val.role == void 0) && !sdIsString(val.role)) {
            throw new BoxSdkError({
                message: 'Expecting string for "role" of type "HubCollaborationV2025R0"',
            });
        }
        const role = val.role == void 0 ? void 0 : val.role;
        const status = val.status == void 0
            ? void 0
            : deserializeHubCollaborationV2025R0StatusField(val.status);
        const acceptanceRequirementsStatus = val.acceptance_requirements_status == void 0
            ? void 0
            : deserializeHubCollaborationV2025R0AcceptanceRequirementsStatusField(val.acceptance_requirements_status);
        return {
            id: id,
            type: type,
            hub: hub,
            accessibleBy: accessibleBy,
            role: role,
            status: status,
            acceptanceRequirementsStatus: acceptanceRequirementsStatus,
        };
    }

    function deserializeHubCollaborationsV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubCollaborationsV2025R0"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "HubCollaborationsV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeHubCollaborationV2025R0(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "HubCollaborationsV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "HubCollaborationsV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    function serializeHubCollaborationCreateRequestV2025R0HubTypeField(val) {
        return val;
    }
    function serializeHubCollaborationCreateRequestV2025R0HubField(val) {
        return {
            ['type']: serializeHubCollaborationCreateRequestV2025R0HubTypeField(val.type),
            ['id']: val.id,
        };
    }
    function serializeHubCollaborationCreateRequestV2025R0AccessibleByField(val) {
        return { ['type']: val.type, ['id']: val.id, ['login']: val.login };
    }
    function serializeHubCollaborationCreateRequestV2025R0(val) {
        return {
            ['hub']: serializeHubCollaborationCreateRequestV2025R0HubField(val.hub),
            ['accessible_by']: serializeHubCollaborationCreateRequestV2025R0AccessibleByField(val.accessibleBy),
            ['role']: val.role,
        };
    }

    function serializeHubCollaborationUpdateRequestV2025R0(val) {
        return { ['role']: val.role };
    }

    class GetHubCollaborationsV2025R0Optionals {
        constructor(fields) {
            this.headers = new GetHubCollaborationsV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class CreateHubCollaborationV2025R0Optionals {
        constructor(fields) {
            this.headers = new CreateHubCollaborationV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetHubCollaborationByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new GetHubCollaborationByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateHubCollaborationByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new UpdateHubCollaborationByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteHubCollaborationByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new DeleteHubCollaborationByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetHubCollaborationsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateHubCollaborationV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetHubCollaborationByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateHubCollaborationByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteHubCollaborationByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class HubCollaborationsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all collaborations for a hub.
         * @param {GetHubCollaborationsV2025R0QueryParams} queryParams Query parameters of getHubCollaborationsV2025R0 method
         * @param {GetHubCollaborationsV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<HubCollaborationsV2025R0>}
         */
        getHubCollaborationsV2025R0(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetHubCollaborationsV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['hub_id']: toString(queryParams.hubId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hub_collaborations'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubCollaborationsV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Adds a collaboration for a single user or a single group to a hub.
         *
         * Collaborations can be created using email address, user IDs, or group IDs.
         * @param {HubCollaborationCreateRequestV2025R0} requestBody Request body of createHubCollaborationV2025R0 method
         * @param {CreateHubCollaborationV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<HubCollaborationV2025R0>}
         */
        createHubCollaborationV2025R0(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateHubCollaborationV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hub_collaborations'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeHubCollaborationCreateRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubCollaborationV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves details for a hub collaboration by collaboration ID.
           * @param {string} hubCollaborationId The ID of the hub collaboration.
          Example: "1234"
           * @param {GetHubCollaborationByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<HubCollaborationV2025R0>}
           */
        getHubCollaborationByIdV2025R0(hubCollaborationId_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubCollaborationId, optionalsInput = {}) {
                const optionals = new GetHubCollaborationByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hub_collaborations/', toString(hubCollaborationId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubCollaborationV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Updates a hub collaboration.
           * Can be used to change the hub role.
           * @param {string} hubCollaborationId The ID of the hub collaboration.
          Example: "1234"
           * @param {HubCollaborationUpdateRequestV2025R0} requestBody Request body of updateHubCollaborationByIdV2025R0 method
           * @param {UpdateHubCollaborationByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<HubCollaborationV2025R0>}
           */
        updateHubCollaborationByIdV2025R0(hubCollaborationId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubCollaborationId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateHubCollaborationByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hub_collaborations/', toString(hubCollaborationId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeHubCollaborationUpdateRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubCollaborationV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Deletes a single hub collaboration.
           * @param {string} hubCollaborationId The ID of the hub collaboration.
          Example: "1234"
           * @param {DeleteHubCollaborationByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteHubCollaborationByIdV2025R0(hubCollaborationId_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubCollaborationId, optionalsInput = {}) {
                const optionals = new DeleteHubCollaborationByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hub_collaborations/', toString(hubCollaborationId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }

    function deserializeHubItemV2025R0TypeField(val) {
        if (val == 'file') {
            return val;
        }
        if (val == 'folder') {
            return val;
        }
        if (val == 'web_link') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize HubItemV2025R0TypeField",
        });
    }
    function deserializeHubItemV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "HubItemV2025R0"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "HubItemV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "HubItemV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "HubItemV2025R0" to be defined',
            });
        }
        const type = deserializeHubItemV2025R0TypeField(val.type);
        if (val.name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "name" of type "HubItemV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "HubItemV2025R0"',
            });
        }
        const name = val.name;
        return { id: id, type: type, name: name };
    }

    function deserializeHubItemsV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "HubItemsV2025R0"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "HubItemsV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeHubItemV2025R0(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "HubItemsV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "HubItemsV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    function serializeFolderReferenceV2025R0TypeField(val) {
        return val;
    }
    function deserializeFolderReferenceV2025R0TypeField(val) {
        if (val == 'folder') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize FolderReferenceV2025R0TypeField",
        });
    }
    function serializeFolderReferenceV2025R0(val) {
        return {
            ['type']: serializeFolderReferenceV2025R0TypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeFolderReferenceV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "FolderReferenceV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "FolderReferenceV2025R0" to be defined',
            });
        }
        const type = deserializeFolderReferenceV2025R0TypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "FolderReferenceV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "FolderReferenceV2025R0"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }

    function serializeWeblinkReferenceV2025R0TypeField(val) {
        return val;
    }
    function deserializeWeblinkReferenceV2025R0TypeField(val) {
        if (val == 'weblink') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize WeblinkReferenceV2025R0TypeField",
        });
    }
    function serializeWeblinkReferenceV2025R0(val) {
        return {
            ['type']: serializeWeblinkReferenceV2025R0TypeField(val.type),
            ['id']: val.id,
        };
    }
    function deserializeWeblinkReferenceV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "WeblinkReferenceV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "WeblinkReferenceV2025R0" to be defined',
            });
        }
        const type = deserializeWeblinkReferenceV2025R0TypeField(val.type);
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "WeblinkReferenceV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "WeblinkReferenceV2025R0"',
            });
        }
        const id = val.id;
        return { type: type, id: id };
    }

    function deserializeHubItemReferenceV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubItemReferenceV2025R0"',
            });
        }
        if (val.type == 'file') {
            return deserializeFileReferenceV2025R0(val);
        }
        if (val.type == 'folder') {
            return deserializeFolderReferenceV2025R0(val);
        }
        if (val.type == 'weblink') {
            return deserializeWeblinkReferenceV2025R0(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize HubItemReferenceV2025R0",
        });
    }

    function deserializeHubItemOperationResultV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubItemOperationResultV2025R0"',
            });
        }
        if (!(val.action == void 0) && !sdIsString(val.action)) {
            throw new BoxSdkError({
                message: 'Expecting string for "action" of type "HubItemOperationResultV2025R0"',
            });
        }
        const action = val.action == void 0 ? void 0 : val.action;
        const item = val.item == void 0 ? void 0 : deserializeHubItemReferenceV2025R0(val.item);
        if (!(val.status == void 0) && !sdIsNumber(val.status)) {
            throw new BoxSdkError({
                message: 'Expecting number for "status" of type "HubItemOperationResultV2025R0"',
            });
        }
        const status = val.status == void 0 ? void 0 : val.status;
        if (!(val.error == void 0) && !sdIsString(val.error)) {
            throw new BoxSdkError({
                message: 'Expecting string for "error" of type "HubItemOperationResultV2025R0"',
            });
        }
        const error = val.error == void 0 ? void 0 : val.error;
        return {
            action: action,
            item: item,
            status: status,
            error: error,
        };
    }

    function deserializeHubItemsManageResponseV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "HubItemsManageResponseV2025R0"',
            });
        }
        if (val.operations == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "operations" of type "HubItemsManageResponseV2025R0" to be defined',
            });
        }
        if (!sdIsList(val.operations)) {
            throw new BoxSdkError({
                message: 'Expecting array for "operations" of type "HubItemsManageResponseV2025R0"',
            });
        }
        const operations = sdIsList(val.operations)
            ? val.operations.map(function (itm) {
                return deserializeHubItemOperationResultV2025R0(itm);
            })
            : [];
        return { operations: operations };
    }

    function serializeFileReferenceOrFolderReferenceOrWeblinkReferenceV2025R0(val) {
        if (val.type == 'file') {
            return serializeFileReferenceV2025R0(val);
        }
        if (val.type == 'folder') {
            return serializeFolderReferenceV2025R0(val);
        }
        if (val.type == 'weblink') {
            return serializeWeblinkReferenceV2025R0(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }

    function serializeHubItemOperationV2025R0ActionField(val) {
        return val;
    }
    function serializeHubItemOperationV2025R0(val) {
        return {
            ['action']: serializeHubItemOperationV2025R0ActionField(val.action),
            ['item']: serializeFileReferenceOrFolderReferenceOrWeblinkReferenceV2025R0(val.item),
        };
    }

    function serializeHubItemsManageRequestV2025R0(val) {
        return {
            ['operations']: val.operations == void 0
                ? val.operations
                : val.operations.map(function (item) {
                    return serializeHubItemOperationV2025R0(item);
                }),
        };
    }

    class GetHubItemsV2025R0Optionals {
        constructor(fields) {
            this.headers = new GetHubItemsV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class ManageHubItemsV2025R0Optionals {
        constructor(fields) {
            this.headers = new ManageHubItemsV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetHubItemsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ManageHubItemsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class HubItemsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all items associated with a Hub.
         * @param {GetHubItemsV2025R0QueryParams} queryParams Query parameters of getHubItemsV2025R0 method
         * @param {GetHubItemsV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<HubItemsV2025R0>}
         */
        getHubItemsV2025R0(queryParams_1) {
            return __awaiter$1(this, arguments, void 0, function* (queryParams, optionalsInput = {}) {
                const optionals = new GetHubItemsV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const queryParamsMap = prepareParams({
                    ['hub_id']: toString(queryParams.hubId),
                    ['marker']: toString(queryParams.marker),
                    ['limit']: toString(queryParams.limit),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hub_items'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubItemsV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Adds and/or removes Hub items from a Hub.
           * @param {string} hubId The unique identifier that represent a hub.
          
          The ID for any hub can be determined
          by visiting this hub in the web application
          and copying the ID from the URL. For example,
          for the URL `https://*.app.box.com/hubs/123`
          the `hub_id` is `123`.
          Example: "12345"
           * @param {HubItemsManageRequestV2025R0} requestBody Request body of manageHubItemsV2025R0 method
           * @param {ManageHubItemsV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<HubItemsManageResponseV2025R0>}
           */
        manageHubItemsV2025R0(hubId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (hubId, requestBody, optionalsInput = {}) {
                const optionals = new ManageHubItemsV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/hubs/', toString(hubId), '/manage_items'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeHubItemsManageRequestV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeHubItemsManageResponseV2025R0(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeShieldListMiniV2025R0TypeField(val) {
        if (val == 'shield_list') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldListMiniV2025R0TypeField",
        });
    }
    function deserializeShieldListMiniV2025R0ContentField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListMiniV2025R0ContentField"',
            });
        }
        if (!(val.type == void 0) && !sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "ShieldListMiniV2025R0ContentField"',
            });
        }
        const type = val.type == void 0 ? void 0 : val.type;
        return { type: type };
    }
    function deserializeShieldListMiniV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListMiniV2025R0"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ShieldListMiniV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldListMiniV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ShieldListMiniV2025R0" to be defined',
            });
        }
        const type = deserializeShieldListMiniV2025R0TypeField(val.type);
        if (val.name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "name" of type "ShieldListMiniV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "ShieldListMiniV2025R0"',
            });
        }
        const name = val.name;
        if (val.content == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "content" of type "ShieldListMiniV2025R0" to be defined',
            });
        }
        const content = deserializeShieldListMiniV2025R0ContentField(val.content);
        return {
            id: id,
            type: type,
            name: name,
            content: content,
        };
    }

    function deserializeShieldListsV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListsV2025R0"',
            });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ShieldListsV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeShieldListMiniV2025R0(itm);
                })
                : [];
        return { entries: entries };
    }

    function serializeShieldListContentCountryV2025R0TypeField(val) {
        return val;
    }
    function deserializeShieldListContentCountryV2025R0TypeField(val) {
        if (val == 'country') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldListContentCountryV2025R0TypeField",
        });
    }
    function serializeShieldListContentCountryV2025R0(val) {
        return {
            ['type']: serializeShieldListContentCountryV2025R0TypeField(val.type),
            ['country_codes']: val.countryCodes.map(function (item) {
                return item;
            }),
        };
    }
    function deserializeShieldListContentCountryV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListContentCountryV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ShieldListContentCountryV2025R0" to be defined',
            });
        }
        const type = deserializeShieldListContentCountryV2025R0TypeField(val.type);
        if (val.country_codes == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "country_codes" of type "ShieldListContentCountryV2025R0" to be defined',
            });
        }
        if (!sdIsList(val.country_codes)) {
            throw new BoxSdkError({
                message: 'Expecting array for "country_codes" of type "ShieldListContentCountryV2025R0"',
            });
        }
        const countryCodes = sdIsList(val.country_codes)
            ? val.country_codes.map(function (itm) {
                if (!sdIsString(itm)) {
                    throw new BoxSdkError({
                        message: 'Expecting string for "ShieldListContentCountryV2025R0"',
                    });
                }
                return itm;
            })
            : [];
        return {
            type: type,
            countryCodes: countryCodes,
        };
    }

    function serializeShieldListContentDomainV2025R0TypeField(val) {
        return val;
    }
    function deserializeShieldListContentDomainV2025R0TypeField(val) {
        if (val == 'domain') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldListContentDomainV2025R0TypeField",
        });
    }
    function serializeShieldListContentDomainV2025R0(val) {
        return {
            ['type']: serializeShieldListContentDomainV2025R0TypeField(val.type),
            ['domains']: val.domains.map(function (item) {
                return item;
            }),
        };
    }
    function deserializeShieldListContentDomainV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListContentDomainV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ShieldListContentDomainV2025R0" to be defined',
            });
        }
        const type = deserializeShieldListContentDomainV2025R0TypeField(val.type);
        if (val.domains == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "domains" of type "ShieldListContentDomainV2025R0" to be defined',
            });
        }
        if (!sdIsList(val.domains)) {
            throw new BoxSdkError({
                message: 'Expecting array for "domains" of type "ShieldListContentDomainV2025R0"',
            });
        }
        const domains = sdIsList(val.domains)
            ? val.domains.map(function (itm) {
                if (!sdIsString(itm)) {
                    throw new BoxSdkError({
                        message: 'Expecting string for "ShieldListContentDomainV2025R0"',
                    });
                }
                return itm;
            })
            : [];
        return {
            type: type,
            domains: domains,
        };
    }

    function serializeShieldListContentEmailV2025R0TypeField(val) {
        return val;
    }
    function deserializeShieldListContentEmailV2025R0TypeField(val) {
        if (val == 'email') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldListContentEmailV2025R0TypeField",
        });
    }
    function serializeShieldListContentEmailV2025R0(val) {
        return {
            ['type']: serializeShieldListContentEmailV2025R0TypeField(val.type),
            ['email_addresses']: val.emailAddresses.map(function (item) {
                return item;
            }),
        };
    }
    function deserializeShieldListContentEmailV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListContentEmailV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ShieldListContentEmailV2025R0" to be defined',
            });
        }
        const type = deserializeShieldListContentEmailV2025R0TypeField(val.type);
        if (val.email_addresses == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "email_addresses" of type "ShieldListContentEmailV2025R0" to be defined',
            });
        }
        if (!sdIsList(val.email_addresses)) {
            throw new BoxSdkError({
                message: 'Expecting array for "email_addresses" of type "ShieldListContentEmailV2025R0"',
            });
        }
        const emailAddresses = sdIsList(val.email_addresses)
            ? val.email_addresses.map(function (itm) {
                if (!sdIsString(itm)) {
                    throw new BoxSdkError({
                        message: 'Expecting string for "ShieldListContentEmailV2025R0"',
                    });
                }
                return itm;
            })
            : [];
        return {
            type: type,
            emailAddresses: emailAddresses,
        };
    }

    function serializeShieldListContentIpV2025R0TypeField(val) {
        return val;
    }
    function deserializeShieldListContentIpV2025R0TypeField(val) {
        if (val == 'ip') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldListContentIpV2025R0TypeField",
        });
    }
    function serializeShieldListContentIpV2025R0(val) {
        return {
            ['type']: serializeShieldListContentIpV2025R0TypeField(val.type),
            ['ip_addresses']: val.ipAddresses.map(function (item) {
                return item;
            }),
        };
    }
    function deserializeShieldListContentIpV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListContentIpV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ShieldListContentIpV2025R0" to be defined',
            });
        }
        const type = deserializeShieldListContentIpV2025R0TypeField(val.type);
        if (val.ip_addresses == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "ip_addresses" of type "ShieldListContentIpV2025R0" to be defined',
            });
        }
        if (!sdIsList(val.ip_addresses)) {
            throw new BoxSdkError({
                message: 'Expecting array for "ip_addresses" of type "ShieldListContentIpV2025R0"',
            });
        }
        const ipAddresses = sdIsList(val.ip_addresses)
            ? val.ip_addresses.map(function (itm) {
                if (!sdIsString(itm)) {
                    throw new BoxSdkError({
                        message: 'Expecting string for "ShieldListContentIpV2025R0"',
                    });
                }
                return itm;
            })
            : [];
        return {
            type: type,
            ipAddresses: ipAddresses,
        };
    }

    function deserializeShieldListContentIntegrationV2025R0TypeField(val) {
        if (val == 'integration') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldListContentIntegrationV2025R0TypeField",
        });
    }
    function deserializeShieldListContentIntegrationV2025R0IntegrationsField(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListContentIntegrationV2025R0IntegrationsField"',
            });
        }
        if (!(val.id == void 0) && !sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldListContentIntegrationV2025R0IntegrationsField"',
            });
        }
        const id = val.id == void 0 ? void 0 : val.id;
        return {
            id: id,
        };
    }
    function deserializeShieldListContentIntegrationV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListContentIntegrationV2025R0"',
            });
        }
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ShieldListContentIntegrationV2025R0" to be defined',
            });
        }
        const type = deserializeShieldListContentIntegrationV2025R0TypeField(val.type);
        if (val.integrations == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "integrations" of type "ShieldListContentIntegrationV2025R0" to be defined',
            });
        }
        if (!sdIsList(val.integrations)) {
            throw new BoxSdkError({
                message: 'Expecting array for "integrations" of type "ShieldListContentIntegrationV2025R0"',
            });
        }
        const integrations = sdIsList(val.integrations)
            ? val.integrations.map(function (itm) {
                return deserializeShieldListContentIntegrationV2025R0IntegrationsField(itm);
            })
            : [];
        return {
            type: type,
            integrations: integrations,
        };
    }

    function deserializeShieldListContentV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListContentV2025R0"',
            });
        }
        if (val.type == 'country') {
            return deserializeShieldListContentCountryV2025R0(val);
        }
        if (val.type == 'domain') {
            return deserializeShieldListContentDomainV2025R0(val);
        }
        if (val.type == 'email') {
            return deserializeShieldListContentEmailV2025R0(val);
        }
        if (val.type == 'ip') {
            return deserializeShieldListContentIpV2025R0(val);
        }
        if (val.type == 'integration') {
            return deserializeShieldListContentIntegrationV2025R0(val);
        }
        throw new BoxSdkError({
            message: "Can't deserialize ShieldListContentV2025R0",
        });
    }

    function deserializeShieldListV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({
                message: 'Expecting a map for "ShieldListV2025R0"',
            });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ShieldListV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ShieldListV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ShieldListV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.type)) {
            throw new BoxSdkError({
                message: 'Expecting string for "type" of type "ShieldListV2025R0"',
            });
        }
        const type = val.type;
        if (val.name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "name" of type "ShieldListV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "ShieldListV2025R0"',
            });
        }
        const name = val.name;
        if (val.enterprise == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "enterprise" of type "ShieldListV2025R0" to be defined',
            });
        }
        const enterprise = deserializeEnterpriseReferenceV2025R0(val.enterprise);
        if (!(val.description == void 0) && !sdIsString(val.description)) {
            throw new BoxSdkError({
                message: 'Expecting string for "description" of type "ShieldListV2025R0"',
            });
        }
        const description = val.description == void 0 ? void 0 : val.description;
        if (val.created_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "created_at" of type "ShieldListV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.created_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "created_at" of type "ShieldListV2025R0"',
            });
        }
        const createdAt = dateTimeFromString(val.created_at);
        if (val.updated_at == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "updated_at" of type "ShieldListV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.updated_at)) {
            throw new BoxSdkError({
                message: 'Expecting string for "updated_at" of type "ShieldListV2025R0"',
            });
        }
        const updatedAt = dateTimeFromString(val.updated_at);
        if (val.content == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "content" of type "ShieldListV2025R0" to be defined',
            });
        }
        const content = deserializeShieldListContentV2025R0(val.content);
        return {
            id: id,
            type: type,
            name: name,
            enterprise: enterprise,
            description: description,
            createdAt: createdAt,
            updatedAt: updatedAt,
            content: content,
        };
    }

    function serializeShieldListContentRequestV2025R0(val) {
        if (val.type == 'country') {
            return serializeShieldListContentCountryV2025R0(val);
        }
        if (val.type == 'domain') {
            return serializeShieldListContentDomainV2025R0(val);
        }
        if (val.type == 'email') {
            return serializeShieldListContentEmailV2025R0(val);
        }
        if (val.type == 'ip') {
            return serializeShieldListContentIpV2025R0(val);
        }
        throw new BoxSdkError({ message: 'unknown type' });
    }

    function serializeShieldListsCreateV2025R0(val) {
        return {
            ['name']: val.name,
            ['description']: val.description,
            ['content']: serializeShieldListContentRequestV2025R0(val.content),
        };
    }

    function serializeShieldListsUpdateV2025R0(val) {
        return {
            ['name']: val.name,
            ['description']: val.description,
            ['content']: serializeShieldListContentRequestV2025R0(val.content),
        };
    }

    class CreateShieldListV2025R0Optionals {
        constructor(fields) {
            this.headers = new CreateShieldListV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldListByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new GetShieldListByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteShieldListByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new DeleteShieldListByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class UpdateShieldListByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new UpdateShieldListByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetShieldListsV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateShieldListV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class GetShieldListByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteShieldListByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class UpdateShieldListByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ShieldListsManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves all shield lists in the enterprise.
         * @param {GetShieldListsV2025R0HeadersInput} headersInput Headers of getShieldListsV2025R0 method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<ShieldListsV2025R0>}
         */
        getShieldListsV2025R0() {
            return __awaiter$1(this, arguments, void 0, function* (headersInput = new GetShieldListsV2025R0Headers({}), cancellationToken) {
                const headers = new GetShieldListsV2025R0Headers({
                    boxVersion: headersInput.boxVersion,
                    extraHeaders: headersInput.extraHeaders,
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_lists'),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldListsV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates a shield list.
         * @param {ShieldListsCreateV2025R0} requestBody Request body of createShieldListV2025R0 method
         * @param {CreateShieldListV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<ShieldListV2025R0>}
         */
        createShieldListV2025R0(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateShieldListV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_lists'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeShieldListsCreateV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldListV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Retrieves a single shield list by its ID.
           * @param {string} shieldListId The unique identifier that represents a shield list.
          The ID for any Shield List can be determined by the response from the endpoint
          fetching all shield lists for the enterprise.
          Example: "90fb0e17-c332-40ed-b4f9-fa8908fbbb24 "
           * @param {GetShieldListByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<ShieldListV2025R0>}
           */
        getShieldListByIdV2025R0(shieldListId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldListId, optionalsInput = {}) {
                const optionals = new GetShieldListByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_lists/', toString(shieldListId)),
                    method: 'GET',
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldListV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Delete a single shield list by its ID.
           * @param {string} shieldListId The unique identifier that represents a shield list.
          The ID for any Shield List can be determined by the response from the endpoint
          fetching all shield lists for the enterprise.
          Example: "90fb0e17-c332-40ed-b4f9-fa8908fbbb24 "
           * @param {DeleteShieldListByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteShieldListByIdV2025R0(shieldListId_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldListId, optionalsInput = {}) {
                const optionals = new DeleteShieldListByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_lists/', toString(shieldListId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
        /**
           * Updates a shield list.
           * @param {string} shieldListId The unique identifier that represents a shield list.
          The ID for any Shield List can be determined by the response from the endpoint
          fetching all shield lists for the enterprise.
          Example: "90fb0e17-c332-40ed-b4f9-fa8908fbbb24 "
           * @param {ShieldListsUpdateV2025R0} requestBody Request body of updateShieldListByIdV2025R0 method
           * @param {UpdateShieldListByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<ShieldListV2025R0>}
           */
        updateShieldListByIdV2025R0(shieldListId_1, requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (shieldListId, requestBody, optionalsInput = {}) {
                const optionals = new UpdateShieldListByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/shield_lists/', toString(shieldListId)),
                    method: 'PUT',
                    headers: headersMap,
                    data: serializeShieldListsUpdateV2025R0(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeShieldListV2025R0(response.data)), { rawData: response.data });
            });
        }
    }

    function deserializeArchiveV2025R0TypeField(val) {
        if (val == 'archive') {
            return val;
        }
        throw new BoxSdkError({
            message: "Can't deserialize ArchiveV2025R0TypeField",
        });
    }
    function deserializeArchiveV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "ArchiveV2025R0"' });
        }
        if (val.id == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "id" of type "ArchiveV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.id)) {
            throw new BoxSdkError({
                message: 'Expecting string for "id" of type "ArchiveV2025R0"',
            });
        }
        const id = val.id;
        if (val.type == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "type" of type "ArchiveV2025R0" to be defined',
            });
        }
        const type = deserializeArchiveV2025R0TypeField(val.type);
        if (val.name == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "name" of type "ArchiveV2025R0" to be defined',
            });
        }
        if (!sdIsString(val.name)) {
            throw new BoxSdkError({
                message: 'Expecting string for "name" of type "ArchiveV2025R0"',
            });
        }
        const name = val.name;
        if (val.size == void 0) {
            throw new BoxSdkError({
                message: 'Expecting "size" of type "ArchiveV2025R0" to be defined',
            });
        }
        if (!sdIsNumber(val.size)) {
            throw new BoxSdkError({
                message: 'Expecting number for "size" of type "ArchiveV2025R0"',
            });
        }
        const size = val.size;
        return {
            id: id,
            type: type,
            name: name,
            size: size,
        };
    }

    function deserializeArchivesV2025R0(val) {
        if (!sdIsMap(val)) {
            throw new BoxSdkError({ message: 'Expecting a map for "ArchivesV2025R0"' });
        }
        if (!(val.entries == void 0) && !sdIsList(val.entries)) {
            throw new BoxSdkError({
                message: 'Expecting array for "entries" of type "ArchivesV2025R0"',
            });
        }
        const entries = val.entries == void 0
            ? void 0
            : sdIsList(val.entries)
                ? val.entries.map(function (itm) {
                    return deserializeArchiveV2025R0(itm);
                })
                : [];
        if (!(val.limit == void 0) && !sdIsNumber(val.limit)) {
            throw new BoxSdkError({
                message: 'Expecting number for "limit" of type "ArchivesV2025R0"',
            });
        }
        const limit = val.limit == void 0 ? void 0 : val.limit;
        if (!(val.next_marker == void 0) && !sdIsString(val.next_marker)) {
            throw new BoxSdkError({
                message: 'Expecting string for "next_marker" of type "ArchivesV2025R0"',
            });
        }
        const nextMarker = val.next_marker == void 0 ? void 0 : val.next_marker;
        return {
            entries: entries,
            limit: limit,
            nextMarker: nextMarker,
        };
    }

    class CreateArchiveV2025R0Optionals {
        constructor(fields) {
            this.headers = new CreateArchiveV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class DeleteArchiveByIdV2025R0Optionals {
        constructor(fields) {
            this.headers = new DeleteArchiveByIdV2025R0Headers({});
            this.cancellationToken = void 0;
            if (fields.headers !== undefined) {
                this.headers = fields.headers;
            }
            if (fields.cancellationToken !== undefined) {
                this.cancellationToken = fields.cancellationToken;
            }
        }
    }
    class GetArchivesV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class CreateArchiveV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class DeleteArchiveByIdV2025R0Headers {
        constructor(fields) {
            /**
             * Version header. */
            this.boxVersion = '2025.0';
            /**
             * Extra headers that will be included in the HTTP request. */
            this.extraHeaders = {};
            if (fields.boxVersion !== undefined) {
                this.boxVersion = fields.boxVersion;
            }
            if (fields.extraHeaders !== undefined) {
                this.extraHeaders = fields.extraHeaders;
            }
        }
    }
    class ArchivesManager {
        constructor(fields) {
            this.networkSession = new NetworkSession({});
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
        }
        /**
         * Retrieves archives for an enterprise.
         * @param {GetArchivesV2025R0QueryParams} queryParams Query parameters of getArchivesV2025R0 method
         * @param {GetArchivesV2025R0HeadersInput} headersInput Headers of getArchivesV2025R0 method
         * @param {CancellationToken} cancellationToken Token used for request cancellation.
         * @returns {Promise<ArchivesV2025R0>}
         */
        getArchivesV2025R0() {
            return __awaiter$1(this, arguments, void 0, function* (queryParams = {}, headersInput = new GetArchivesV2025R0Headers({}), cancellationToken) {
                const headers = new GetArchivesV2025R0Headers({
                    boxVersion: headersInput.boxVersion,
                    extraHeaders: headersInput.extraHeaders,
                });
                const queryParamsMap = prepareParams({
                    ['limit']: toString(queryParams.limit),
                    ['marker']: toString(queryParams.marker),
                });
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/archives'),
                    method: 'GET',
                    params: queryParamsMap,
                    headers: headersMap,
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeArchivesV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
         * Creates an archive.
         * @param {CreateArchiveV2025R0RequestBody} requestBody Request body of createArchiveV2025R0 method
         * @param {CreateArchiveV2025R0OptionalsInput} optionalsInput
         * @returns {Promise<ArchiveV2025R0>}
         */
        createArchiveV2025R0(requestBody_1) {
            return __awaiter$1(this, arguments, void 0, function* (requestBody, optionalsInput = {}) {
                const optionals = new CreateArchiveV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                const response = yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/archives'),
                    method: 'POST',
                    headers: headersMap,
                    data: serializeCreateArchiveV2025R0RequestBody(requestBody),
                    contentType: 'application/json',
                    responseFormat: 'json',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return Object.assign(Object.assign({}, deserializeArchiveV2025R0(response.data)), { rawData: response.data });
            });
        }
        /**
           * Permanently deletes an archive.
           * @param {string} archiveId The ID of the archive.
          Example: "982312"
           * @param {DeleteArchiveByIdV2025R0OptionalsInput} optionalsInput
           * @returns {Promise<undefined>}
           */
        deleteArchiveByIdV2025R0(archiveId_1) {
            return __awaiter$1(this, arguments, void 0, function* (archiveId, optionalsInput = {}) {
                const optionals = new DeleteArchiveByIdV2025R0Optionals({
                    headers: optionalsInput.headers,
                    cancellationToken: optionalsInput.cancellationToken,
                });
                const headers = optionals.headers;
                const cancellationToken = optionals.cancellationToken;
                const headersMap = prepareParams(Object.assign({ ['box-version']: toString(headers.boxVersion) }, headers.extraHeaders));
                yield this.networkSession.networkClient.fetch(new FetchOptions({
                    url: ''.concat(this.networkSession.baseUrls.baseUrl, '/2.0/archives/', toString(archiveId)),
                    method: 'DELETE',
                    headers: headersMap,
                    responseFormat: 'no_content',
                    auth: this.auth,
                    networkSession: this.networkSession,
                    cancellationToken: cancellationToken,
                }));
                return void 0;
            });
        }
    }
    function serializeCreateArchiveV2025R0RequestBody(val) {
        return { ['name']: val.name };
    }

    class BoxClient {
        constructor(fields) {
            this.networkSession = new NetworkSession({
                baseUrls: new BaseUrls({}),
            });
            if (fields.auth !== undefined) {
                this.auth = fields.auth;
            }
            if (fields.networkSession !== undefined) {
                this.networkSession = fields.networkSession;
            }
            this.authorization = new AuthorizationManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.files = new FilesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedFiles = new TrashedFilesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.appItemAssociations = new AppItemAssociationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.downloads = new DownloadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.uploads = new UploadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.chunkedUploads = new ChunkedUploadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.listCollaborations = new ListCollaborationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.comments = new CommentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.tasks = new TasksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileVersions = new FileVersionsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileMetadata = new FileMetadataManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileClassifications = new FileClassificationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.skills = new SkillsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileWatermarks = new FileWatermarksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileRequests = new FileRequestsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folders = new FoldersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedFolders = new TrashedFoldersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderMetadata = new FolderMetadataManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderClassifications = new FolderClassificationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedItems = new TrashedItemsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderWatermarks = new FolderWatermarksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.folderLocks = new FolderLocksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.metadataTemplates = new MetadataTemplatesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.classifications = new ClassificationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.metadataCascadePolicies = new MetadataCascadePoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.search = new SearchManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.userCollaborations = new UserCollaborationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.taskAssignments = new TaskAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sharedLinksFiles = new SharedLinksFilesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sharedLinksFolders = new SharedLinksFoldersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.webLinks = new WebLinksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.trashedWebLinks = new TrashedWebLinksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sharedLinksWebLinks = new SharedLinksWebLinksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sharedLinksAppItems = new SharedLinksAppItemsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.users = new UsersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.sessionTermination = new SessionTerminationManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.avatars = new AvatarsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.transfer = new TransferManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.emailAliases = new EmailAliasesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.memberships = new MembershipsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.invites = new InvitesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.groups = new GroupsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.webhooks = new WebhooksManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.events = new EventsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.collections = new CollectionsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.recentItems = new RecentItemsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.retentionPolicies = new RetentionPoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.retentionPolicyAssignments = new RetentionPolicyAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.legalHoldPolicies = new LegalHoldPoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.legalHoldPolicyAssignments = new LegalHoldPolicyAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileVersionRetentions = new FileVersionRetentionsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.fileVersionLegalHolds = new FileVersionLegalHoldsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.shieldInformationBarriers = new ShieldInformationBarriersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.shieldInformationBarrierReports =
                new ShieldInformationBarrierReportsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.shieldInformationBarrierSegments =
                new ShieldInformationBarrierSegmentsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.shieldInformationBarrierSegmentMembers =
                new ShieldInformationBarrierSegmentMembersManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.shieldInformationBarrierSegmentRestrictions =
                new ShieldInformationBarrierSegmentRestrictionsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.devicePinners = new DevicePinnersManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.termsOfServices = new TermsOfServicesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.termsOfServiceUserStatuses = new TermsOfServiceUserStatusesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.collaborationAllowlistEntries =
                new CollaborationAllowlistEntriesManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.collaborationAllowlistExemptTargets =
                new CollaborationAllowlistExemptTargetsManager({
                    auth: this.auth,
                    networkSession: this.networkSession,
                });
            this.storagePolicies = new StoragePoliciesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.storagePolicyAssignments = new StoragePolicyAssignmentsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.zipDownloads = new ZipDownloadsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.signRequests = new SignRequestsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.workflows = new WorkflowsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.signTemplates = new SignTemplatesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.integrationMappings = new IntegrationMappingsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.ai = new AiManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.aiStudio = new AiStudioManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.docgenTemplate = new DocgenTemplateManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.docgen = new DocgenManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.hubs = new HubsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.hubCollaborations = new HubCollaborationsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.hubItems = new HubItemsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.shieldLists = new ShieldListsManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
            this.archives = new ArchivesManager({
                auth: this.auth,
                networkSession: this.networkSession,
            });
        }
        /**
         * Make a custom http request using the client authentication and network session.
         * @param {FetchOptionsInput} fetchOptionsInput Options to be passed to the fetch call
         * @returns {Promise<FetchResponse>}
         */
        makeRequest(fetchOptionsInput) {
            return __awaiter$1(this, void 0, void 0, function* () {
                const fetchOptions = new FetchOptions({
                    url: fetchOptionsInput.url,
                    method: fetchOptionsInput.method,
                    params: fetchOptionsInput.params,
                    headers: fetchOptionsInput.headers,
                    data: fetchOptionsInput.data,
                    fileStream: fetchOptionsInput.fileStream,
                    multipartData: fetchOptionsInput.multipartData,
                    contentType: fetchOptionsInput.contentType,
                    responseFormat: fetchOptionsInput.responseFormat,
                    auth: fetchOptionsInput.auth,
                    networkSession: fetchOptionsInput.networkSession,
                    cancellationToken: fetchOptionsInput.cancellationToken,
                    followRedirects: fetchOptionsInput.followRedirects,
                });
                const auth = fetchOptions.auth == void 0 ? this.auth : fetchOptions.auth;
                const networkSession = fetchOptions.networkSession == void 0
                    ? this.networkSession
                    : fetchOptions.networkSession;
                const enrichedFetchOptions = new FetchOptions({
                    auth: auth,
                    networkSession: networkSession,
                    url: fetchOptions.url,
                    method: fetchOptions.method,
                    params: fetchOptions.params,
                    headers: fetchOptions.headers,
                    data: fetchOptions.data,
                    fileStream: fetchOptions.fileStream,
                    multipartData: fetchOptions.multipartData,
                    contentType: fetchOptions.contentType,
                    responseFormat: fetchOptions.responseFormat,
                    followRedirects: fetchOptions.followRedirects,
                });
                return yield networkSession.networkClient.fetch(enrichedFetchOptions);
            });
        }
        /**
         * Create a new client to impersonate user with the provided ID. All calls made with the new client will be made in context of the impersonated user, leaving the original client unmodified.
         * @param {string} userId ID of an user to impersonate
         * @returns {BoxClient}
         */
        withAsUserHeader(userId) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withAdditionalHeaders({
                    ['As-User']: userId,
                }),
            });
        }
        /**
         * Create a new client with suppressed notifications. Calls made with the new client will not trigger email or webhook notifications
         * @returns {BoxClient}
         */
        withSuppressedNotifications() {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withAdditionalHeaders({
                    ['Box-Notifications']: 'off',
                }),
            });
        }
        /**
           * Create a new client with a custom set of headers that will be included in every API call
           * @param {{
              readonly [key: string]: string;
          }} extraHeaders Custom set of headers that will be included in every API call
           * @returns {BoxClient}
           */
        withExtraHeaders(extraHeaders = {}) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withAdditionalHeaders(extraHeaders),
            });
        }
        /**
         * Create a new client with a custom set of base urls that will be used for every API call
         * @param {BaseUrlsInput} baseUrlsInput Custom set of base urls that will be used for every API call
         * @returns {BoxClient}
         */
        withCustomBaseUrls(baseUrlsInput) {
            const baseUrls = new BaseUrls({
                baseUrl: baseUrlsInput.baseUrl,
                uploadUrl: baseUrlsInput.uploadUrl,
                oauth2Url: baseUrlsInput.oauth2Url,
            });
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withCustomBaseUrls(baseUrls),
            });
        }
        /**
         * Create a new client with a custom proxy that will be used for every API call
         * @param {ProxyConfig} config
         * @returns {BoxClient}
         */
        withProxy(config) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withProxy(config),
            });
        }
        /**
         * Create a new client with a custom set of agent options that will be used for every API call
         * @param {AgentOptions} agentOptions Custom set of agent options that will be used for every API call
         * @returns {BoxClient}
         */
        withCustomAgentOptions(agentOptions) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withCustomAgentOptions(agentOptions),
            });
        }
        /**
         * Create a new client with a custom set of interceptors that will be used for every API call
         * @param {readonly Interceptor[]} interceptors Custom set of interceptors that will be used for every API call
         * @returns {BoxClient}
         */
        withInterceptors(interceptors) {
            return new BoxClient({
                auth: this.auth,
                networkSession: this.networkSession.withInterceptors(interceptors),
            });
        }
    }

    exports.BoxCcgAuth = BoxCcgAuth;
    exports.BoxClient = BoxClient;
    exports.BoxDeveloperTokenAuth = BoxDeveloperTokenAuth;
    exports.BoxJwtAuth = BoxJwtAuth;
    exports.BoxOAuth = BoxOAuth;
    exports.CcgConfig = CcgConfig;
    exports.JwtConfig = JwtConfig;
    exports.OAuthConfig = OAuthConfig;

}));
//# sourceMappingURL=bundle.js.map
