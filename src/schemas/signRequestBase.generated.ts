import { serializeSignRequestPrefillTag } from './signRequestPrefillTag.generated.js';
import { deserializeSignRequestPrefillTag } from './signRequestPrefillTag.generated.js';
import { SignRequestPrefillTag } from './signRequestPrefillTag.generated.js';
import { BoxSdkError } from '../box/errors.js';
import { SerializedData } from '../serialization/json.js';
import { sdIsEmpty } from '../serialization/json.js';
import { sdIsBoolean } from '../serialization/json.js';
import { sdIsNumber } from '../serialization/json.js';
import { sdIsString } from '../serialization/json.js';
import { sdIsList } from '../serialization/json.js';
import { sdIsMap } from '../serialization/json.js';
export interface SignRequestBase {
  /**
   * Indicates if the sender should receive a `prepare_url` in the response to complete document preparation using the UI. */
  readonly isDocumentPreparationNeeded?: boolean;
  /**
   * When specified, the signature request will be redirected to this url when a document is signed. */
  readonly redirectUrl?: string;
  /**
   * The uri that a signer will be redirected to after declining to sign a document. */
  readonly declinedRedirectUrl?: string;
  /**
   * Disables the usage of signatures generated by typing (text). */
  readonly areTextSignaturesEnabled?: boolean;
  /**
   * Subject of sign request email. This is cleaned by sign request. If this field is not passed, a default subject will be used. */
  readonly emailSubject?: string;
  /**
   * Message to include in sign request email. The field is cleaned through sanitization of specific characters. However, some html tags are allowed. Links included in the message are also converted to hyperlinks in the email. The message may contain the following html tags including `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`. Be aware that when the text to html ratio is too high, the email may end up in spam filters. Custom styles on these tags are not allowed. If this field is not passed, a default message will be used. */
  readonly emailMessage?: string;
  /**
   * Reminds signers to sign a document on day 3, 8, 13 and 18. Reminders are only sent to outstanding signers. */
  readonly areRemindersEnabled?: boolean;
  /**
   * Name of the signature request. */
  readonly name?: string;
  /**
   * When a document contains sign-related tags in the content, you can prefill them using this `prefill_tags` by referencing the 'id' of the tag as the `external_id` field of the prefill tag. */
  readonly prefillTags?: readonly SignRequestPrefillTag[];
  /**
   * Set the number of days after which the created signature request will automatically expire if not completed. By default, we do not apply any expiration date on signature requests, and the signature request does not expire. */
  readonly daysValid?: number;
  /**
   * This can be used to reference an ID in an external system that the sign request is related to. */
  readonly externalId?: string;
  /**
   * Forces signers to verify a text message prior to viewing the document. You must specify the phone number of signers to have this setting apply to them. */
  readonly isPhoneVerificationRequiredToView?: boolean;
  /**
   * When a signature request is created from a template this field will indicate the id of that template. */
  readonly templateId?: string;
  /**
   * Used as an optional system name to appear in the signature log next to the signers who have been assigned the `embed_url_external_id`. */
  readonly externalSystemName?: string;
  readonly rawData?: SerializedData;
}
export function serializeSignRequestBase(val: SignRequestBase): SerializedData {
  return {
    ['is_document_preparation_needed']:
      val.isDocumentPreparationNeeded == void 0
        ? void 0
        : val.isDocumentPreparationNeeded,
    ['redirect_url']: val.redirectUrl == void 0 ? void 0 : val.redirectUrl,
    ['declined_redirect_url']:
      val.declinedRedirectUrl == void 0 ? void 0 : val.declinedRedirectUrl,
    ['are_text_signatures_enabled']:
      val.areTextSignaturesEnabled == void 0
        ? void 0
        : val.areTextSignaturesEnabled,
    ['email_subject']: val.emailSubject == void 0 ? void 0 : val.emailSubject,
    ['email_message']: val.emailMessage == void 0 ? void 0 : val.emailMessage,
    ['are_reminders_enabled']:
      val.areRemindersEnabled == void 0 ? void 0 : val.areRemindersEnabled,
    ['name']: val.name == void 0 ? void 0 : val.name,
    ['prefill_tags']:
      val.prefillTags == void 0
        ? void 0
        : (val.prefillTags.map(function (
            item: SignRequestPrefillTag
          ): SerializedData {
            return serializeSignRequestPrefillTag(item);
          }) as readonly any[]),
    ['days_valid']: val.daysValid == void 0 ? void 0 : val.daysValid,
    ['external_id']: val.externalId == void 0 ? void 0 : val.externalId,
    ['is_phone_verification_required_to_view']:
      val.isPhoneVerificationRequiredToView == void 0
        ? void 0
        : val.isPhoneVerificationRequiredToView,
    ['template_id']: val.templateId == void 0 ? void 0 : val.templateId,
    ['external_system_name']:
      val.externalSystemName == void 0 ? void 0 : val.externalSystemName,
  };
}
export function deserializeSignRequestBase(
  val: SerializedData
): SignRequestBase {
  if (!sdIsMap(val)) {
    throw new BoxSdkError({ message: 'Expecting a map for "SignRequestBase"' });
  }
  if (
    !(val.is_document_preparation_needed == void 0) &&
    !sdIsBoolean(val.is_document_preparation_needed)
  ) {
    throw new BoxSdkError({
      message:
        'Expecting boolean for "is_document_preparation_needed" of type "SignRequestBase"',
    });
  }
  const isDocumentPreparationNeeded: undefined | boolean =
    val.is_document_preparation_needed == void 0
      ? void 0
      : val.is_document_preparation_needed;
  if (!(val.redirect_url == void 0) && !sdIsString(val.redirect_url)) {
    throw new BoxSdkError({
      message: 'Expecting string for "redirect_url" of type "SignRequestBase"',
    });
  }
  const redirectUrl: undefined | string =
    val.redirect_url == void 0 ? void 0 : val.redirect_url;
  if (
    !(val.declined_redirect_url == void 0) &&
    !sdIsString(val.declined_redirect_url)
  ) {
    throw new BoxSdkError({
      message:
        'Expecting string for "declined_redirect_url" of type "SignRequestBase"',
    });
  }
  const declinedRedirectUrl: undefined | string =
    val.declined_redirect_url == void 0 ? void 0 : val.declined_redirect_url;
  if (
    !(val.are_text_signatures_enabled == void 0) &&
    !sdIsBoolean(val.are_text_signatures_enabled)
  ) {
    throw new BoxSdkError({
      message:
        'Expecting boolean for "are_text_signatures_enabled" of type "SignRequestBase"',
    });
  }
  const areTextSignaturesEnabled: undefined | boolean =
    val.are_text_signatures_enabled == void 0
      ? void 0
      : val.are_text_signatures_enabled;
  if (!(val.email_subject == void 0) && !sdIsString(val.email_subject)) {
    throw new BoxSdkError({
      message: 'Expecting string for "email_subject" of type "SignRequestBase"',
    });
  }
  const emailSubject: undefined | string =
    val.email_subject == void 0 ? void 0 : val.email_subject;
  if (!(val.email_message == void 0) && !sdIsString(val.email_message)) {
    throw new BoxSdkError({
      message: 'Expecting string for "email_message" of type "SignRequestBase"',
    });
  }
  const emailMessage: undefined | string =
    val.email_message == void 0 ? void 0 : val.email_message;
  if (
    !(val.are_reminders_enabled == void 0) &&
    !sdIsBoolean(val.are_reminders_enabled)
  ) {
    throw new BoxSdkError({
      message:
        'Expecting boolean for "are_reminders_enabled" of type "SignRequestBase"',
    });
  }
  const areRemindersEnabled: undefined | boolean =
    val.are_reminders_enabled == void 0 ? void 0 : val.are_reminders_enabled;
  if (!(val.name == void 0) && !sdIsString(val.name)) {
    throw new BoxSdkError({
      message: 'Expecting string for "name" of type "SignRequestBase"',
    });
  }
  const name: undefined | string = val.name == void 0 ? void 0 : val.name;
  if (!(val.prefill_tags == void 0) && !sdIsList(val.prefill_tags)) {
    throw new BoxSdkError({
      message: 'Expecting array for "prefill_tags" of type "SignRequestBase"',
    });
  }
  const prefillTags: undefined | readonly SignRequestPrefillTag[] =
    val.prefill_tags == void 0
      ? void 0
      : sdIsList(val.prefill_tags)
      ? (val.prefill_tags.map(function (
          itm: SerializedData
        ): SignRequestPrefillTag {
          return deserializeSignRequestPrefillTag(itm);
        }) as readonly any[])
      : [];
  if (!(val.days_valid == void 0) && !sdIsNumber(val.days_valid)) {
    throw new BoxSdkError({
      message: 'Expecting number for "days_valid" of type "SignRequestBase"',
    });
  }
  const daysValid: undefined | number =
    val.days_valid == void 0 ? void 0 : val.days_valid;
  if (!(val.external_id == void 0) && !sdIsString(val.external_id)) {
    throw new BoxSdkError({
      message: 'Expecting string for "external_id" of type "SignRequestBase"',
    });
  }
  const externalId: undefined | string =
    val.external_id == void 0 ? void 0 : val.external_id;
  if (
    !(val.is_phone_verification_required_to_view == void 0) &&
    !sdIsBoolean(val.is_phone_verification_required_to_view)
  ) {
    throw new BoxSdkError({
      message:
        'Expecting boolean for "is_phone_verification_required_to_view" of type "SignRequestBase"',
    });
  }
  const isPhoneVerificationRequiredToView: undefined | boolean =
    val.is_phone_verification_required_to_view == void 0
      ? void 0
      : val.is_phone_verification_required_to_view;
  if (!(val.template_id == void 0) && !sdIsString(val.template_id)) {
    throw new BoxSdkError({
      message: 'Expecting string for "template_id" of type "SignRequestBase"',
    });
  }
  const templateId: undefined | string =
    val.template_id == void 0 ? void 0 : val.template_id;
  if (
    !(val.external_system_name == void 0) &&
    !sdIsString(val.external_system_name)
  ) {
    throw new BoxSdkError({
      message:
        'Expecting string for "external_system_name" of type "SignRequestBase"',
    });
  }
  const externalSystemName: undefined | string =
    val.external_system_name == void 0 ? void 0 : val.external_system_name;
  return {
    isDocumentPreparationNeeded: isDocumentPreparationNeeded,
    redirectUrl: redirectUrl,
    declinedRedirectUrl: declinedRedirectUrl,
    areTextSignaturesEnabled: areTextSignaturesEnabled,
    emailSubject: emailSubject,
    emailMessage: emailMessage,
    areRemindersEnabled: areRemindersEnabled,
    name: name,
    prefillTags: prefillTags,
    daysValid: daysValid,
    externalId: externalId,
    isPhoneVerificationRequiredToView: isPhoneVerificationRequiredToView,
    templateId: templateId,
    externalSystemName: externalSystemName,
  } satisfies SignRequestBase;
}
